<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeiXi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiangjunhong.com/"/>
  <updated>2020-04-26T15:16:17.095Z</updated>
  <id>https://www.xiangjunhong.com/</id>
  
  <author>
    <name>北徯。</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机系统基础学习笔记(2)-数据的位运算操作</title>
    <link href="https://www.xiangjunhong.com/posts/206ff928.html"/>
    <id>https://www.xiangjunhong.com/posts/206ff928.html</id>
    <published>2020-04-20T16:00:00.000Z</published>
    <updated>2020-04-26T15:16:17.095Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>C语言的位运算操作包括两类，逻辑运算操作和逻辑移位操作。</p><h3 id="逻辑运算操作"><a href="#逻辑运算操作" class="headerlink" title="逻辑运算操作"></a>逻辑运算操作</h3><p>C语言提供了四种按位逻辑操作符，分别是按位取反，按位与，按位或，按位异或。在编译时，编译器会根据操作数的宽度分别转换为不同的指令。</p><table><thead><tr><th>操作</th><th>C语言操作符</th><th>汇编指令</th></tr></thead><tbody><tr><td>按位取反</td><td>~</td><td>notb、notw、notl</td></tr><tr><td>按位与</td><td>&amp;</td><td>andb、andw、andl</td></tr><tr><td>按位或</td><td>|</td><td>orb、orw、orl</td></tr><tr><td>按位异或</td><td>^</td><td>xorb、xorw、xorl</td></tr></tbody></table><blockquote><p>注意: C语言的逻辑与(&amp;&amp;)、逻辑或(||)、逻辑非(!)并没有对应的机器指令，而是由多条指令联合来实现这些功能，完成以变量为单位的逻辑操作。</p></blockquote><a id="more"></a><p>下面我们以一个简单的C语言程序test.c来了解逻辑运算操作过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> c=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a = ~a;</span><br><span class="line">b = ~b;</span><br><span class="line">c = ~c;</span><br><span class="line">d = a&amp;b;</span><br><span class="line">d = a^b;</span><br><span class="line">d = a|b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>利用gcc命令将其进行编译成可执行文件。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o0 -m32 -g test.c -o test</span><br></pre></td></tr></table></figure></div><p>利用objdump命令进行反汇编并将其重定向到test.txt文件方便查看。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -S test&gt;test.txt</span><br></pre></td></tr></table></figure></div><p>main函数所对应的汇编指令如下所示。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">000004ed &lt;main&gt;:</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void main() </span><br><span class="line">&#123;</span><br><span class="line"> 4ed:55                   push   %ebp</span><br><span class="line"> 4ee:89 e5                mov    %esp,%ebp</span><br><span class="line"> 4f0:83 ec 10             sub    $0x10,%esp</span><br><span class="line"> 4f3:e8 48 00 00 00       call   540 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 4f8:05 e4 1a 00 00       add    $0x1ae4,%eax</span><br><span class="line">int a=5;</span><br><span class="line"> 4fd:c7 45 f4 05 00 00 00 movl   $0x5,-0xc(%ebp)</span><br><span class="line">unsigned int b=3;</span><br><span class="line"> 504:c7 45 f8 03 00 00 00 movl   $0x3,-0x8(%ebp)</span><br><span class="line">short c=5;</span><br><span class="line"> 50b:66 c7 45 f2 05 00    movw   $0x5,-0xe(%ebp)</span><br><span class="line">int d=0;</span><br><span class="line"> 511:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">a = ~a;</span><br><span class="line"> 518:f7 55 f4             notl   -0xc(%ebp)</span><br><span class="line">b = ~b;</span><br><span class="line"> 51b:f7 55 f8             notl   -0x8(%ebp)</span><br><span class="line">c = ~c;</span><br><span class="line"> 51e:66 f7 55 f2          notw   -0xe(%ebp)</span><br><span class="line">d = a&amp;b;</span><br><span class="line"> 522:8b 45 f4             mov    -0xc(%ebp),%eax</span><br><span class="line"> 525:23 45 f8             and    -0x8(%ebp),%eax</span><br><span class="line"> 528:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line">d = a^b;</span><br><span class="line"> 52b:8b 45 f4             mov    -0xc(%ebp),%eax</span><br><span class="line"> 52e:33 45 f8             xor    -0x8(%ebp),%eax</span><br><span class="line"> 531:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line">d = a|b;</span><br><span class="line"> 534:8b 45 f4             mov    -0xc(%ebp),%eax</span><br><span class="line"> 537:0b 45 f8             or     -0x8(%ebp),%eax</span><br><span class="line"> 53a:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line"> 53d:90                   nop</span><br><span class="line">&#125;</span><br><span class="line"> 53e:c9                   leave  </span><br><span class="line"> 53f:c3                   ret</span><br></pre></td></tr></table></figure></div><p>由以上代码可以看出a,b,c取反的三个操作分别对应以下指令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = ~a;</span><br><span class="line">518:f7 55 f4             notl   -0xc(%ebp)</span><br><span class="line">b = ~b;</span><br><span class="line">51b:f7 55 f8             notl   -0x8(%ebp)</span><br><span class="line">c = ~c;</span><br><span class="line">51e:66 f7 55 f2          notw   -0xe(%ebp)</span><br></pre></td></tr></table></figure></div><p>其中变量a和变量b的取反指令都是notl,处理的是4字节的变量。而变量c的取反指令执行的是notw,执行的是2字节的变量。这也就说明了编译器会根据操作数的宽度分别转换为不同的指令。</p><p>下表给出C语言基本数据和类型和IA-32操作数类型的对应关系</p><table><thead><tr><th>C语言声明</th><th>汇编指令长度后缀</th><th>存储长度</th></tr></thead><tbody><tr><td>(unsigned) char</td><td>b</td><td>8</td></tr><tr><td>(unsigned) short</td><td>w</td><td>16</td></tr><tr><td>(unsigned) int</td><td>l</td><td>32</td></tr><tr><td>(unsigned) long int</td><td>l</td><td>32</td></tr><tr><td>(unsigned) long long int</td><td>-</td><td>2 $\times$ 32</td></tr><tr><td>char *</td><td>l</td><td>32</td></tr><tr><td>float</td><td>s</td><td>32</td></tr><tr><td>double</td><td>l</td><td>64</td></tr><tr><td>long double</td><td>t</td><td>80/96</td></tr></tbody></table><p>仍然以下面这样一个简单的C语言程序来理解逻辑与(&amp;&amp;)、逻辑或(||)、逻辑非(!)和按位逻辑操作符的区别。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">short</span> c=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a = !a;</span><br><span class="line">b = !b;</span><br><span class="line">c = !c;</span><br><span class="line">d = a&amp;&amp;b;</span><br><span class="line">d = a||b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>利用gcc命令将其进行编译，objdump命令进行反汇编之后，main函数所对应的汇编指令如下所示。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">000004ed &lt;main&gt;:</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void main() </span><br><span class="line">&#123;</span><br><span class="line"> 4ed:55                   push   %ebp</span><br><span class="line"> 4ee:89 e5                mov    %esp,%ebp</span><br><span class="line"> 4f0:83 ec 10             sub    $0x10,%esp</span><br><span class="line"> 4f3:e8 82 00 00 00       call   57a &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 4f8:05 e4 1a 00 00       add    $0x1ae4,%eax</span><br><span class="line">int a=5;</span><br><span class="line"> 4fd:c7 45 f4 05 00 00 00 movl   $0x5,-0xc(%ebp)</span><br><span class="line">unsigned int b=3;</span><br><span class="line"> 504:c7 45 f8 03 00 00 00 movl   $0x3,-0x8(%ebp)</span><br><span class="line">short c=5;</span><br><span class="line"> 50b:66 c7 45 f2 05 00    movw   $0x5,-0xe(%ebp)</span><br><span class="line">int d=0;</span><br><span class="line"> 511:c7 45 fc 00 00 00 00 movl   $0x0,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">a = !a;</span><br><span class="line"> 518:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line"> 51c:0f 94 c0             sete   %al</span><br><span class="line"> 51f:0f b6 c0             movzbl %al,%eax</span><br><span class="line"> 522:89 45 f4             mov    %eax,-0xc(%ebp)</span><br><span class="line">b = !b;</span><br><span class="line"> 525:83 7d f8 00          cmpl   $0x0,-0x8(%ebp)</span><br><span class="line"> 529:0f 94 c0             sete   %al</span><br><span class="line"> 52c:0f b6 c0             movzbl %al,%eax</span><br><span class="line"> 52f:89 45 f8             mov    %eax,-0x8(%ebp)</span><br><span class="line">c = !c;</span><br><span class="line"> 532:66 83 7d f2 00       cmpw   $0x0,-0xe(%ebp)</span><br><span class="line"> 537:0f 94 c0             sete   %al</span><br><span class="line"> 53a:0f b6 c0             movzbl %al,%eax</span><br><span class="line"> 53d:66 89 45 f2          mov    %ax,-0xe(%ebp)</span><br><span class="line">d = a&amp;&amp;b;</span><br><span class="line"> 541:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line"> 545:74 0d                je     554 &lt;main+0x67&gt;</span><br><span class="line"> 547:83 7d f8 00          cmpl   $0x0,-0x8(%ebp)</span><br><span class="line"> 54b:74 07                je     554 &lt;main+0x67&gt;</span><br><span class="line"> 54d:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 552:eb 05                jmp    559 &lt;main+0x6c&gt;</span><br><span class="line"> 554:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 559:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line">d = a||b;</span><br><span class="line"> 55c:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line"> 560:75 06                jne    568 &lt;main+0x7b&gt;</span><br><span class="line"> 562:83 7d f8 00          cmpl   $0x0,-0x8(%ebp)</span><br><span class="line"> 566:74 07                je     56f &lt;main+0x82&gt;</span><br><span class="line"> 568:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line"> 56d:eb 05                jmp    574 &lt;main+0x87&gt;</span><br><span class="line"> 56f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line"> 574:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">return;</span><br></pre></td></tr></table></figure></div><p><strong>机器指令逻辑非(!)实现的操作解释,以a = !a这个作为例子：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = !a;</span><br><span class="line">518:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line">51c:0f 94 c0             sete   %al</span><br><span class="line">51f:0f b6 c0             movzbl %al,%eax</span><br><span class="line">522:89 45 f4             mov    %eax,-0xc(%ebp)</span><br></pre></td></tr></table></figure></div><p>首先将变量a与常数0进行比较，如果相等就置寄存器al为1，不等则置为0，然后再把寄存器al的值扩展0扩展送到eax寄存器中，再从寄存器eax中送回到变量a的地址当中。</p><p><strong>机器指令逻辑与(&amp;&amp;)实现的操作解释，以d = a&amp;&amp;b来解释。</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = a&amp;&amp;b;</span><br><span class="line">541:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line">545:74 0d                je     554 &lt;main+0x67&gt;</span><br><span class="line">547:83 7d f8 00          cmpl   $0x0,-0x8(%ebp)</span><br><span class="line">54b:74 07                je     554 &lt;main+0x67&gt;</span><br><span class="line">54d:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">552:eb 05                jmp    559 &lt;main+0x6c&gt;</span><br><span class="line">554:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">559:89 45 fc             mov    %eax,-0x4(%ebp)</span><br></pre></td></tr></table></figure></div><p>首先将变量a与0进行相比，如果变量a等于0，就跳到554这个位置，也就是执行指令<font color="red">mov $0x0,%eax</font>，就是把0送到寄存器eax里面，再送到变量d当中。如果变量a不等于0，就用变量b与0相比，如果b等于0，也是跳转到554这个位置去将最终的结果设置为0，如果变量b也不等于0，就把1送到寄存器eax当中，将最终的结果设置为1。</p><p><strong>机器指令逻辑或(||)实现的操作解释，以d = a||b来解释</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d = a||b;</span><br><span class="line">55c:83 7d f4 00          cmpl   $0x0,-0xc(%ebp)</span><br><span class="line">560:75 06                jne    568 &lt;main+0x7b&gt;</span><br><span class="line">562:83 7d f8 00          cmpl   $0x0,-0x8(%ebp)</span><br><span class="line">566:74 07                je     56f &lt;main+0x82&gt;</span><br><span class="line">568:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">56d:eb 05                jmp    574 &lt;main+0x87&gt;</span><br><span class="line">56f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">574:89 45 fc             mov    %eax,-0x4(%ebp)</span><br></pre></td></tr></table></figure></div><p>首先将变量a与0进行相比，如果变量a不等于0，就跳转到568这个位置，也就是执行指令<font color="red">mov $0x1,%eax</font>，把1送到寄存器eax里面，无条件转到574这个位置，并将eax的值送到变量d当中。如果变量a等于0,就将变量b与0比较，如果b等于0，就跳转到56f这个位置，去将最终的结果设置为0。</p><h3 id="逻辑移位操作"><a href="#逻辑移位操作" class="headerlink" title="逻辑移位操作"></a>逻辑移位操作</h3><p>C语言的移位操作包括逻辑左移，算术左移，逻辑右移，算术右移等四种。</p><table><thead><tr><th>操作</th><th>C语言操作符</th><th>汇编指令</th></tr></thead><tbody><tr><td>逻辑左移</td><td>&lt;&lt;</td><td>shlb、shlw、shll</td></tr><tr><td>算术左移</td><td>&lt;&lt;</td><td>salb、salw、sall</td></tr><tr><td>逻辑右移</td><td>&gt;&gt;</td><td>shrb、shrw、shrl</td></tr><tr><td>算术右移</td><td>&gt;&gt;</td><td>sarb、sarw、sarl</td></tr></tbody></table><blockquote><p>注意：IA-32中的其他移位指令没有对应的C语言操作，如想实现循环移位指令，需要编写多条语句来实现。</p></blockquote><p>逻辑移位和算术移位的C语言操作符相同，编译器会根据操作数的不同来选择不同的指令。<font color="#DB7093">无符号数采用逻辑移位指令，有符号数采用算术移位指令。逻辑和算术的区别在于友移时最高位补0还是补符号位。算术右移补入符号位，逻辑右移补入0</font>。</p><p>我们仍然以一个简单的C语言指令来为大家介绍逻辑移位操作的汇编指令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> c = <span class="number">0x8000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> d = <span class="number">0x8000</span>;</span><br><span class="line"></span><br><span class="line">a=a&gt;&gt;<span class="number">4</span>;</span><br><span class="line">b=b&gt;&gt;<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">a=c;</span><br><span class="line">a=d;</span><br><span class="line">b=c;</span><br><span class="line">b=d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>利用gcc命令将其进行编译，objdump命令进行反汇编之后，main函数所对应的汇编指令如下所示</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">000004ed &lt;main&gt;:</span><br><span class="line"><span class="meta">#</span><span class="bash">include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> 4ed:55                   push   %ebp</span><br><span class="line"> 4ee:89 e5                mov    %esp,%ebp</span><br><span class="line"> 4f0:83 ec 10             sub    $0x10,%esp</span><br><span class="line"> 4f3:e8 46 00 00 00       call   53e &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line"> 4f8:05 e4 1a 00 00       add    $0x1ae4,%eax</span><br><span class="line">int a = 0x80000000;</span><br><span class="line"> 4fd:c7 45 f8 00 00 00 80 movl   $0x80000000,-0x8(%ebp)</span><br><span class="line">unsigned int b = 0x80000000;</span><br><span class="line"> 504:c7 45 fc 00 00 00 80 movl   $0x80000000,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">short c = 0x8000;</span><br><span class="line"> 50b:66 c7 45 f4 00 80    movw   $0x8000,-0xc(%ebp)</span><br><span class="line">unsigned short d = 0x8000;</span><br><span class="line"> 511:66 c7 45 f6 00 80    movw   $0x8000,-0xa(%ebp)</span><br><span class="line"></span><br><span class="line">a=a&gt;&gt;4;</span><br><span class="line"> 517:c1 7d f8 04          sarl   $0x4,-0x8(%ebp)</span><br><span class="line">b=b&gt;&gt;4;</span><br><span class="line"> 51b:c1 6d fc 04          shrl   $0x4,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">a=c;</span><br><span class="line"> 51f:0f bf 45 f4          movswl -0xc(%ebp),%eax</span><br><span class="line"> 523:89 45 f8             mov    %eax,-0x8(%ebp)</span><br><span class="line">a=d;</span><br><span class="line"> 526:0f b7 45 f6          movzwl -0xa(%ebp),%eax</span><br><span class="line"> 52a:89 45 f8             mov    %eax,-0x8(%ebp)</span><br><span class="line">b=c;</span><br><span class="line"> 52d:0f bf 45 f4          movswl -0xc(%ebp),%eax</span><br><span class="line"> 531:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line">b=d;</span><br><span class="line"> 534:0f b7 45 f6          movzwl -0xa(%ebp),%eax</span><br><span class="line"> 538:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line"></span><br><span class="line">return;</span><br></pre></td></tr></table></figure></div><p>从<font color="red">sarl $0x4,-0x8(%ebp)</font>这条指令可以清楚的看到当执行a右移4位的操作时，因为a是有符号数，所以执行的就是算术右移，对应的汇编指令sarl。而执行b右移时，因为b是无符号数，所以执行的是逻辑右移指令，对应汇编指令shrl。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a=c;</span><br><span class="line">51f:0f bf 45 f4          movswl -0xc(%ebp),%eax</span><br><span class="line">523:89 45 f8             mov    %eax,-0x8(%ebp)</span><br><span class="line">a=d;</span><br><span class="line">526:0f b7 45 f6          movzwl -0xa(%ebp),%eax</span><br><span class="line">52a:89 45 f8             mov    %eax,-0x8(%ebp)</span><br><span class="line">b=c;</span><br><span class="line">52d:0f bf 45 f4          movswl -0xc(%ebp),%eax</span><br><span class="line">531:89 45 fc             mov    %eax,-0x4(%ebp)</span><br><span class="line">b=d;</span><br><span class="line">534:0f b7 45 f6          movzwl -0xa(%ebp),%eax</span><br><span class="line">538:89 45 fc             mov    %eax,-0x4(%ebp)</span><br></pre></td></tr></table></figure></div><p>由这8条指令可以看出，在执行a=c的时候，执行的是符号扩展指令，z=d时执行的是零扩展指令，b=c时执行的是符号扩展指令，b=d时执行的是零扩展指令。因此我们可以看出,<font color="#DB7093">执行符号扩展还是零扩展是由等号右边的变量类型决定的，与等号左边的变量类型无关</font>。</p><h3 id="位运算的作用"><a href="#位运算的作用" class="headerlink" title="位运算的作用"></a>位运算的作用</h3><ol><li><strong>可实现特定的功能</strong>：取特定位、保留特定位</li><li><strong>周期短速度快</strong>：左移、右移可用于实现快速的整数乘、除法</li><li><strong>可实现其他功能</strong>：原位交换</li></ol><h5 id="PS：交换变量a和变量b的值"><a href="#PS：交换变量a和变量b的值" class="headerlink" title="PS：交换变量a和变量b的值"></a>PS：交换变量a和变量b的值</h5><p>普通方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a; a = b; b = c;</span><br></pre></td></tr></table></figure></div><p>位操作交换法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a^b; b = b^a; a = a^b;</span><br></pre></td></tr></table></figure></div><p>位操作法原理：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = b^(a^b) = b^a^b = b^b^a = a</span><br><span class="line">a = (a^b)^(b^(a^b)) = a^b^b^a^b = b</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">我可以耐心等，幸福可以来得慢一些，只要它是真的!</font></strong><br>以上内容就是本次我给大家分享的计算机系统基础学习的笔记-数据的位运算操作，小编也是初次入门，有什么地方写的不对的，还请多多指教。另外需要各种资料的童鞋，可以关注我的微信公众号<strong>北徯</strong>，免费的PPT模板，各种资料等你来领。</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;C语言的位运算操作包括两类，逻辑运算操作和逻辑移位操作。&lt;/p&gt;&lt;h3 id=&quot;逻辑运算操作&quot;&gt;&lt;a href=&quot;#逻辑运算操作&quot; class=&quot;headerlink&quot; title=&quot;逻辑运算操作&quot;&gt;&lt;/a&gt;逻辑运算操作&lt;/h3&gt;&lt;p&gt;C语言提供了四种按位逻辑操作符，分别是按位取反，按位与，按位或，按位异或。在编译时，编译器会根据操作数的宽度分别转换为不同的指令。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作&lt;/th&gt;&lt;th&gt;C语言操作符&lt;/th&gt;&lt;th&gt;汇编指令&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;按位取反&lt;/td&gt;&lt;td&gt;~&lt;/td&gt;&lt;td&gt;notb、notw、notl&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;按位与&lt;/td&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;&lt;td&gt;andb、andw、andl&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;按位或&lt;/td&gt;&lt;td&gt;|&lt;/td&gt;&lt;td&gt;orb、orw、orl&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;按位异或&lt;/td&gt;&lt;td&gt;^&lt;/td&gt;&lt;td&gt;xorb、xorw、xorl&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote&gt;&lt;p&gt;注意: C语言的逻辑与(&amp;amp;&amp;amp;)、逻辑或(||)、逻辑非(!)并没有对应的机器指令，而是由多条指令联合来实现这些功能，完成以变量为单位的逻辑操作。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机系统笔记" scheme="https://www.xiangjunhong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机系统" scheme="https://www.xiangjunhong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据的位运算操作" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop学习笔记(2)-HDFS的基本操作(Shell命令)</title>
    <link href="https://www.xiangjunhong.com/posts/1fa5155e.html"/>
    <id>https://www.xiangjunhong.com/posts/1fa5155e.html</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-04-20T05:33:09.223Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>在这里我给大家继续分享一些关于HDFS分布式文件的经验哈，其中包括一些hdfs的基本的shell命令的操作，再加上hdfs java程序设计。在前面我已经写了关于如何去搭建hadoop这样一个大数据平台，还没搭好环境的童鞋可以转到我写的这篇文章<a href="https://www.xiangjunhong.com/posts/ae1da46b.html">Hadoop在Ubuntu的安装</a>，接下来就开始我们本次的经验分享啦。</p><h3 id="HDFS的Shell命令操作"><a href="#HDFS的Shell命令操作" class="headerlink" title="HDFS的Shell命令操作"></a>HDFS的Shell命令操作</h3><h4 id="HDFS的格式化与启动"><a href="#HDFS的格式化与启动" class="headerlink" title="HDFS的格式化与启动"></a>HDFS的格式化与启动</h4><p>首次使用HDFS时，需要使用format 命令进行格式化</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvSnAzWnc2YlBnMktvSVRjLnBuZw?x-oss-process=image/format,png" alt=" "></p><a id="more"></a><p>使用start-dfs.sh命令启动HDFS，可使用JPS命令查看是否成功启动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></div><p>下面的图片是启动失败的截图，那么怎么解决这个问题呢。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvQXZLWk5wNVFUWHNuQkU3LnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="HDFS启动失败"><a href="#HDFS启动失败" class="headerlink" title="HDFS启动失败"></a>HDFS启动失败</h4><p>首先需要停止hdfs，这也是操作完hdfs的必要步骤。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/stop-dfs.sh</span><br></pre></td></tr></table></figure></div><p>删除tmp/dfs目录下的data文件夹</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r ./tmp/dfs/data</span><br></pre></td></tr></table></figure></div><p>最后重新执行HDFS的格式化与启动操作。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvUjdCandnb2YxM1c2NUpoLnBuZw?x-oss-process=image/format,png" alt=" "><br>启动成功包括出现NameNode、SecondDaryNameNode、以及DataNode。</p><h4 id="HDFS支持的命令"><a href="#HDFS支持的命令" class="headerlink" title="HDFS支持的命令"></a>HDFS支持的命令</h4><p>查看hdfs支持的所有命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvMWhLeG5lOU1yYXBsQ3F1LnBuZw?x-oss-process=image/format,png" alt=" "></p><p>Ps:查看hadoop下</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```shell</span><br><span class="line">./bin/hadoop fs -help put</span><br></pre></td></tr></table></figure></div><p></p><h4 id="HDFS文件系统中目录创建操作"><a href="#HDFS文件系统中目录创建操作" class="headerlink" title="HDFS文件系统中目录创建操作"></a>HDFS文件系统中目录创建操作</h4><h5 id="创建用户目录"><a href="#创建用户目录" class="headerlink" title="创建用户目录"></a>创建用户目录</h5><p>Hadoop系统安装好以后，第一次使用HDFS时，需要首先在HDFS中创建用户目录。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir -p /user/hadoop</span><br></pre></td></tr></table></figure></div><p>用查询命令查看我们在路径user下面创建的文件夹hadoop</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -ls /user</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvQWJWWTh1NDNRczlPbjVqLnBuZw?x-oss-process=image/format,png" alt=" "></p><h5 id="创建二级目录"><a href="#创建二级目录" class="headerlink" title="创建二级目录"></a>创建二级目录</h5><p>在hadoop目录下再创建一个input文件夹</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir /user/hadoop/input</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvVWg4SmRjMXdBR2tSZVo1LnBuZw?x-oss-process=image/format,png" alt=" "></p><h5 id="根目录下创建目录"><a href="#根目录下创建目录" class="headerlink" title="根目录下创建目录"></a>根目录下创建目录</h5><p>在hadoop根目录下创建一个input文件夹</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -mkdir /input</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAveU5RWldMcFZHY2lPTThKLnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="HDFS文件系统中目录删除操作"><a href="#HDFS文件系统中目录删除操作" class="headerlink" title="HDFS文件系统中目录删除操作"></a>HDFS文件系统中目录删除操作</h4><p>删除在hadoop根目录下面创建的input文件夹</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -rm -r /input</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvS09xWW92UkxpQ053RVdHLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>可以看到，hadoop根目录下的input文件夹已经被我们成功删除，现在只有存在user目录。</p><h4 id="Hadoop的文件操作"><a href="#Hadoop的文件操作" class="headerlink" title="Hadoop的文件操作"></a>Hadoop的文件操作</h4><h5 id="创建文件的方式"><a href="#创建文件的方式" class="headerlink" title="创建文件的方式"></a>创建文件的方式</h5><p>在当前环境目录下创建hello.txt文件，这里介绍两种方法。<br><strong>number one</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch hello.txt</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvdFE1Vm9BY1JEV3lzRnYxLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>打开hello.txt文件，并写入如下内容并保存。</p><blockquote><p>hello world</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit hello.txt</span><br></pre></td></tr></table></figure></div><p><strong>number t two</strong><br>利用vim编辑创建hello.txt。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim hello.txt</span><br></pre></td></tr></table></figure></div><p>关于vim怎么建立简单的文本文件我就不在这里解释了，不会的童鞋可以找找度娘。</p><h5 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h5><p>利用put命令将创建的hello.txt文件上传到user/hadoop/input的目录</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -put ./hello.txt  /user/hadoop/input</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/hdfs dfs -ls /user/hadoop/input</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvTFFBc0ZVb3BNejR1VFJZLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>在user/hadoop/input目录下利用cat命令查看hello.txt文件内容</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs  -cat /user/hadoop/input/hello.txt</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvYkxWVURZUmdsdWMzdFQxLnBuZw?x-oss-process=image/format,png" alt=" "></p><h5 id="HDFS中的文件下载到本地文件系统"><a href="#HDFS中的文件下载到本地文件系统" class="headerlink" title="HDFS中的文件下载到本地文件系统"></a>HDFS中的文件下载到本地文件系统</h5><p>使用-get命令将HDFS中的hello.txt文件下载到本地文件系统中的/home/hadoop/Desktop这个目录下:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="POWERSHELL"><figure class="iseeu highlight /powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs dfs -get /user/hadoop/input/hello.txt /home/hadoop/Desktop</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvNGtJR0RNUFU4NmVidnVULnBuZw?x-oss-process=image/format,png" alt=" "></p><div class="note success"><p><strong><font color="#5cb85c">天再高又怎样，踮起脚尖就更接近阳光!</font></strong><br>到这里，关于hadoop基本的shell命令介绍就结束了。如果有哪里写的不好的的地方，希望各位童鞋提出来哇，我加以改正！我们一起交流，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在这里我给大家继续分享一些关于HDFS分布式文件的经验哈，其中包括一些hdfs的基本的shell命令的操作，再加上hdfs java程序设计。在前面我已经写了关于如何去搭建hadoop这样一个大数据平台，还没搭好环境的童鞋可以转到我写的这篇文章&lt;a href=&quot;https://www.xiangjunhong.com/posts/ae1da46b.html&quot;&gt;Hadoop在Ubuntu的安装&lt;/a&gt;，接下来就开始我们本次的经验分享啦。&lt;/p&gt;&lt;h3 id=&quot;HDFS的Shell命令操作&quot;&gt;&lt;a href=&quot;#HDFS的Shell命令操作&quot; class=&quot;headerlink&quot; title=&quot;HDFS的Shell命令操作&quot;&gt;&lt;/a&gt;HDFS的Shell命令操作&lt;/h3&gt;&lt;h4 id=&quot;HDFS的格式化与启动&quot;&gt;&lt;a href=&quot;#HDFS的格式化与启动&quot; class=&quot;headerlink&quot; title=&quot;HDFS的格式化与启动&quot;&gt;&lt;/a&gt;HDFS的格式化与启动&lt;/h4&gt;&lt;p&gt;首次使用HDFS时，需要使用format 命令进行格式化&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./bin/hdfs namenode -format&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMjAvSnAzWnc2YlBnMktvSVRjLnBuZw?x-oss-process=image/format,png&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.xiangjunhong.com/categories/Ubuntu/"/>
    
      <category term="Hadoop学习笔记" scheme="https://www.xiangjunhong.com/categories/Ubuntu/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/tags/Mac/"/>
    
      <category term="Hadoop的shell命令使用" scheme="https://www.xiangjunhong.com/tags/Hadoop%E7%9A%84shell%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Parallels Desktop的安装</title>
    <link href="https://www.xiangjunhong.com/posts/201e1121.html"/>
    <id>https://www.xiangjunhong.com/posts/201e1121.html</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-04-20T02:26:26.682Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p><font color="green">Parallels Desktop</font>是一款运行在 Mac 电脑上的极为优秀的<font color="red">虚拟机</font>软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。</p><p>Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。</p><h3 id="Parallels-Desktop15的安装"><a href="#Parallels-Desktop15的安装" class="headerlink" title="Parallels Desktop15的安装"></a>Parallels Desktop15的安装</h3><p>小编收集到15.0版本的，更加顺畅，相比较14.0的大的亮点在于首次引入了对 Metal 的支持以提供更快的性能，并集成了 Keychain。相比较此前版本 Microsoft Office 应用快了80%，而 3D 图像渲染快了 15%，更适合最新 Windows 10 更新和 macOS Catalina。</p><h5 id="需要Parallels-Desktop15安装包链接的伙伴关注微信公众号：-北徯-回复关键词：-PD15-即可获取下载链接。"><a href="#需要Parallels-Desktop15安装包链接的伙伴关注微信公众号：-北徯-回复关键词：-PD15-即可获取下载链接。" class="headerlink" title="需要Parallels Desktop15安装包链接的伙伴关注微信公众号： 北徯   回复关键词： PD15 即可获取下载链接。"></a>需要Parallels Desktop15安装包链接的伙伴关注微信公众号： <strong>北徯</strong> 回复关键词： <strong>PD15</strong> 即可获取下载链接。</h5><a id="more"></a><p>下载之后先不要急着安装，现在安装肯定会报软件解析错误等相关的警告，这是因为没有设置<strong>mac安装软件允许任何来源</strong></p><p>解决允许任何来源问题办法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 -&gt; 选择“任何来源”</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.  显示&quot;任何来源&quot;选项在控制台中执行：</span><br><span class="line">  sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div><p>mac安装软件允许任何来源之后就可以安装软件了，打开dmg文件后双击箭头所指，按照提示一步步点击确定就可以啦<br><img src="https://img-blog.csdnimg.cn/20200420090059714.png" alt=" "></p><h3 id="Windows10-镜像文件"><a href="#Windows10-镜像文件" class="headerlink" title="Windows10 镜像文件"></a>Windows10 镜像文件</h3><p>根据自己电脑的情况选择32bit或者64bit的Win10文件，Mac运行内存有16G可以选择64bit，小编之前是选择了32bit,对Windows不想给它分多了,毕竟Mac=亲生的 Windows=捡来的，但是后来我又试了一试64位的，感觉极佳，只是内存耗到的多一点。所以选择那个镜像文件就由你决定啦。</p><p>仍然把我的镜像文件分享给大家，给大家省点麻烦</p><h5 id="需要Win10-64位，或者Win10-32位镜像文件链接的伙伴关注微信公众号：-北徯-分别回复关键词：-Win10-64-或者-Win10-32即可获取下载链接。"><a href="#需要Win10-64位，或者Win10-32位镜像文件链接的伙伴关注微信公众号：-北徯-分别回复关键词：-Win10-64-或者-Win10-32即可获取下载链接。" class="headerlink" title="需要Win10 64位，或者Win10 32位镜像文件链接的伙伴关注微信公众号： 北徯   分别回复关键词： Win10 64 或者 Win10 32即可获取下载链接。"></a>需要Win10 64位，或者Win10 32位镜像文件链接的伙伴关注微信公众号： <strong>北徯</strong> 分别回复关键词： <strong>Win10 64</strong> 或者 <strong>Win10 32</strong>即可获取下载链接。</h5><p>镜像文件下载好好之后就选择相应的镜像文件，之后安装助手就会帮你搞定了，你只需要静静地等待，安装成功后如下图：</p><h4 id="32位系统如下图"><a href="#32位系统如下图" class="headerlink" title="32位系统如下图"></a>32位系统如下图</h4><p><img src="https://img-blog.csdnimg.cn/2020042009010047.png" alt="在这里插入图片描述"></p><h4 id="64位系统如下图"><a href="#64位系统如下图" class="headerlink" title="64位系统如下图"></a>64位系统如下图</h4><p><img src="https://img-blog.csdnimg.cn/20200420090100716.png" alt=" "></p><p>是不是看起来就很nice!</p><h3 id="开启体验之旅"><a href="#开启体验之旅" class="headerlink" title="开启体验之旅"></a>开启体验之旅</h3><p>理论上Parallels Desktop可以让你在苹果的Mac OS系统上同时运行多个 Windows系统，你可以随意在它们之间进行切换，并且能够运行各个平台上几乎所有的应用程序和游戏，让原本枯燥的Mac变得可玩性极高。</p><p>另外，PD支持各种 USB 硬件设备，并且支持 USB-C / USB 3.0。用户可以随意将 USB 设备分配给 Mac 或分配到虚拟机系统里去。例如手机刷ROM、连接老式打印机、使用U盘加密狗等等。</p><p>性能方面，Parallels Desktop支持 DirectX 11，如果你之前对比过其它虚拟机软件，相信你肯定有所感触，PD 在 3D 游戏和图形性能方面比 VMware Fusion、VirtualBox等更加流畅和出色，而且新版本对《守望先锋》、XBox One 游戏串流等进行了专项优化，来保证游戏的流畅性。<br>另外，Parallels Desktop还提供了“一键自动优化”功能，你可以根据不同的用途（效能应用程序、设计或开发，游戏）对 PD 虚拟机进行调整和优化，让它更加适合你的工作场景(我选择的设计开发方面)</p><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次分享给大家的我认为还不错的Mac虚拟机，我后面还会继续分享其他的玩转Mac技巧，如果觉得这篇文章对你有的话就给我一个小小的赞吧，你的鼓励就是我前进的动力。后面我继续加油，坚持就是胜利！另外需要各种资料的童鞋，可以关注我的微信公众号<strong>北徯</strong>，免费的PPT模板，各种资料等你来领。</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;green&quot;&gt;Parallels Desktop&lt;/font&gt;是一款运行在 Mac 电脑上的极为优秀的&lt;font color=&quot;red&quot;&gt;虚拟机&lt;/font&gt;软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。&lt;/p&gt;&lt;p&gt;Parallels Desktop是一款运行在 Mac 电脑上的极为优秀的虚拟机软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。&lt;/p&gt;&lt;h3 id=&quot;Parallels-Desktop15的安装&quot;&gt;&lt;a href=&quot;#Parallels-Desktop15的安装&quot; class=&quot;headerlink&quot; title=&quot;Parallels Desktop15的安装&quot;&gt;&lt;/a&gt;Parallels Desktop15的安装&lt;/h3&gt;&lt;p&gt;小编收集到15.0版本的，更加顺畅，相比较14.0的大的亮点在于首次引入了对 Metal 的支持以提供更快的性能，并集成了 Keychain。相比较此前版本 Microsoft Office 应用快了80%，而 3D 图像渲染快了 15%，更适合最新 Windows 10 更新和 macOS Catalina。&lt;/p&gt;&lt;h5 id=&quot;需要Parallels-Desktop15安装包链接的伙伴关注微信公众号：-北徯-回复关键词：-PD15-即可获取下载链接。&quot;&gt;&lt;a href=&quot;#需要Parallels-Desktop15安装包链接的伙伴关注微信公众号：-北徯-回复关键词：-PD15-即可获取下载链接。&quot; class=&quot;headerlink&quot; title=&quot;需要Parallels Desktop15安装包链接的伙伴关注微信公众号： 北徯   回复关键词： PD15 即可获取下载链接。&quot;&gt;&lt;/a&gt;需要Parallels Desktop15安装包链接的伙伴关注微信公众号： &lt;strong&gt;北徯&lt;/strong&gt; 回复关键词： &lt;strong&gt;PD15&lt;/strong&gt; 即可获取下载链接。&lt;/h5&gt;
    
    </summary>
    
    
      <category term="玩转Mac" scheme="https://www.xiangjunhong.com/categories/%E7%8E%A9%E8%BD%ACMac/"/>
    
    
      <category term="Parallels Desktop" scheme="https://www.xiangjunhong.com/tags/Parallels-Desktop/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统基础学习笔记(1)-基本GCC，objdump，GBD命令的使用</title>
    <link href="https://www.xiangjunhong.com/posts/d66292e9.html"/>
    <id>https://www.xiangjunhong.com/posts/d66292e9.html</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-23T07:14:53.432Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h3 id="基本GCC命令的使用"><a href="#基本GCC命令的使用" class="headerlink" title="基本GCC命令的使用"></a>基本GCC命令的使用</h3><p>GCC是一套由GNU项目开发的编程语言编译器，可处理C语言、<br>C++、Fortran、Pascal、Objective-C、Java等等。GCC通常是 跨平台软件的编译器首选。gcc是GCC套件中的编译驱动程序名。</p><p>若计算机是x86-64位系统，为了编译成IA-32指令集，<br>则请先运行下列命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential module-assistant </span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure></div><p>接下来就以输出hello world这样一个简单的C语言程序hello.c来演示这个过程。</p><a id="more"></a><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello,world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>hello.c这个源文件要经过预处理，编译，汇编，链接四个过程，最终生成可执行目标文件。示意图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200416093809601.png" alt=" "></p><p>Linux中的gcc编译驱动程序可以实现上图过程的每一步，下面分别对其进行解释：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –E hello.c –o hello.i</span><br></pre></td></tr></table></figure></div><p>对hello.c的程序进行预编译，预编译是对源程序以字符#开头的命令进行处理，对于这里来说就是将include后的.h文件内容嵌入到源程序文件中，预处理后的文件还是文本文件，用.i作扩展名,如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20200416093809737.png" alt=" "></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –S hello.i –o hello.s</span><br></pre></td></tr></table></figure></div><p>对hello.i进行编译，生成一个汇编语言源程序，用.s作为扩展名，编译后的文件还是文本文件。<br><img src="https://img-blog.csdnimg.cn/20200416093809890.png" alt="  "></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –c hello.s –o hello.o</span><br></pre></td></tr></table></figure></div><p>对hello.s文件进行汇编，生成一个可重定位目标文件，以.o作为扩展名，汇编后的文件是二进制文件。内容为0，1表示的机器指令，数据和其他信息。</p><p><img src="https://img-blog.csdnimg.cn/2020041609381033.png" alt=" "></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o –o hello</span><br></pre></td></tr></table></figure></div><p>此命令将多个可重定位的目标文件和标准库函数链接合成一个可执行文件。在这个例子中，链接将hello.o文件和标准库函数printf所在的可重定位目标模块printf.o进行链接，生成可执行目标文件hello。</p><p><img src="https://img-blog.csdnimg.cn/20200416093810190.png" alt=" "></p><p>运行可执行文件hello输入指令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure></div><p><img src="https://img-blog.csdnimg.cn/20200416093810332.png" alt=" "></p><p>上面是分步骤转换C语言程序到可执行目标文件，也可以用命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c –o hello</span><br></pre></td></tr></table></figure></div><p>将hello.c直接编译成可执行目标文件hello。</p><p>在用gcc命令编译c程序时，会加入各种选择，例如以下命令:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o0 -m32 -g hello.c -o hello</span><br></pre></td></tr></table></figure></div><p>比如加入-O0,塔表示编译时采用的优化级别，0表示不用编译优化，-m32这个选项表示编译成x86-32位的指令。如果计算机是64位架构的处理器，不加这个选项则会编译成x86-64位的指令集。-g表示带调试信息(单步调试必须加入)。</p><h3 id="objdump命令的使用"><a href="#objdump命令的使用" class="headerlink" title="objdump命令的使用"></a>objdump命令的使用</h3><p>目标文件都是由01序列的机器指令构成，数据和其他信息构成，用文本编辑器打不开，怎样才能看到目标文件的内容呢？答案是可以利用objdump工具来反汇编二进制的目标文件，对可重定位目标文件和可执行的目标文件都可以反汇编。<br>我们利用一个c程序来进行举例，程序名gdbtest.c。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">3</span>,y=<span class="number">5</span>,z;</span><br><span class="line">z=x+y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"z=%d\n"</span>,z);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>利用gcc命令可以分别编译为gdbtest.o的可重定位目标文件和gdbtest可执行目标文件。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E -g -m32 gdbtest.c -o gdbtest.i</span><br><span class="line">gcc -S -g -m32 gdbtest.i -o gdbtest.s</span><br><span class="line">gcc -c -g -m32 gdbtest.s -o gdbtest.o</span><br><span class="line">gcc -o0 -m32 -g gdbtest.c -o gdbtest</span><br></pre></td></tr></table></figure></div><p><img src="https://img-blog.csdnimg.cn/20200416093810491.png" alt=" "></p><blockquote><p>建议在objdump命令中使用-S选项，并与gcc命令中的-g选项一起配合使用。</p></blockquote><p>利用以下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objdump –S gdbtest.o&gt;gdbtesto.txt </span><br><span class="line">objdump –S gdbtest&gt;gdbtest.txt</span><br></pre></td></tr></table></figure></div><p>对这两个文件来进行反汇编，-S表示在反汇编后的内容中添加源代码，方便理解C语言源程序与IA-32机器级指令之间的对应关系。’&gt;’这个符号表示将反汇编后的内容保存在文件中，在这里是保存为文本文件，为了防止内容太多输出到屏幕上不方便阅读。</p><p><img src="https://img-blog.csdnimg.cn/20200416093810647.png" alt=" "></p><p>gdbtest.o的可重定位目标文件的反汇编文件内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200416093810906.png" alt=" "></p><p>可执行目标文件的反汇编内容：</p><p><img src="https://img-blog.csdnimg.cn/20200416093811130.png" alt="  "></p><blockquote><p>可重定位目标文件和可执行目标文件的一个很重要的区别就是指令的地址是不是从0地址开始。可重定位目标文件是完成一个子任务的独立模块，所以每个模块的地址都是从0地址开始，然而可执行目标文件中的的指令和数据都有一个确定的地址，是安装操作系统给定的储存器地址映射分配，也是在调试步骤中可以看到的地址。不是内存的物理地址，是虚拟地址。</p></blockquote><h3 id="GDB调试工具的使用"><a href="#GDB调试工具的使用" class="headerlink" title="GDB调试工具的使用"></a>GDB调试工具的使用</h3><h4 id="启动GDB调试工具"><a href="#启动GDB调试工具" class="headerlink" title="启动GDB调试工具"></a>启动GDB调试工具</h4><p>启动GDB调试工具，加载被调试的可执行文件。</p><table><thead><tr><th></th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>gdb [可执行文件名]</td><td>启动GDB调试工具，并加载可执行文件</td></tr><tr><td>2</td><td>1.gdb<br>2. file [可执行文件名]</td><td>启动GDB调试工具<br>加载可执行文件</td></tr></tbody></table><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><p>设置断点，使程序运行到断点处停下来，方便查看程序运行的状态。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>break main</td><td>在main函数的入口处设置断点</td></tr><tr><td>break gdbtest.c:3</td><td>在源程序gdbtest.c的di sa第3行处设置断点</td></tr></tbody></table><h4 id="启动程序运行"><a href="#启动程序运行" class="headerlink" title="启动程序运行"></a>启动程序运行</h4><p>启动并运行已经加载的程序，程序在执行的设置的第一个断点会停下来。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>run</td><td>启动程序运行，程序在断点处停下</td></tr></tbody></table><h4 id="查看程序运行时的当前状态"><a href="#查看程序运行时的当前状态" class="headerlink" title="查看程序运行时的当前状态"></a>查看程序运行时的当前状态</h4><ol><li><p>程序的当前断点位置<br>含义：反映程序已经执行了哪些指令，下一步要执行哪一条指令。<br>eip寄存器：保存了下一条将要执行的指令的地址。</p><table><thead><tr><th>ir</th><th>显示所有寄存器的内容</th></tr></thead><tbody><tr><td>ir eip</td><td>只显示寄存器eip的内容</td></tr></tbody></table></li><li><p>通用寄存器的内容：ir eax ebx ecx edx(或者ir)</p></li><li><p>存储器的单元内容：x/8xb Oxffd2bc</p><blockquote><p>x命令用于查看储存单元的内容，后跟一些参数选项。<br>数据表示要显示的数据单元的个数。<br>x表示存储单元的内容，十六进制形式。<br>b表示要显示的储存单元的宽度，按字节显示（w:按4字节显示）<br>后面的数据表示要显示的存储单元的起始地址。</p></blockquote><p>x/8xb Oxffd2bc这条内容就是表示从Oxffd2bc地址单元开始，显示8个字节的存储单元内容，并用十六进制表示。</p></li><li><p>查看运行时的当前状态</p><blockquote><p>说明： IA-32用栈来支持过程的嵌套调用，过程的入口参数，返回地址，被保存寄存器的值，被调用过程中的非静态局部变量等都会被保存在栈中。</p></blockquote><blockquote><p>栈帧信息：<br>当前栈帧范围: i r esp ebp //esp栈顶指针和ebp栈底指针<br>当前栈帧字节数:y=R[ebp]-R[esp]+4 //不是命令，是计算方法<br>显示当前栈帧内容:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x/yxb $esp</span><br><span class="line">x/zxw $esp //z=y/4</span><br></pre></td></tr></table></figure></div></blockquote></li></ol><h4 id="继续执行下一条指令或语句"><a href="#继续执行下一条指令或语句" class="headerlink" title="继续执行下一条指令或语句"></a>继续执行下一条指令或语句</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>si</td><td>执行一条机器指令</td></tr><tr><td>s</td><td>执行一条c语句</td></tr></tbody></table><h4 id="退出调试"><a href="#退出调试" class="headerlink" title="退出调试"></a>退出调试</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>quit</td><td>退出GDB调试过程</td></tr></tbody></table><div class="note success"><p><strong><font color="#5cb85c">有挫败才有成长!</font></strong><br>本次给大家分享的内容就到这里啦，觉得还不错的点个赞支持一下小编，你的肯定就是小编前进的动力。另外需要各种资料的童鞋，可以关注我的微信公众号<strong>北徯</strong>，免费的PPT模板，各种资料等你来领。</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基本GCC命令的使用&quot;&gt;&lt;a href=&quot;#基本GCC命令的使用&quot; class=&quot;headerlink&quot; title=&quot;基本GCC命令的使用&quot;&gt;&lt;/a&gt;基本GCC命令的使用&lt;/h3&gt;&lt;p&gt;GCC是一套由GNU项目开发的编程语言编译器，可处理C语言、&lt;br&gt;C++、Fortran、Pascal、Objective-C、Java等等。GCC通常是 跨平台软件的编译器首选。gcc是GCC套件中的编译驱动程序名。&lt;/p&gt;&lt;p&gt;若计算机是x86-64位系统，为了编译成IA-32指令集，&lt;br&gt;则请先运行下列命令:&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install build-essential module-assistant &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install gcc-multilib g++-multilib&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;接下来就以输出hello world这样一个简单的C语言程序hello.c来演示这个过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机系统笔记" scheme="https://www.xiangjunhong.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="GCC命令" scheme="https://www.xiangjunhong.com/tags/GCC%E5%91%BD%E4%BB%A4/"/>
    
      <category term="计算机系统" scheme="https://www.xiangjunhong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="GDB命令" scheme="https://www.xiangjunhong.com/tags/GDB%E5%91%BD%E4%BB%A4/"/>
    
      <category term="obidump命令" scheme="https://www.xiangjunhong.com/tags/obidump%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Sql create table</title>
    <link href="https://www.xiangjunhong.com/posts/e4bced2a.html"/>
    <id>https://www.xiangjunhong.com/posts/e4bced2a.html</id>
    <published>2020-04-09T10:05:36.030Z</published>
    <updated>2020-04-16T06:37:02.878Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h4 id="Sql-create-table-语句"><a href="#Sql-create-table-语句" class="headerlink" title="Sql create table 语句"></a>Sql create table 语句</h4><p>Sql create table 语句用于创建数据库中的表。<br>表由行和列组成，每个表都必须有个表名。</p><h4 id="create-table-语法"><a href="#create-table-语法" class="headerlink" title="create table 语法"></a>create table 语法</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>),</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>),</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>),</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>column_name 参数规定表中列的名称。<br>data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。<br>size 参数规定表中列的最大长度。</p></blockquote><a id="more"></a><h4 id="create-table-实例"><a href="#create-table-实例" class="headerlink" title="create table 实例"></a>create table 实例</h4><p>现在我们想要创建一个名为 “Persons” 的表，包含五列：PersonID、Name、Address 和 City。<br>我们使用下面的 create table语句：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonID <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>PersonID 列的数据类型是 int，包含整数。<br>Name、Address 和 City 列的数据类型是 varchar，包含字符，且这些字段的最大长度为 255 个字符。</p></blockquote><p>空的 “Persons” 表如下所示：</p><table><thead><tr><th>PersonID</th><th>Name</th><th>Address</th><th>City</th></tr></thead></table><p>在Sql server创建表如图所示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvYnlGaDQzWDlvekNmNnZ0LnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><p>可使用 insert into 语句向空表写入数据,这个语法我们在后面的教程会讲到。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-create-table-语句&quot;&gt;&lt;a href=&quot;#Sql-create-table-语句&quot; class=&quot;headerlink&quot; title=&quot;Sql create table 语句&quot;&gt;&lt;/a&gt;Sql create table 语句&lt;/h4&gt;&lt;p&gt;Sql create table 语句用于创建数据库中的表。&lt;br&gt;表由行和列组成，每个表都必须有个表名。&lt;/p&gt;&lt;h4 id=&quot;create-table-语法&quot;&gt;&lt;a href=&quot;#create-table-语法&quot; class=&quot;headerlink&quot; title=&quot;create table 语法&quot;&gt;&lt;/a&gt;create table 语法&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name1 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name2 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name3 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;column_name 参数规定表中列的名称。&lt;br&gt;data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。&lt;br&gt;size 参数规定表中列的最大长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL-create table" scheme="https://www.xiangjunhong.com/tags/SQL-create-table/"/>
    
  </entry>
  
  <entry>
    <title>Sql insert into</title>
    <link href="https://www.xiangjunhong.com/posts/be01953a.html"/>
    <id>https://www.xiangjunhong.com/posts/be01953a.html</id>
    <published>2020-04-09T10:04:39.854Z</published>
    <updated>2020-04-16T06:37:13.897Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h4 id="Sql-insert-into语句"><a href="#Sql-insert-into语句" class="headerlink" title="Sql insert into语句"></a>Sql insert into语句</h4><p>insert into 语句用于向表中插入新记录。</p><h4 id="insert-into-语法"><a href="#insert-into-语法" class="headerlink" title="insert into 语法"></a>insert into 语法</h4><p>insert into 语句可以有两种编写形式。</p><ol><li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">values</span>(value1,value2,value3,...);</span><br></pre></td></tr></table></figure></div><ol start="2"><li>第二种形式需要指定列名及被插入的值：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">values</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></div><a id="more"></a><h4 id="insert-into-实例"><a href="#insert-into-实例" class="headerlink" title="insert into 实例"></a>insert into 实例</h4><p>在本教程中，我们将使用上一节建立的Persons空表进行演示,假设我们要向 “Persons” 表中插入一个新行。<br>我们可以使用下面的 SQL 语句：</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Persons(PersonID,<span class="keyword">Name</span>,Address,City)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">2001</span>,<span class="string">'小明'</span>,<span class="string">'ChongQing'</span>,<span class="string">'Wushan'</span>);</span><br></pre></td></tr></table></figure></div><p>执行以上 SQL，再读取 “Persons” 表，数据如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvZGZvVzc2QWpuRUczdVljLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><h5 id="在指定的列插入数据"><a href="#在指定的列插入数据" class="headerlink" title="在指定的列插入数据"></a>在指定的列插入数据</h5><p>我们也可以在指定的列插入数据。<br>下面的 SQL 语句将插入一个新行，但是只在 “PersonID”、和 “Name” 列插入数据：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Persons(PersonID,<span class="keyword">Name</span>)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">2001</span>,<span class="string">'小花'</span>);</span><br></pre></td></tr></table></figure></div><p>执行以上 SQL，再读取 “Persons” 表，数据如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvSlpLMnY2em1vZWtGZE0zLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-insert-into语句&quot;&gt;&lt;a href=&quot;#Sql-insert-into语句&quot; class=&quot;headerlink&quot; title=&quot;Sql insert into语句&quot;&gt;&lt;/a&gt;Sql insert into语句&lt;/h4&gt;&lt;p&gt;insert into 语句用于向表中插入新记录。&lt;/p&gt;&lt;h4 id=&quot;insert-into-语法&quot;&gt;&lt;a href=&quot;#insert-into-语法&quot; class=&quot;headerlink&quot; title=&quot;insert into 语法&quot;&gt;&lt;/a&gt;insert into 语法&lt;/h4&gt;&lt;p&gt;insert into 语句可以有两种编写形式。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;(value1,value2,value3,...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;第二种形式需要指定列名及被插入的值：&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table_name (column1,column2,column3,...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt; (value1,value2,value3,...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL-insert into" scheme="https://www.xiangjunhong.com/tags/SQL-insert-into/"/>
    
  </entry>
  
  <entry>
    <title>Sql 约束（Constraints)</title>
    <link href="https://www.xiangjunhong.com/posts/6d7376dd.html"/>
    <id>https://www.xiangjunhong.com/posts/6d7376dd.html</id>
    <published>2020-04-09T10:03:01.294Z</published>
    <updated>2020-04-16T06:37:34.182Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h2 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h2><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 create table 语句），或者在表创建之后规定（通过 alter table 语句）。</p><h3 id="create-table-constraint-语法"><a href="#create-table-constraint-语法" class="headerlink" title="create table + constraint 语法"></a>create table + constraint 语法</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>在 SQL 中，我们有如下约束：</p><ul><li>not null - 指示某列不能存储 NULL 值。</li><li>unique - 保证某列的每行必须有唯一的值。</li><li>primary key - not null 和 unique 的结合。确保某列（或两个列多个列的结合）有唯&gt;一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li>foreign key - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li>check - 保证列中的值符合指定的条件。</li><li>default - 规定没有给列赋值时的默认值</li></ul></blockquote><p>接下来，我们依次给大家分享每一种约束。</p><a id="more"></a><h3 id="Sql-not-null-约束"><a href="#Sql-not-null-约束" class="headerlink" title="Sql not null 约束"></a>Sql not null 约束</h3><p>在默认的情况下，表的列接受 NULL 值。not null 约束强制列不接受 NULL 值。not null 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><p>下面的 SQL 强制 “PersonID” 列、 “Name” 列以及 “Address” 列不接受 NULL 值：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonID <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="添加-not-null-约束"><a href="#添加-not-null-约束" class="headerlink" title="添加 not null 约束"></a>添加 not null 约束</h4><p>在一个已创建的表的 “City” 字段中添加 not null 约束如下所示：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><h4 id="删除-not-null-约束"><a href="#删除-not-null-约束" class="headerlink" title="删除 not null 约束"></a>删除 not null 约束</h4><p>在一个已创建的表的 “Age” 字段中删除 NOT NULL 约束如下所示：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="built_in">varchar</span>(<span class="number">255</span>)  <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><blockquote><p>注意：在添加和删除not null约束，我用change和modify命令始终报错，这是因为我用的是sql server数据库，而change和modify命令是在my sql 和oracle下才能用的语法。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvMjRZbmU5N2ZBTlZCMXlXLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><h3 id="Sql-unique-约束"><a href="#Sql-unique-约束" class="headerlink" title="Sql unique 约束"></a>Sql unique 约束</h3><p>unique 约束唯一标识数据库表中的每条记录。unique 和primary key约束均为列或列集合提供了唯一性的保证。primary key 约束拥有自动定义的 unique 约束。请注意，每个表可以有多个 unique约束，但是每个表只能有一个 primary key 约束。</p><h4 id="create-table-时的-unique-约束"><a href="#create-table-时的-unique-约束" class="headerlink" title="create table 时的 unique 约束"></a>create table 时的 unique 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonId” 列上创建unique 约束：</p><h6 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access："><a href="#SQL-Server-Oracle-MS-Access：" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access："><a href="#MySQL-SQL-Server-Oracle-MS-Access：" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID),</span><br><span class="line"><span class="keyword">constraint</span> uc_PersonID <span class="keyword">unique</span> (PersonId,<span class="keyword">Name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="alter-时的-unique-约束"><a href="#alter-时的-unique-约束" class="headerlink" title="alter 时的 unique 约束"></a>alter 时的 unique 约束</h4><p>当表已被创建时，如需在 “PersonID” 列创建unique 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-1"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-1" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">unique</span> (PersonID)</span><br></pre></td></tr></table></figure></div><p>如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-2"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-2" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> uc_PersonID <span class="keyword">unique</span> (PersonId,<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></div><h4 id="撤销-unique-约束"><a href="#撤销-unique-约束" class="headerlink" title="撤销 unique 约束"></a>撤销 unique 约束</h4><p>如需撤销 unique 约束，请使用下面的 SQL：</p><h6 id="MySQL：-1"><a href="#MySQL：-1" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> uc_PersonID</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-1"><a href="#SQL-Server-Oracle-MS-Access：-1" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> uc_PersonID</span><br></pre></td></tr></table></figure></div><h3 id="primary-key-约束"><a href="#primary-key-约束" class="headerlink" title="primary key 约束"></a>primary key 约束</h3><p>primary key 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。</p><h4 id="create-table-时的-primary-key-约束"><a href="#create-table-时的-primary-key-约束" class="headerlink" title="create table 时的 primary key 约束"></a>create table 时的 primary key 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonID” 列上创建 primary key 约束：</p><h6 id="MySQL：-2"><a href="#MySQL：-2" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">primary <span class="keyword">key</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-2"><a href="#SQL-Server-Oracle-MS-Access：-2" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>如需命名 primary key 约束，并定义多个列的 primary key 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-3"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-3" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">constraint</span> pk_PersonID primary <span class="keyword">key</span> (PersonID,<span class="keyword">Name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>注释：在上面的实例中，只有一个主键 primary key（pk_PersonID）。然而，pk_PersonID 的值是由两个列（PersonID和 Name）组成的。</p><h4 id="alter-table-时的-primary-key-约束"><a href="#alter-table-时的-primary-key-约束" class="headerlink" title="alter table 时的 primary key 约束"></a>alter table 时的 primary key 约束</h4><p>当表已被创建时，如需在 “PersonId” 列创建 primary key 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-4"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-4" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> primary <span class="keyword">key</span> (PersonID)</span><br></pre></td></tr></table></figure></div><p>如需命名 primary key 约束，并定义多个列的 primary key 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-5"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-5" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> pk_PersonID primary <span class="keyword">key</span> (PersonID,<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></div><p>注释：如果您使用 alter table 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。</p><h4 id="撤销-primary-key-约束"><a href="#撤销-primary-key-约束" class="headerlink" title="撤销 primary key 约束"></a>撤销 primary key 约束</h4><p>如需撤销 primary key 约束，请使用下面的 SQL：</p><h6 id="MySQL：-3"><a href="#MySQL：-3" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> primary <span class="keyword">key</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-3"><a href="#SQL-Server-Oracle-MS-Access：-3" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> pk_PersonID</span><br></pre></td></tr></table></figure></div><h3 id="foreign-key-约束"><a href="#foreign-key-约束" class="headerlink" title="foreign key 约束"></a>foreign key 约束</h3><p>一个表中的 foreign key 指向另一个表中的 unique key(唯一约束的键)。<br>让我们通过一个实例来解释外键。请看下面两个表：<br>Persons 表：</p><table><thead><tr><th>PersonId</th><th>Name</th><th>Address</th><th>City</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>Timoteivn</td><td>Sandnes</td></tr><tr><td>2</td><td>小红</td><td>Timoteivn</td><td>Sandnes</td></tr><tr><td>3</td><td>小军</td><td>Timoteivn</td><td>Stavanger</td></tr></tbody></table><p>Orders表：</p><table><thead><tr><th>OrderId</th><th>OrderNo</th><th>PersonId</th></tr></thead><tbody><tr><td>1</td><td>77895</td><td>3</td></tr><tr><td>2</td><td>44678</td><td>3</td></tr><tr><td>3</td><td>22456</td><td>2</td></tr><tr><td>4</td><td>24562</td><td>1</td></tr></tbody></table><blockquote><p>请注意:</p><ul><li>Orders”表中的 “PersonId” 列指向 “Persons” 表中的 “PersonId” 列。</li><li>“Persons” 表中的 “PersonId” 列是 “Persons” 表中的 primary key。</li><li>“Orders” 表中的 “PersonId” 列是 “Orders” 表中的 foreign key。</li><li>foreign key约束用于预防破坏表之间连接的行为。</li><li>foreign key约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li></ul></blockquote><h4 id="create-table-时的foreign-key-约束"><a href="#create-table-时的foreign-key-约束" class="headerlink" title="create table 时的foreign key 约束"></a>create table 时的foreign key 约束</h4><p>下面的 SQL 在 “Orders” 表创建时在 “PersonId” 列上创建 foreign key 约束：</p><h6 id="MySQL：-4"><a href="#MySQL：-4" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(OrderId),</span><br><span class="line"> <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId) <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-4"><a href="#SQL-Server-Oracle-MS-Access：-4" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span> <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如需命名foreign key 约束，并定义多个列的foreign key约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-6"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-6" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(OrderId),</span><br><span class="line"> <span class="keyword">constraint</span> fk_PerOrders <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId) <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table时的foreign-key约束"><a href="#alter-table时的foreign-key约束" class="headerlink" title="alter table时的foreign key约束"></a>alter table时的foreign key约束</h4><p>当 “Orders” 表已被创建时，如需在 “P_Id” 列创建 foreign key约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-7"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-7" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId)</span><br><span class="line"><span class="keyword">references</span> Persons(PersonId)</span><br></pre></td></tr></table></figure></div><p>如需命名 foreign key约束，并定义多个列的 foreign key约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-8"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-8" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_PerOrders</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId)</span><br><span class="line"><span class="keyword">references</span> Persons(PersonId)</span><br></pre></td></tr></table></figure></div><h4 id="撤销foreign-key约束"><a href="#撤销foreign-key约束" class="headerlink" title="撤销foreign key约束"></a>撤销foreign key约束</h4><p>如需撤销 foreign key约束，请使用下面的 SQL：</p><h6 id="MySQL：-5"><a href="#MySQL：-5" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> fk_PerOrders</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-5"><a href="#SQL-Server-Oracle-MS-Access：-5" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> fk_PerOrders</span><br></pre></td></tr></table></figure></div><h3 id="check-约束"><a href="#check-约束" class="headerlink" title="check 约束"></a>check 约束</h3><p>check 约束用于限制列中的值的范围。如果对单个列定义 check 约束，那么该列只允许特定的值。如果对一个表定义 check 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。</p><h4 id="create-table-时的check-约束"><a href="#create-table-时的check-约束" class="headerlink" title="create table 时的check 约束"></a>create table 时的check 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonId” 列上创建 check 约束。check 约束规定 “PersonId” 列必须只包含大于 0 的整数。</p><h6 id="MySQL：-6"><a href="#MySQL：-6" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-6"><a href="#SQL-Server-Oracle-MS-Access：-6" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-9"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-9" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),  </span><br><span class="line"><span class="keyword">constraint</span> chk_Person <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span> <span class="keyword">and</span> City=<span class="string">'Sandnes'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table-时的check-约束"><a href="#alter-table-时的check-约束" class="headerlink" title="alter table 时的check 约束"></a>alter table 时的check 约束</h4><p>当表已被创建时，如需在 “P_Id” 列创建 check 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access"><a href="#MySQL-SQL-Server-Oracle-MS-Access" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access:"></a>MySQL / SQL Server / Oracle / MS Access:</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><p>如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-10"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-10" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> chk_Person <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span> <span class="keyword">and</span> City=<span class="string">'Sandnes'</span>)</span><br></pre></td></tr></table></figure></div><h4 id="撤销-check-约束"><a href="#撤销-check-约束" class="headerlink" title="撤销 check 约束"></a>撤销 check 约束</h4><p>如需撤销 check 约束，请使用下面的 SQL：</p><h6 id="SQL-Server-Oracle-MS-Access：-7"><a href="#SQL-Server-Oracle-MS-Access：-7" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> chk_Person</span><br></pre></td></tr></table></figure></div><h6 id="MySQL：-7"><a href="#MySQL：-7" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">check</span> chk_Person</span><br></pre></td></tr></table></figure></div><h3 id="Sql-default-约束"><a href="#Sql-default-约束" class="headerlink" title="Sql default 约束"></a>Sql default 约束</h3><p>default 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p><h4 id="create-table-时的default-约束"><a href="#create-table-时的default-约束" class="headerlink" title="create table 时的default 约束"></a>create table 时的default 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 default 约束：</p><h6 id="My-SQL-SQL-Server-Oracle-MS-Access："><a href="#My-SQL-SQL-Server-Oracle-MS-Access：" class="headerlink" title="My SQL / SQL Server / Oracle / MS Access："></a>My SQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">'Sandnes'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>通过使用类似getdata()这样的函数，default 约束也可以用于插入系统值：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line">OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">PersonId <span class="built_in">int</span>,</span><br><span class="line">OrderDate <span class="built_in">date</span> <span class="keyword">default</span> getdata()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table-时的default-约束"><a href="#alter-table-时的default-约束" class="headerlink" title="alter table 时的default 约束"></a>alter table 时的default 约束</h4><p>当表已被创建时，如需在 “City” 列创建 default 约束，请使用下面的 SQL：</p><h6 id="MySQL：-8"><a href="#MySQL：-8" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> City <span class="keyword">set</span> <span class="keyword">default</span> <span class="string">'SANDNES'</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-MS-Access："><a href="#SQL-Server-MS-Access：" class="headerlink" title="SQL Server / MS Access："></a>SQL Server / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> ab_c <span class="keyword">default</span> <span class="string">'SANDNES'</span> <span class="keyword">for</span> City</span><br></pre></td></tr></table></figure></div><h6 id="Oracle："><a href="#Oracle：" class="headerlink" title="Oracle："></a>Oracle：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">modify</span> City <span class="keyword">default</span> <span class="string">'SANDNES'</span></span><br></pre></td></tr></table></figure></div><h4 id="撤销-default-约束"><a href="#撤销-default-约束" class="headerlink" title="撤销 default 约束"></a>撤销 default 约束</h4><p>如需撤销 default 约束，请使用下面的 SQL：</p><h6 id="MySQL：-9"><a href="#MySQL：-9" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> City <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-8"><a href="#SQL-Server-Oracle-MS-Access：-8" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;SQL-约束（Constraints）&quot;&gt;&lt;a href=&quot;#SQL-约束（Constraints）&quot; class=&quot;headerlink&quot; title=&quot;SQL 约束（Constraints）&quot;&gt;&lt;/a&gt;SQL 约束（Constraints）&lt;/h2&gt;&lt;p&gt;SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 create table 语句），或者在表创建之后规定（通过 alter table 语句）。&lt;/p&gt;&lt;h3 id=&quot;create-table-constraint-语法&quot;&gt;&lt;a href=&quot;#create-table-constraint-语法&quot; class=&quot;headerlink&quot; title=&quot;create table + constraint 语法&quot;&gt;&lt;/a&gt;create table + constraint 语法&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name1 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name2 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name3 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;在 SQL 中，我们有如下约束：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;not null - 指示某列不能存储 NULL 值。&lt;/li&gt;&lt;li&gt;unique - 保证某列的每行必须有唯一的值。&lt;/li&gt;&lt;li&gt;primary key - not null 和 unique 的结合。确保某列（或两个列多个列的结合）有唯&amp;gt;一标识，有助于更容易更快速地找到表中的一个特定的记录。&lt;/li&gt;&lt;li&gt;foreign key - 保证一个表中的数据匹配另一个表中的值的参照完整性。&lt;/li&gt;&lt;li&gt;check - 保证列中的值符合指定的条件。&lt;/li&gt;&lt;li&gt;default - 规定没有给列赋值时的默认值&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;接下来，我们依次给大家分享每一种约束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="Constraints" scheme="https://www.xiangjunhong.com/tags/Constraints/"/>
    
  </entry>
  
  <entry>
    <title>SQL-create database</title>
    <link href="https://www.xiangjunhong.com/posts/259f9205.html"/>
    <id>https://www.xiangjunhong.com/posts/259f9205.html</id>
    <published>2020-04-09T02:34:26.410Z</published>
    <updated>2020-04-16T06:37:47.285Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h4 id="Sql-create-database语句"><a href="#Sql-create-database语句" class="headerlink" title="Sql create database语句"></a>Sql create database语句</h4><p>create database 语句用于创建数据库。</p><h4 id="create-database-语法"><a href="#create-database-语法" class="headerlink" title="create database 语法"></a>create database 语法</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname;</span><br></pre></td></tr></table></figure></div><h4 id="create-database-实例"><a href="#create-database-实例" class="headerlink" title="create database  实例"></a>create database 实例</h4><p>下面的 SQL 语句创建一个名为 “my_db” 的数据库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname my_db;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-create-database语句&quot;&gt;&lt;a href=&quot;#Sql-create-database语句&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL-create database" scheme="https://www.xiangjunhong.com/tags/SQL-create-database/"/>
    
  </entry>
  
  <entry>
    <title>Sql语法</title>
    <link href="https://www.xiangjunhong.com/posts/d4b9b850.html"/>
    <id>https://www.xiangjunhong.com/posts/d4b9b850.html</id>
    <published>2020-04-08T15:31:04.603Z</published>
    <updated>2020-04-08T15:32:59.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><p>一个数据库通常包含一个或多个表。每个表有一个名字标识,表包含带有数据的记录（行）。</p><h4 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h4><p>您需要在数据库上执行的大部分工作都由 SQL 语句完成。<br>在本教程中，我们将为您讲解各种不同的 SQL 语句。</p><a id="more"></a><blockquote><p>请记住…<br>SQL 对大小写不敏感：SELECT 与 select 是相同的。所以本教程基本上采用小写完成</p></blockquote><h4 id="SQL-语句后面的分号？"><a href="#SQL-语句后面的分号？" class="headerlink" title="SQL 语句后面的分号？"></a>SQL 语句后面的分号？</h4><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。<br>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。<br>在本教程中，我们将在每条 SQL 语句的末端使用分号。</p><h4 id="一些最重要的-SQL-命令"><a href="#一些最重要的-SQL-命令" class="headerlink" title="一些最重要的 SQL 命令"></a>一些最重要的 SQL 命令</h4><ul><li>select - 从数据库中提取数据</li><li>update - 更新数据库中的数据</li><li>delete- 从数据库中删除数据</li><li>insert into - 向数据库中插入新数据</li><li>create database - 创建新数据库</li><li>alter database - 修改数据库</li><li>create table - 创建新表</li><li>alter table - 变更（改变）数据库表</li><li>drop table - 删除表</li><li>create index - 创建索引（搜索键）</li><li>drop index - 删除索引</li><li>等等。。。。。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;数据库表&quot;&gt;&lt;a href=&quot;#数据库表&quot; class=&quot;headerlink&quot; title=&quot;数据库表&quot;&gt;&lt;/a&gt;数据库表&lt;/h4&gt;&lt;p&gt;一个数据库通常包含一个或多个表。每个表有一个名字标识,表包含带有数据的记录（行）。&lt;/p&gt;&lt;h4 id=&quot;SQL-语句&quot;&gt;&lt;a href=&quot;#SQL-语句&quot; class=&quot;headerlink&quot; title=&quot;SQL 语句&quot;&gt;&lt;/a&gt;SQL 语句&lt;/h4&gt;&lt;p&gt;您需要在数据库上执行的大部分工作都由 SQL 语句完成。&lt;br&gt;在本教程中，我们将为您讲解各种不同的 SQL 语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL简介</title>
    <link href="https://www.xiangjunhong.com/posts/4d4e6c19.html"/>
    <id>https://www.xiangjunhong.com/posts/4d4e6c19.html</id>
    <published>2020-04-08T14:49:47.967Z</published>
    <updated>2020-04-08T14:52:37.622Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><h3 id="SQL-是什么？"><a href="#SQL-是什么？" class="headerlink" title="SQL 是什么？"></a>SQL 是什么？</h3><ul><li>SQL，指结构化查询语言，全称是 Structured Query Language。</li><li>SQL 让您可以访问和处理数据库。<ul><li>SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。</li></ul></li></ul><blockquote><p>SQL是操作关系数据库的标准语言，是所有关系数据库通用的。SQL只是制定的一个标准，由具体的关系数据库厂商来实现，所以某些关系数据库可能不支持SQL中的少数语句。</p></blockquote><a id="more"></a><h3 id="SQL-能做什么？"><a href="#SQL-能做什么？" class="headerlink" title="SQL 能做什么？"></a>SQL 能做什么？</h3><ul><li>SQL 面向数据库执行查询</li><li>SQL 可从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul><h3 id="在您的网站中使用-SQL"><a href="#在您的网站中使用-SQL" class="headerlink" title="在您的网站中使用 SQL"></a>在您的网站中使用 SQL</h3><p>要创建一个显示数据库中数据的网站，您需要：</p><ol><li>RDBMS 数据库程序（比如 MS Access、SQL Server、MySQL）</li><li>使用服务器端脚本语言，比如 PHP 或 ASP</li><li>使用 SQL 来获取您想要的数据</li><li>使用 HTML / CSS</li></ol><h3 id="使用SQL须知"><a href="#使用SQL须知" class="headerlink" title="使用SQL须知"></a>使用SQL须知</h3><p>虽然SQL作为访问和处理数据库的标准语言，依然存在着多种版本，但是与ANSI标准相兼容，必须以相似的方式支持主要的命令(如：select updata insert where)<br>-除了SQL标准之外，大部分SQL数据库程序都拥有自己的专有扩展。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;SQL-是什么？&quot;&gt;&lt;a href=&quot;#SQL-是什么？&quot; class=&quot;headerlink&quot; title=&quot;SQL 是什么？&quot;&gt;&lt;/a&gt;SQL 是什么？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;SQL，指结构化查询语言，全称是 Structured Query Language。&lt;/li&gt;&lt;li&gt;SQL 让您可以访问和处理数据库。&lt;ul&gt;&lt;li&gt;SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;SQL是操作关系数据库的标准语言，是所有关系数据库通用的。SQL只是制定的一个标准，由具体的关系数据库厂商来实现，所以某些关系数据库可能不支持SQL中的少数语句。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://www.xiangjunhong.com/posts/4d712855.html"/>
    <id>https://www.xiangjunhong.com/posts/4d712855.html</id>
    <published>2020-04-08T14:40:49.441Z</published>
    <updated>2020-04-09T14:21:36.693Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>SQL，指结构化查询语言，全称是 Structured Query Language。SQL可以让您可以访问和处理数据库。SQL是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。在本教程中，您将学到如何使用SQL访问和处理数据系统中的数据.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvb081TFJDblE2WjhYcnQ3LmpwZw?x-oss-process=image/format,png#pic_center" alt=" "></p><a id="more"></a><h1 id="SQL-目录"><a href="#SQL-目录" class="headerlink" title="SQL 目录"></a>SQL 目录</h1><ul><li><a href="https://www.xiangjunhong.com/posts/4d4e6c19.html">Sql 简介</a></li><li><a href="https://www.xiangjunhong.com/posts/d4b9b850.html">Sql 语法</a></li><li><a href="https://www.xiangjunhong.com/posts/259f9205.html">Sql create database</a></li><li><a href="https://www.xiangjunhong.com/posts/e4bced2a.html">Sql create table</a></li><li><a href="https://www.xiangjunhong.com/posts/be01953a.html">Sql insert into</a></li><li><a href="https://www.xiangjunhong.com/posts/6d7376dd.html">Sql 约束</a></li><li><a href>Sql update</a></li><li><a href>Sql delete</a></li><li><a href>Sql select</a></li><li><a href>Sql select top</a></li><li><a href>Sql where</a></li><li><a href>Sql and &amp; or</a></li><li><a href>Sql like</a></li><li><a href>Sql 通配符</a></li><li><a href>Sql order by</a></li><li><a href>Sql in</a></li><li><a href>Sql between</a></li><li><a href>Sql 别名</a></li><li><a href>Sql 连接（join</a></li><li><a href>Sql inner join</a></li><li><a href>Sql left join</a></li><li><a href>Sql right join</a></li><li><a href>Sql full join</a></li><li><a href>Sql union</a></li><li><a href>Sql select into</a></li><li><a href>Sql insert into select</a></li><li><a href>Sql not null</a></li><li><a href>Sql unique</a></li><li><a href>Sql check</a></li><li><a href>Sql default</a></li><li><a href>Sql create index</a></li><li><a href>Sql drop</a></li><li><a href>Sql alter</a></li><li><a href>Sql auto increment</a></li><li><a href>Sql 视图</a></li><li><a href>Sql 日期</a></li><li><a href>Sql null值</a></li><li><a href>Sql null函数</a></li><li><a href>Sql 通用数据类型</a></li><li><a href>Sql db数据类型</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;SQL，指结构化查询语言，全称是 Structured Query Language。SQL可以让您可以访问和处理数据库。SQL是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。在本教程中，您将学到如何使用SQL访问和处理数据系统中的数据.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvb081TFJDblE2WjhYcnQ3LmpwZw?x-oss-process=image/format,png#pic_center&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop学习笔记(1)-Hadoop在Ubuntu的安装</title>
    <link href="https://www.xiangjunhong.com/posts/ae1da46b.html"/>
    <id>https://www.xiangjunhong.com/posts/ae1da46b.html</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-04-20T05:32:48.862Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>由于小编在本学期有一门课程需要学习hadoop,需要在ubuntu的linux系统下搭建Hadoop环境，在这个过程中遇到一些问题，写下这篇博客来记录这个过程，并把分享给大家。</p><h3 id="Hadoop的安装方式"><a href="#Hadoop的安装方式" class="headerlink" title="Hadoop的安装方式"></a>Hadoop的安装方式</h3><ul><li>单机模式:Hadoop默认模式为非分布式模式(本地模式)，无需 进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试</li><li>伪分布式模式:Hadoop可以在单节点上以伪分布式的方式运行， Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也 作为 DataNode，同时，读取的是 HDFS 中的文件</li><li>分布式模式:使用多个节点构成集群环境来运行Hadoop</li></ul><a id="more"></a><h3 id="创建Hadoop用户-可选"><a href="#创建Hadoop用户-可选" class="headerlink" title="创建Hadoop用户(可选)"></a>创建Hadoop用户(可选)</h3><p>如果安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为hadoop 的用户，首先按打开终端窗口，输入如下命令创建新用户 :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd –m hadoop –s /bin/bash</span><br></pre></td></tr></table></figure></div><p>上面这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell 接着使用如下命令设置密码，可简单设置为 hadoop，按提示输入两次密码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd hadoop</span><br></pre></td></tr></table></figure></div><p>可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘 手的权限问题:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser hadoop sudo</span><br></pre></td></tr></table></figure></div><h3 id="SSH登录权限设置"><a href="#SSH登录权限设置" class="headerlink" title="SSH登录权限设置"></a>SSH登录权限设置</h3><h4 id="SSH是什么"><a href="#SSH是什么" class="headerlink" title="SSH是什么?"></a>SSH是什么?</h4><p>SSH 为 Secure Shell 的缩写，是建立在应用层和传输层基础上的安全协议。 SSH 是目前较可靠、专为远程登录会话和其他网络服务提供安全性的协议。 利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是 UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。 SSH是由客 户端和服务端的软件组成，服务端是一个守护进程(daemon)，它在后台运 行并响应来自客户端的连接请求，客户端包含ssh程序以及像scp(远程拷 贝)、slogin(远程登陆)、sftp(安全文件传输)等其他的应用程序.</p><h4 id="配置SSH的原因"><a href="#配置SSH的原因" class="headerlink" title="配置SSH的原因"></a>配置SSH的原因</h4><p>Hadoop名称节点(NameNode)需要启动集群中所有机器的Hadoop守护进程，这个过 程需要通过SSH登录来实现。Hadoop并没有提供SSH输入密码登录的形式，因此，为 了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录它们。</p><h4 id="配置SSH的无密码登录"><a href="#配置SSH的无密码登录" class="headerlink" title="配置SSH的无密码登录"></a>配置SSH的无密码登录</h4><p>安装openssh-server( 通常Linux系统会默认安装openssh的客户端软件openssh-client)，所以需要自己安装一下服务端。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></div><p>输入 cd .ssh目录下，如果没有.ssh文件 输入 ssh localhost生成。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh/</span><br></pre></td></tr></table></figure></div><p>生成秘钥</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvYXJKQ0x1UjNYb1NkRXhULnBuZw?x-oss-process=image/format,png" alt="  "><br>将Master中生成的密钥加入授权（authorized_keys）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub                     # 查看生成的公钥</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvd05pejNiZ1VhRHNsNHVjLnBuZw?x-oss-process=image/format,png" alt=" "></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys    # 加入授权</span><br><span class="line">chmod 600 authorized_keys    # 修改文件权限，如果不修改文件权限，那么其它用户就能查看该授权</span><br></pre></td></tr></table></figure></div><p>完成后，直接键入“ssh localhost”，能无密码登录即可，<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvTkxjNjJ2ZDdSdEJqbmJ1LnBuZw?x-oss-process=image/format,png" alt=" "><br>键入“exit”退出，到此SSH无密码登录配置就成功了。</p><h3 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h3><h4 id="scp命令传输Mac的文件到ubuntu"><a href="#scp命令传输Mac的文件到ubuntu" class="headerlink" title="scp命令传输Mac的文件到ubuntu"></a>scp命令传输Mac的文件到ubuntu</h4><p>因为老师给了我们的java的jdk安装包，想着不用去ubuntu重新下载，所以就想到了利用scp命令传输Mac的文件到ubuntu，利用这个命令前提是Ubuntu安装了SSH服务器，在之前我们已经有了这步操作。</p><p>利用ifconfig查看ubuntu服务器的局域网IP地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvSHlNQTg5UlZtYkZ1bGpvLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>以下是利用scp命令传输文件的基本格式：<br><strong>1. 本地文件传输到服务器</strong></p><table><thead><tr><th>从本地将文件传输到服务器</th><th>从本地将文件夹传输到服务器</th></tr></thead><tbody><tr><td>scp[本地文件的路径] [服务器用户名]@[服务器地址]:[服务器上存放文件的路径]</td><td>scp -r[本地文件的路径] [服务器用户名]@[服务器地址]:[服务器上存放文件的路径]</td></tr><tr><td>scp /Users/mac/Desktop/test.txt <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root</td><td>scp -r /Users/mac/Desktop/test <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root</td></tr></tbody></table><p><strong>2. 服务器文件传输到本地</strong></p><table><thead><tr><th>将服务器上的文件传输到本地</th><th>将服务器上的文件夹传输到本地</th></tr></thead><tbody><tr><td>scp [服务器用户名]@[服务器地址]:[服务器上存放文件的路径] [本地文件的路径]</td><td>scp -r [服务器用户名]@[服务器地址]:[服务器上存放文件的路径] [本地文件的路径]</td></tr><tr><td>scp <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root/default/test.txt /Users/mac/Desktop</td><td>scp -r <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root/default/test /Users/mac/Desktop</td></tr></tbody></table><h4 id="mac客户端执行传输命令"><a href="#mac客户端执行传输命令" class="headerlink" title="mac客户端执行传输命令"></a>mac客户端执行传输命令</h4><p>在选择Linux服务器端的储存文件地址时，由于权限原因，默认的是在/tmp有权限，可以先把文件放到tmp文件目录下，然后在进行mv 或者scp到其他目录，即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /Users/xjh/Desktop/jdk-8u221-linux-x64.tar.gz hadoop@172.16.186.128:/tmp</span><br></pre></td></tr></table></figure></div><p>传输速度还是蛮快的，如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkveGJldjJSeWg5YVBHcDZuLnBuZw?x-oss-process=image/format,png" alt=" "><br>在Ubuntu将jdk移动到我们新建的java目录下（没建的新建一个就是），到此传输文件成功，可以开始配置Java环境了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /tmp/jdk-8u221-linux-x64.tar.gz usr/java</span><br></pre></td></tr></table></figure></div><p>在java目录中，使用sudo tar命令解压jdk文件;<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvZlRWSkVVdEEzYnJNNUhLLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>解压成功后，java目录中会有对应的目录文件存在</p><h4 id="配置Java环境"><a href="#配置Java环境" class="headerlink" title="配置Java环境"></a>配置Java环境</h4><p>使用命令“sudo gedit ~/.bashrc”打开配置文件，在末尾添加以下几行文字，注意自己的jdk版本号。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set java env</span><br><span class="line">export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_221</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre    </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib    </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></div><p>使用命令“source ~/.bashrc”使环境变量生效。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></div><p>配置软连接，软连接相当于windows系统中的快捷键，部分软件可能会从/usr/bin目录下查找Java，因此添加该软连接防止其他软件查找不到的情况。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java  java  /usr/java/jdk1.8.0_221/bin/java 300</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/javac  javac  /usr/java/jdk1.8.0_221/bin/javac 300</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvNUpES3VvWUx3dmtpSVg0LnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="测试java是否安装成功"><a href="#测试java是否安装成功" class="headerlink" title="测试java是否安装成功"></a>测试java是否安装成功</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvUW1HT2d5M3A2RGxBajFuLnBuZw?x-oss-process=image/format,png" alt=" "></p><h3 id="Hadoop单机安装配置"><a href="#Hadoop单机安装配置" class="headerlink" title="Hadoop单机安装配置"></a>Hadoop单机安装配置</h3><p>将我们下载的Hadoop解压到 /usr/local/ 中</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar zxvf tmp/hadoop-3.2.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></div><p>利用cd /usr/local/ 命令切换操作空间，将文件夹名改为hadoop</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv ./hadoop-3.2.1/ ./hadoop</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvRXRDZWpwY1VNNjFLREdhLnBuZw?x-oss-process=image/format,png" alt=" "><br>修改文件权限</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R hadoop:hadoop ./hadoop</span><br></pre></td></tr></table></figure></div><p>Hadoop 解压后，在Hadoop目录下的etc/hadoop/hadoop-env.sh文件中添加如下的 Java环境信息。</p><blockquote><p>export JAVA_HOME=/usr/java/jdk1.8.0_221</p></blockquote><p>然后，保存hadoop-env.sh文件，即完成单机模式的Hadoop基本安装。测试Hadoop是否安装成功，如出现如下图所示的版本信息，即可。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvdVhKYkxsRWZwVDVDM095LnBuZw?x-oss-process=image/format,png" alt=" "><br>默认情况下，单机模式的Hadoop以Java进程的方式运行，可依次运行如下命令进行进一步测试。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir input</span><br><span class="line">sudo cp etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure></div><p>执行下列命令，运行MapReduce程序，完成测试计算。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></table></figure></div><p>执行下列命令，查看计算结果。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat output/*</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvdlJFaUlxbVgzY1FZV0hKLnBuZw?x-oss-process=image/format,png" alt=" "><br>Hadoop目录下，会有input和output两个新建的文件，output中有上述程序 的运算结果，到此Hadoop单机安装配置成功。</p><h3 id="Hadoop伪分布式安装配置"><a href="#Hadoop伪分布式安装配置" class="headerlink" title="Hadoop伪分布式安装配置"></a>Hadoop伪分布式安装配置</h3><blockquote><ul><li>Hadoop可以在单节点上以伪分布式的方式运行，Hadoop进程以分 离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode， 同时，读取的是 HDFS 中的文件</li><li>Hadoop的配置文件位于/usr/local/hadoop/etc/hadoop/中，伪分布式 需要修改2个配置文件 core-site.xml 和 hdfs-site.xml</li><li>Hadoop的配置文件是xml格式，每个配置以声明property的name 和 value 的方式来实现<br>hadoop目录认识</li></ul></blockquote><h4 id="hadoop下的目录"><a href="#hadoop下的目录" class="headerlink" title="hadoop下的目录"></a>hadoop下的目录</h4><p>修改配置文件之前，先看一下hadoop下的目录：</p><div class="note primary"><ul><li>bin：hadoop最基本的管理脚本和使用脚本所在目录，这些脚本是sbin目录下管理脚本的基础实现，用户可以直接使用这些脚本管理和使用hadoop</li><li>etc：配置文件存放的目录，包括core-site.xml,hdfs-site.xml,mapred-site.xml等从hadoop1.x继承而来的配置文件和yarn-site.xml等hadoop2.x新增的配置文件</li><li>include：对外提供的编程库头文件（具体动态库和静态库在lib目录中，这些头文件军事用c++定义的，通常用于c++程序访问hdfs或者编写mapreduce程序）</li><li>Lib：该目录包含了hadoop对外提供的才变成动态库和静态库，与include目录中的头文件结合使用</li><li>libexec：各个服务对应的shell配置文件所在目录，可用于配置日志输出目录、启动参数等信息</li><li>sbin：hadoop管理脚本所在目录，主要包含hdfs和yarn中各类服务的启动、关闭脚本</li><li>share：hadoop各个模块编译后的jar包所在目录。</li></ul></div><h4 id="修改配置文件-core-site-xml"><a href="#修改配置文件-core-site-xml" class="headerlink" title="修改配置文件 core-site.xml"></a>修改配置文件 core-site.xml</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;configuration&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div><ul><li>hadoop.tmp.dir表示存放临时数据的目录，即包括NameNode的数据，也包 括DataNode的数据。该路径任意指定，只要实际存在该文件夹即可</li><li>name为fs.defaultFS的值，表示hdfs路径的逻辑名称</li></ul><h4 id="修改配置文件-hdfs-site-xml"><a href="#修改配置文件-hdfs-site-xml" class="headerlink" title="修改配置文件 hdfs-site.xml"></a>修改配置文件 hdfs-site.xml</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;1&lt;/value&gt; </span><br><span class="line">   &lt;/property&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;         </span><br><span class="line">       &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div><ul><li>dfs.replication表示副本的数量，伪分布式要设置为1</li><li>dfs.namenode.name.dir表示本地磁盘目录，是存储fsimage文件的地方</li><li>dfs.datanode.data.dir表示本地磁盘目录，HDFS数据存放block的地方</li></ul><table><thead><tr><th>文件名称</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>hadoop-env.sh</td><td>Bash脚本</td><td>记录配置Hadoop运行所需的环境变量，以运行 Hadoop</td></tr><tr><td>core-site.xml</td><td>Hadoop配置XML</td><td>Hadoop core的配置项，例如HDFS和MapReduce 常用的I/O设置等</td></tr><tr><td>hdfs-site.xml</td><td>Hadoop配置XML</td><td>Hadoop的守护进程的配置项，包括NameNode、 SecondaryNameNode和DataNode等</td></tr><tr><td>mapred-site.xml</td><td>Hadoop配置XML</td><td>MapReduce守护进程的配置项，包括JobTracker 和TaskTracker</td></tr><tr><td>masters</td><td>纯文本</td><td>运行SecondaryNameNode的机器列表(每行一 个)</td></tr><tr><td>slaves</td><td></td><td>纯文本</td></tr><tr><td>hadoop- metrics.properties</td><td>Java属性</td><td>控制metrics在Hadoop上如何发布的属性</td></tr></tbody></table><p>至此，配置完毕，但是还不能启动，要对hdfs先进行格式化。类似以前的软盘，使用前要先格式化,执行命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></div><p>看到日志信息：即格式化成功。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvUXlKRGZQN0IxQzgyTXdGLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>在我们name目录(这个目录是我们自己配置的时候指定的)下也会出现映像文件（fsimage），用于将数据持久化 。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvUUVhWndCcjVoV2xNODNzLnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h4><p>输入以下命令启动Hadoop：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvZkJuOEgxYkx6RFpnSnJqLnBuZw?x-oss-process=image/format,png" alt=" "><br>安装jps</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk-headless</span><br></pre></td></tr></table></figure></div><p>安装好之后jps检查角色如果有多个角色，就启动成功。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvdHB6VTN1aFgxOVFCMkNELnBuZw?x-oss-process=image/format,png" alt=" "><br>浏览器访问localhost:9870<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvek8xUlVRVHNseHdnS0wzLnBuZw?x-oss-process=image/format,png" alt=" "></p><div class="note success"><p><strong><font color="#5cb85c">前面的路布满荆棘，我有过迟疑，却从未后退。一无所有，就是拼的理由!</font></strong><br>到这里，在Linux系统配置Hadoop的安装和使用教程就到此结束了，经过了很多的踩坑终于完成了这篇教程。如果有哪里不对的地方，希望各路大神在下方评论区留言，我加以改正！我们一起交流，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于小编在本学期有一门课程需要学习hadoop,需要在ubuntu的linux系统下搭建Hadoop环境，在这个过程中遇到一些问题，写下这篇博客来记录这个过程，并把分享给大家。&lt;/p&gt;&lt;h3 id=&quot;Hadoop的安装方式&quot;&gt;&lt;a href=&quot;#Hadoop的安装方式&quot; class=&quot;headerlink&quot; title=&quot;Hadoop的安装方式&quot;&gt;&lt;/a&gt;Hadoop的安装方式&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;单机模式:Hadoop默认模式为非分布式模式(本地模式)，无需 进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试&lt;/li&gt;&lt;li&gt;伪分布式模式:Hadoop可以在单节点上以伪分布式的方式运行， Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也 作为 DataNode，同时，读取的是 HDFS 中的文件&lt;/li&gt;&lt;li&gt;分布式模式:使用多个节点构成集群环境来运行Hadoop&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.xiangjunhong.com/categories/Ubuntu/"/>
    
      <category term="Hadoop学习笔记" scheme="https://www.xiangjunhong.com/categories/Ubuntu/Hadoop%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/tags/Mac/"/>
    
      <category term="Hadoop的安装" scheme="https://www.xiangjunhong.com/tags/Hadoop%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现链式队列</title>
    <link href="https://www.xiangjunhong.com/posts/7fcb11a7.html"/>
    <id>https://www.xiangjunhong.com/posts/7fcb11a7.html</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-01T11:23:17.480Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>链式队列，简称”链队列”，即使用链表实现的队列存储结构。<br>链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/v14i9JV6RkacuqT.gif"></div>所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。<a id="more"></a><blockquote><p>在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。</p></blockquote><p>由此，我们可以编写出创建链式队列的 C 语言实现代码为:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个头节点</span></span><br><span class="line">    QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="comment">//对头节点进行初始化</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据入队"><a href="#链式队列数据入队" class="headerlink" title="链式队列数据入队"></a>链式队列数据入队</h3><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：</p><ol><li>将该数据元素用节点包裹，例如新节点名称为 elem；</li><li>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；</li><li>最后移动 rear 指针指向该新节点，即 rear=elem；</li></ol><p>由此，新节点就入队成功了。</p><p>例如，在上图的基础上，我们依次将<code>{1,2,3}</code>依次入队，各个数据元素入队的过程如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/I4cxvyYn6gUzVbR.gif"></div>数据元素入链式队列的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、用节点包裹入队元素</span></span><br><span class="line">    QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    enElem-&gt;data=data;</span><br><span class="line">    enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2、新节点与rear节点建立逻辑关系</span></span><br><span class="line">    rear-&gt;next=enElem;</span><br><span class="line">    <span class="comment">//3、rear指向新节点</span></span><br><span class="line">    rear=enElem;</span><br><span class="line">    <span class="comment">//返回新的rear，为后续新元素入队做准备</span></span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据出队"><a href="#链式队列数据出队" class="headerlink" title="链式队列数据出队"></a>链式队列数据出队</h3><p>当链式队列中，有数据元素需要出队时，按照 “先进先出” 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。</p><p>链式队列中队头元素出队，需要做以下 3 步操作：</p><ol><li>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；</li><li>将 p 节点（即要出队的队头节点）从链表中摘除；</li><li>释放节点 p，回收其所占的内存空间；</li></ol><p>例如，在上图2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如下图所示：</p><div align="center"><img src="https://i.loli.net/2020/02/29/wVhEDjNbPHon9lz.gif"></div>链式队列中队头元素出队的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、</span></span><br><span class="line">    QNode * p=top-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">    top-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">        rear=top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。</p></blockquote><h3 id="链式队列的长度"><a href="#链式队列的长度" class="headerlink" title="链式队列的长度"></a>链式队列的长度</h3><p>链式队列的长度，只需要设置一个移动指针，由队列头部移动直至到队列尾部，来达到计数的效果。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列的打印"><a href="#链式队列的打印" class="headerlink" title="链式队列的打印"></a>链式队列的打印</h3><p>链式队列的打印，实际上也就是一个链表的遍历过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过学习链式队列最基本的数据入队和出队操作，我们可以就实际问题，对以上代码做适当的修改。</p><p>前面在学习顺序队列时，由于顺序表的局限性，我们在顺序队列中实现数据入队和出队的基础上，又对实现代码做了改进，令其能够充分利用数组中的空间。链式队列就不需要考虑空间利用的问题，因为链式队列本身就是实时申请空间。因此，这可以算作是链式队列相比顺序队列的一个优势。</p><p>这里给出链式队列入队和出队的完整 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头节点</span></span><br><span class="line">QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="comment">//对头节点进行初始化</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">enElem-&gt;data=data;</span><br><span class="line">enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//使用尾插法向链队列中添加数据元素</span></span><br><span class="line">rear-&gt;next=enElem;</span><br><span class="line">rear=enElem;</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n队列为空"</span>);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line">QNode * p=top-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"出队的元素是：%d \n"</span>,p-&gt;data);</span><br><span class="line">top-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">rear=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">QNode * <span class="built_in">queue</span>,*top,*rear;</span><br><span class="line"><span class="built_in">queue</span>=top=rear=initQueue();<span class="comment">//创建头结点</span></span><br><span class="line"><span class="comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">rear = enQueue(rear, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">printQueue(top);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列的长度为：%d\n"</span>,QueueLength(top));</span><br><span class="line"><span class="comment">//入队完成，所有数据元素开始出队列</span></span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>1 2 3 4 5 6 7 8 9 10<br>队列的长度为：10<br>出队的元素是：1<br>出队的元素是：2</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现链式队列，如今作为大学生的我，也开始受网课的折磨了，在家上网课的感觉比在学校还要累。每天都在上课，写作业，所以一直更新文章也比较少。如果有什么问题的,大家可在下方评论区留言，我加以改正，我们一起交流分享啊！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;链式队列，简称”链队列”，即使用链表实现的队列存储结构。&lt;br&gt;链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.loli.net/2020/02/29/v14i9JV6RkacuqT.gif&quot;&gt;&lt;/div&gt;所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="链式队列" scheme="https://www.xiangjunhong.com/tags/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>在MAC上如何使用Sql Server</title>
    <link href="https://www.xiangjunhong.com/posts/e35620b3.html"/>
    <id>https://www.xiangjunhong.com/posts/e35620b3.html</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-03-10T10:53:47.010Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>由于小编在这学期要学习数据库原理这门课程，需要用到<code>SQL Server</code>，然而大家都知道<code>SQL Server</code>目前是只能在Windows上使用，我们在mac电脑上如何使用呢？我们可以借助目前比较火的Docker来完成，接下来就给大家介绍如何在docker上部署。</p><h3 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h3 id="MacOS-Docker-安装"><a href="#MacOS-Docker-安装" class="headerlink" title="MacOS Docker 安装"></a>MacOS Docker 安装</h3><h4 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h4><p>macOS 我们可以使用 Homebrew 来安装 Docker。</p><p>Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用<code>Homebrew Cask</code>来进行安装，在终端运行以下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install docker</span></span><br></pre></td></tr></table></figure></div><a id="more"></a><p>安装成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/42716/Docker.dmg</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask 'docker'.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure></div><p>在载入<code>Docker app</code>后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有个小鲸鱼的图标。</p><h4 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvbkRoZnZsc0dkeFp0U1ZLLnBuZw?x-oss-process=image/format,png"></div><br><p>从应用中找到 Docker 图标并点击运行。可能会询问 macOS 的登陆密码，输入即可。<br>点击顶部状态栏中的鲸鱼图标会弹出操作菜单。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTXhrUUtQcElmVjJlcWNtLnBuZw?x-oss-process=image/format,png"></div><br><br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvcW9KeEdSSDFPdk10RkE1LnBuZw?x-oss-process=image/format,png"></div><br>第一次点击图标，可能会看到这个安装成功的界面，点击 "`Got it!`" 可以关闭这个窗口。<br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTG4xRUN6c2Z1NnBaRjdvLnBuZw?x-oss-process=image/format,png"></div><br><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version                                  </span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br></pre></td></tr></table></figure></div><p>之后我们可以通过 docker info 来查看是否配置成功。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></div><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<code>http://hub-mirror.c.163.com</code>。<br>在之前的版本中，Docker客户端有修改镜像的界面，但是更新版本之后，去除了这个界面，那怎么来修改镜像呢？网上都是Linux的教程，并没有Mac的教程，这两个系统之间文件目录有所差别，费了九牛二虎之力找到了<code>daemon.json</code>这个文件。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .docker</span><br></pre></td></tr></table></figure></div><p><code>daemon.json</code>就在这个文件夹，将里面的内容修改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"experimental"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"debug"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>:[<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重启，Docker就会 应用配置的镜像地址。<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/exQAdcC7giYmBv3.png"></div><br>以上图片就是配置成功的样式。 我们也可以通过 docker info 来查看是否配置成功。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line">....</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br><span class="line"> Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"> Product License: Community Engine</span><br></pre></td></tr></table></figure></div><h3 id="拉取并运行-SQL-Server-容器映像"><a href="#拉取并运行-SQL-Server-容器映像" class="headerlink" title="拉取并运行 SQL Server 容器映像"></a>拉取并运行 SQL Server 容器映像</h3><p>拉取并运行SQL Server 容器映像，参考了<a href="https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-linux-2017&pivots=cs1-bash#pullandrun2017" target="_blank" rel="noopener">微软的官方开发文档</a>.</p><p>从 Microsoft 容器注册表中拉取 SQL Server 2017 Linux 容器映像，打开我们的终端，输入命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><p>这里会将sql server for linux docker下载到我们计算机上。</p><h4 id="使用-Docker-运行容器映像"><a href="#使用-Docker-运行容器映像" class="headerlink" title="使用 Docker 运行容器映像"></a>使用 Docker 运行容器映像</h4><p>要使用 Docker 运行容器映像，可以从 Bash Shell (Linux/macOS) 或提升的 PowerShell 命令提示符使用以下命令。(也就是终端)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -e <span class="string">"ACCEPT_EULA=Y"</span> -e <span class="string">"SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -p 1433:1433 --name sql1 \</span><br><span class="line">   -d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><blockquote><p><font color="blue"><strong>备注</strong>:</font><br>密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。 默认情况下，密码的长度必须至少为 8 个字符，并且必须包含以下四种字符中的三种：大写字母、小写字母、十进制数字和符号。 你可以通过执行 docker logs 命令检查错误日志。</p></blockquote><p>下表对前一个 docker run 示例中的参数进行了说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e “ACCEPT_EULA=Y”</td><td>将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必需设置。</td></tr><tr><td>-e “SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;“</td><td>指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 SQL Server 映像的必需设置。</td></tr><tr><td>-p 1433:1433</td><td>将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 在此示例中，SQL Server 侦听容器中的 TCP 1433，并对主机上的端口 1433 公开。</td></tr><tr><td>–name sql1</td><td>为容器指定一个自定义名称，而不是使用随机生成的名称。 如果运行多个容器，则无法重复使用相同的名称。</td></tr><tr><td>-d mcr.microsoft.com/mssql/server:2017-latest</td><td>SQL Server 2017 Linux 容器映像。</td></tr></tbody></table><p>要查看 Docker 容器，请使用 docker ps 命令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure></div><p>应会看到与以下类似的输出：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                                        COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">78c2deca0bd6        mcr.microsoft.com/mssql/server:2017-latest   <span class="string">"/opt/mssql/bin/nonr…"</span>   30 minutes ago      Exited (0) 2 minutes ago                       sql1</span><br></pre></td></tr></table></figure></div><p>如果“状态”列显示“正常运行”，则 SQL Server 将在容器中运行，并侦听“端口”列中指定的端口 。</p><h4 id="更改-SA-密码"><a href="#更改-SA-密码" class="headerlink" title="更改 SA 密码"></a>更改 SA 密码</h4><p>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。 创建 SQL Server 容器后，通过在容器中运行 <code>echo $SA_PASSWORD</code>，可发现指定的 <code>SA_PASSWORD</code> 环境变量。 出于安全考虑，请考虑更改 SA 密码。</p><ol><li>选择 SA 用户要使用的强密码。</li><li>使用 docker exec 运行sqlcmd ，以使用 <code>Transact-SQL</code> 更改密码。 在下面的示例中，将旧密码 <code>&lt;YourStrong!Passw0rd&gt;</code>和新密码 <code>&lt;YourNewStrong!Passw0rd&gt;</code> 替换为你自己的密码值。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">   -S localhost -U SA -P <span class="string">"&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -Q <span class="string">'ALTER LOGIN SA WITH PASSWORD="&lt;YourNewStrong@Passw0rd&gt;"'</span></span><br></pre></td></tr></table></figure></div><h4 id="连接到-SQL-Server"><a href="#连接到-SQL-Server" class="headerlink" title="连接到 SQL Server"></a>连接到 SQL Server</h4><p>下列步骤在容器内部使用<code>SQL Server</code>命令行工具<code>sqlcmd</code> 来连接 <code>SQL Server</code>。</p><ol><li>使用 <code>docker exec -it</code> 命令在运行的容器内部启动交互式 <code>Bash Shell</code>。 在下面的示例中，sql1 是在创建容器时由 –name 参数指定的名称。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 <span class="string">"bash"</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>在容器内部使用 sqlcmd 进行本地连接。 默认情况下，sqlcmd 不在路径之中，因此需要指定完整路径。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P <span class="string">"&lt;YourNewStrong@Passw0rd&gt;"</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>如果成功，应会显示 sqlcmd 命令提示符：1&gt;。</li></ol><h3 id="利用Navicat可视化工具连接Sql-Server"><a href="#利用Navicat可视化工具连接Sql-Server" class="headerlink" title="利用Navicat可视化工具连接Sql Server"></a>利用Navicat可视化工具连接Sql Server</h3><h4 id="下载Navicat"><a href="#下载Navicat" class="headerlink" title="下载Navicat"></a>下载Navicat</h4><p>因为正版只有14天的试用期，没Money的小编只有安排破解版了，在这里把安装包也分享给大家：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ" target="_blank" rel="noopener">https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ</a> 密码:cg5s</p></blockquote><p>下载好后添加Sql Server数据库连接:<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/3zoU1tI74yf9kh2.png"></div><br><div class="note danger"><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>密码一定不要填错，如果密码填错，会出现以下错误：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[42000] [FreeTDS][SQL Server]Login failed for user &apos;SA&apos;. (18456)</span><br><span class="line">[08001] [FreeTDS][SQL Server]Unable to connect to data source (0)</span><br></pre></td></tr></table></figure></div><p>最后，连接成功！<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/D6tHIF3PWXSNwir.png"></div><br><div class="note success"><p><strong><font color="#5cb85c">满怀希望就会所向披靡，因为深海不会因为一杯沸水而加温!</font></strong></p><p>以上就是小编本次给大家分享的在Mac上如何使用SQL Server的详细教程,我们一起讨论！如果哪里有写的不好的地方，还希望大家提出来，在下方评论区留言，我加以修正！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于小编在这学期要学习数据库原理这门课程，需要用到&lt;code&gt;SQL Server&lt;/code&gt;，然而大家都知道&lt;code&gt;SQL Server&lt;/code&gt;目前是只能在Windows上使用，我们在mac电脑上如何使用呢？我们可以借助目前比较火的Docker来完成，接下来就给大家介绍如何在docker上部署。&lt;/p&gt;&lt;h3 id=&quot;Docker介绍&quot;&gt;&lt;a href=&quot;#Docker介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker介绍&quot;&gt;&lt;/a&gt;Docker介绍&lt;/h3&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;&lt;h3 id=&quot;MacOS-Docker-安装&quot;&gt;&lt;a href=&quot;#MacOS-Docker-安装&quot; class=&quot;headerlink&quot; title=&quot;MacOS Docker 安装&quot;&gt;&lt;/a&gt;MacOS Docker 安装&lt;/h3&gt;&lt;h4 id=&quot;使用-Homebrew-安装&quot;&gt;&lt;a href=&quot;#使用-Homebrew-安装&quot; class=&quot;headerlink&quot; title=&quot;使用 Homebrew 安装&quot;&gt;&lt;/a&gt;使用 Homebrew 安装&lt;/h4&gt;&lt;p&gt;macOS 我们可以使用 Homebrew 来安装 Docker。&lt;/p&gt;&lt;p&gt;Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用&lt;code&gt;Homebrew Cask&lt;/code&gt;来进行安装，在终端运行以下命令：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; brew cask install docker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/categories/Mac/"/>
    
      <category term="Sql Server" scheme="https://www.xiangjunhong.com/categories/Mac/Sql-Server/"/>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/tags/Mac/"/>
    
      <category term="Sql Server" scheme="https://www.xiangjunhong.com/tags/Sql-Server/"/>
    
  </entry>
  
  <entry>
    <title>队列的含义以及C语言实现顺序队列</title>
    <link href="https://www.xiangjunhong.com/posts/2d063bc3.html"/>
    <id>https://www.xiangjunhong.com/posts/2d063bc3.html</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-03-10T10:54:20.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p><font color="green">队列</font>，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。</p><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>与栈结构不同的是，<font color="red">队列</font>的两端都”开口”，要求数据只能从一端进，从另一端出，如下图示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwb0hscS5naWY" alt></p><blockquote><p>通常，称进数据的一端为 “<font color="green">队尾</font>“，出数据的一端为 “<font color="green">队头</font>“，数据元素进队列的过程称为 “<font color="green">入队</font>“，出队列的过程称为 “<font color="green">出队</font>“。</p></blockquote><a id="more"></a><p>不仅如此，<font color="red">队列中数据的进出要遵循 “先进先出” 的原则</font>，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p><blockquote><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><p>因此，数据从表的一端进，从另一端出，且遵循 “先进先出” 原则的线性存储结构就是队列。</p><h3 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h3><p><font color="blue">顺序队列</font>，即采用顺序表模拟实现的队列结构。</p><blockquote><p>我们知道，队列具有以下两个特点：<br>数据从队列的一端进，另一端出；<br>数据的入队和出队遵循”先进先出”的原则；</p></blockquote><p>因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。</p><h4 id="顺序队列简单实现"><a href="#顺序队列简单实现" class="headerlink" title="顺序队列简单实现"></a>顺序队列简单实现</h4><p>由于顺序队列的底层使用的是<font color="blue">数组</font>，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVGEzbi5naWY" alt><br>由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p><p>在上图的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p><p>例如，在上图的基础上将<code>{1,2,3,4}</code>用顺序队列存储的实现操作如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVFdnMS5naWY" alt><br>在上图基础上，顺序队列中数据出队列的实现过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVE9nSS5naWY" alt><br>因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    a[rear]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (front!=rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队元素：%d\n"</span>,a[front]);</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a, rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序输出结果：</p><blockquote><p>出队元素：1<br>出队元素：2<br>出队元素：3<br>出队元素：4</p></blockquote><p><strong><em>此方法存在的问题</em></strong></p><p>先来分析上面两张图。第一张图的b是有数据进队成功的示意图，而第二张图的b 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；</li></ul><p>为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。</p><h4 id="顺序队列另一种实现方法"><a href="#顺序队列另一种实现方法" class="headerlink" title="顺序队列另一种实现方法"></a>顺序队列另一种实现方法</h4><p>既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。</p><p>为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如下图所示：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwN0JSQS5naWY" alt><br>上图只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 5<span class="comment">//表示顺序表申请的空间大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满</span></span><br><span class="line">    <span class="keyword">if</span> ((rear+<span class="number">1</span>)%max==front) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空间已满"</span>);</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line">    a[rear%max]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(front==rear%max) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[front]);</span><br><span class="line">    <span class="comment">//front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]</span></span><br><span class="line">    front=(front+<span class="number">1</span>)%max;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[max];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果：</p><blockquote><p>1 2 3 4 5 6</p></blockquote><p>使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：</p><ul><li>当队列为空时，队列的头指针等于队列的尾指针；</li><li>当数组满员时，队列的头指针等于队列的尾指针；</li></ul><p>顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。</p><div class="note success"><p><strong><font color="#5cb85c">不去追逐，永远不会拥有。不往前走，永远原地停留!</font></strong><br>利用本篇文章的机会，给大家介绍了C队列以及简单的实现了顺序队列，并作出了一些优化。相关的代码依旧是托管在了github上面，需要的小伙伴请自取。如果有写的不好的地方，大家在评论区留言，我加以改正，和大家一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;green&quot;&gt;队列&lt;/font&gt;，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。&lt;/p&gt;&lt;h3 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h3&gt;&lt;p&gt;与栈结构不同的是，&lt;font color=&quot;red&quot;&gt;队列&lt;/font&gt;的两端都”开口”，要求数据只能从一端进，从另一端出，如下图示：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwb0hscS5naWY&quot; alt&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通常，称进数据的一端为 “&lt;font color=&quot;green&quot;&gt;队尾&lt;/font&gt;“，出数据的一端为 “&lt;font color=&quot;green&quot;&gt;队头&lt;/font&gt;“，数据元素进队列的过程称为 “&lt;font color=&quot;green&quot;&gt;入队&lt;/font&gt;“，出队列的过程称为 “&lt;font color=&quot;green&quot;&gt;出队&lt;/font&gt;“。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="顺序队列" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现链式栈</title>
    <link href="https://www.xiangjunhong.com/posts/6163d4b5.html"/>
    <id>https://www.xiangjunhong.com/posts/6163d4b5.html</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-02-12T05:40:35.532Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --><p>在之前写的C语言实现链式栈篇博文中，我已经给大家大概介绍了关于<a href="https://www.xiangjunhong.com/posts/9b621d6f.html">链式栈</a>的意义以及相关操作,我会在下面给大家分享百度百科对链式栈的定义，以及给大家介绍利用C++实现链式栈的基本操作。</p><h3 id="百度百科链式栈"><a href="#百度百科链式栈" class="headerlink" title="百度百科链式栈"></a>百度百科链式栈</h3><blockquote><p>链式栈是一种数据存储结构，可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。</p></blockquote><p><font color="blue">栈</font>是只能在某一端插入和删除的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底（push），最后的数据在栈顶（top），需要读数据的时候从栈顶开始弹出数据（top）最后一个数据被第一个读出来。链式栈中的元素以Node的形式存储，节点Node中存有此节点存于栈中的元素以及指向下个节点的指针。链式栈的数据成员只用保存指向栈顶节点的指针 *top_node。</p><a id="more"></a><p><font color="blue">顺序栈</font>的实现在于使用了数组这个基本数据结构，数组中的元素在内存中的存储位置是连续的，且编译器要求我们在编译期就要确定数组的大小，这样<font color="DarkViolet">对内存的使用效率并不高，一来无法避免因数组空间用光而引起的溢出问题，二在系统将内存分配给数组后，则这些内存对于其他任务就不可用</font>；而对于链栈而言，使用了<font color="gree">链表来实现栈，链表中的元素存储在不连续的地址，由于是动态申请内存，所以我们可以以非常小的内存空间开始，另外当某个项不使用时也可将内存返还给系统</font>。</p><h3 id="C-实现链式栈"><a href="#C-实现链式栈" class="headerlink" title="C++实现链式栈"></a>C++实现链式栈</h3><p>利用C++语言实现了数据结构的链式栈，主要完成了以下操作：</p><table><thead><tr><th>链式栈的</th><th>基本操作</th></tr></thead><tbody><tr><td>元素进栈</td><td>元素出栈</td></tr><tr><td>返回栈顶元素</td><td>判断栈是否为空</td></tr><tr><td>打印栈的元素</td><td></td></tr></tbody></table><h4 id="链式栈的结点"><a href="#链式栈的结点" class="headerlink" title="链式栈的结点"></a>链式栈的结点</h4><p>链式栈的结点其实跟链式结构的顺序结构差不多类似，包含两部分，一是储存数据的<font color="red">数据域</font>，二是储存下一结点地址的<font color="red">指针域</font>,因此以结构体封装的结点如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainStackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T data;<span class="comment">//链式栈储存结点的数据</span></span><br><span class="line">chainStackNode&lt;T&gt; *next;<span class="comment">//链式栈指向下一结点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="链式栈的基本操作"><a href="#链式栈的基本操作" class="headerlink" title="链式栈的基本操作"></a>链式栈的基本操作</h4><p>在写这次链式栈的时候，我在所有的函数实现前都加上了<font color="red">inline</font>,在这里给大家解释一下。inline是<font color="green">C++关键字</font>，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为<font color="green">内联函数</font>，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造函数，就是实现成员的初始化操作，当然在这里实现链式栈的初始化就只需要创建一个头指针，并初始化头指针的各个成员。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:chainStack()</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="keyword">new</span> chainStackNode&lt;T&gt;;<span class="comment">//创建一个新的结点</span></span><br><span class="line">top-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将top的next指针指向空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素进栈"><a href="#元素进栈" class="headerlink" title="元素进栈"></a>元素进栈</h5><p>链式栈的进栈操作，顾名思义就是一个新的元素进入栈，当然首先要创建一个新的结点，然后就是将这个新的结点插入到栈顶，只需要调整来两个指针操作。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Push(T newData)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *newNode = <span class="keyword">new</span> chainStackNode&lt;T&gt;;</span><br><span class="line"><span class="keyword">if</span>(!newNode)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"分配内存失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;data = newData;<span class="comment">//修改指针，添加元素</span></span><br><span class="line">newNode-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h5><p>元素出栈，就跟线性表的删除元素类似，不过只能删除顶部结点，这个栈的特性是不可以违背的，调整指针删除结点之后不要忘了释放删除的结点的内存。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Pop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *temporaryNode;<span class="comment">//创建一个临时指针指向删除结点</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"该栈为空！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temporaryNode = top-&gt;next;</span><br><span class="line">x = temporaryNode-&gt;data;<span class="comment">//以引用返回</span></span><br><span class="line">top-&gt;next = temporaryNode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temporaryNode;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="返回栈顶元素"><a href="#返回栈顶元素" class="headerlink" title="返回栈顶元素"></a>返回栈顶元素</h5><p>返回栈顶的元素，判断栈是否为空，如果为空自然没有元素可以返回，否则就返回top指向的下一个结点的数据即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:getTop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = top-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h5><p>有了top指针，就只需要判断top指针的下一结点是否为空即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(top-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//top指针的下一结点是否为空，以此来判断是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印栈的元素"><a href="#打印栈的元素" class="headerlink" title="打印栈的元素"></a>打印栈的元素</h5><p>打印栈的元素，就是一个遍历的过程，定义一个指针，输出结点数据，调整指针位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">void</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:printChainStackData()</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *pMove;</span><br><span class="line">pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]-&gt;"</span>;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">冰冻三尺，非一日之寒!</font></strong><br>到这里，利用C++语言实现链式栈的介绍就已经结束了，如果有哪里写的不好的地方，还希望大家给我提出了，我加以修正，完整的代码包括测试代码我已经push到了github<a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E9%93%BE%E5%BC%8F%E6%A0%88" target="_blank" rel="noopener">C++实现链式栈</a>，如果大家有什么想法的，欢迎在下方评论区留言，我们一起讨论，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在之前写的C语言实现链式栈篇博文中，我已经给大家大概介绍了关于&lt;a href=&quot;https://www.xiangjunhong.com/posts/9b621d6f.html&quot;&gt;链式栈&lt;/a&gt;的意义以及相关操作,我会在下面给大家分享百度百科对链式栈的定义，以及给大家介绍利用C++实现链式栈的基本操作。&lt;/p&gt;&lt;h3 id=&quot;百度百科链式栈&quot;&gt;&lt;a href=&quot;#百度百科链式栈&quot; class=&quot;headerlink&quot; title=&quot;百度百科链式栈&quot;&gt;&lt;/a&gt;百度百科链式栈&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;链式栈是一种数据存储结构，可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;栈&lt;/font&gt;是只能在某一端插入和删除的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底（push），最后的数据在栈顶（top），需要读数据的时候从栈顶开始弹出数据（top）最后一个数据被第一个读出来。链式栈中的元素以Node的形式存储，节点Node中存有此节点存于栈中的元素以及指向下个节点的指针。链式栈的数据成员只用保存指向栈顶节点的指针 *top_node。&lt;/p&gt;
    
    </summary>
    
    
      <category term="链式栈" scheme="https://www.xiangjunhong.com/categories/%E9%93%BE%E5%BC%8F%E6%A0%88/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%93%BE%E5%BC%8F%E6%A0%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现双向循环链表</title>
    <link href="https://www.xiangjunhong.com/posts/a530f7f0.html"/>
    <id>https://www.xiangjunhong.com/posts/a530f7f0.html</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-02-07T13:02:37.492Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --><p>本次博文是关于利用C++模板的方式实现的双向循环链表以及双向循环链表的基本操作，在之前的博文C++语言实现双向链表中，以下是链接<a href="https://www.xiangjunhong.com/posts/5394fce7.html" class="LinkCard">C++语言实现双向循环链表</a>已经给大家分析了双向循环链表的结构，并以图示的方式给大家解释了双向循环链表的基本操作。本篇文章利用C++实现了双向循环链表的基本操作，其中包括：</p><table><thead><tr><th>双向循环链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>双向循环链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>在之前的C++语言实现双向链表时已经给大家解释了封装的结点的特点，不需要作太大的改变，我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向循环链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedList</span>;</span><span class="comment">//声明一下双向循环链表，以免定义友元时报错</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向循环链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleCircularLinkedListNode(T _data,doubleCircularLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleCircularLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>本次实现的操作跟双向链表实现的操作基本一样，实现了双向循环链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向循环链表的长度，打印双向循环链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>实现双向循环链表的头部插入结点，之前的双向链表因为在头部和尾部的指针都是指向<font color="green">NULL</font>的,所以需要分情况来处理，然而双向循环链表没有元素时这两个指针都是指向自身的，因此并不需要分情况处理，都需要修改四个指针。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，调整四个指针即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* lastNode = headNode;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都需要调整四个指针，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历双向循环链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next; <span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMoveprior = headNode;<span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;data != item)</span><br><span class="line">&#123;</span><br><span class="line">pMoveprior = pMove;</span><br><span class="line">pMove = pMoveprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(pMove == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pMove = headNode;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向循环链表的长度"><a href="#双向循环链表的长度" class="headerlink" title="双向循环链表的长度"></a>双向循环链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向循环链表"><a href="#打印双向循环链表" class="headerlink" title="打印双向循环链表"></a>打印双向循环链表</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove !=headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">与其用泪水悔恨今天，不如用汗水拼搏明天!</font></strong><br>以上就是我简要的给大家分享的C++实现双向循环链表，因为实现了双向链表，所以基本上实现思路差不多，唯一的不同就是在<font color="red">循环</font>一词不同，这一不同就是头结点的前驱指针和尾结点的后驱指针指向不同，要是还是不太清楚的可以去那篇博客看看。本次的完整代码已经全部上传到github! <a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">(C++实现双向循环链表)</a>,如果有什么问题，欢迎在下方评论区留言啊，我们一起讨论啊，一起进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本次博文是关于利用C++模板的方式实现的双向循环链表以及双向循环链表的基本操作，在之前的博文C++语言实现双向链表中，以下是链接&lt;a href=&quot;https://www.xiangjunhong.com/posts/5394fce7.html&quot; class=&quot;LinkCard&quot;&gt;C++语言实现双向循环链表&lt;/a&gt;已经给大家分析了双向循环链表的结构，并以图示的方式给大家解释了双向循环链表的基本操作。本篇文章利用C++实现了双向循环链表的基本操作，其中包括：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;双向循环链表&lt;/th&gt;&lt;th&gt;实现的功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;头部插入结点建立链表&lt;/td&gt;&lt;td&gt;尾部插入结点建立链表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实现指定位置插入结点&lt;/td&gt;&lt;td&gt;查找给定数值是否存在&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除指定位置的结点&lt;/td&gt;&lt;td&gt;修改指定位置的结点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;双向链表的长度&lt;/td&gt;&lt;td&gt;打印双向链表&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/"/>
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现双向链表</title>
    <link href="https://www.xiangjunhong.com/posts/5394fce7.html"/>
    <id>https://www.xiangjunhong.com/posts/5394fce7.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-02-03T10:13:36.208Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --><p>这篇文章是关于利用C++模板的方式实现的双向链表以及双向链表的基本操作，在之前的博文中，以下是链接<br><a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">C++语言实现双向链表</a><br>已经给大家分析了双向链表的结构，并以图示的方式给大家解释了双向链表的基本操作。本篇文章利用C++实现了双向链表的基本操作，其中包括：</p><blockquote><p><strong>双向链表的基本操作C++语言实现</strong></p></blockquote><table><thead><tr><th>双向链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>因为双向链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>因此，首先我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleLinkedListNode(T _data,doubleLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>实现了双向链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向链表的长度，打印双向链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>带头结点实现的双向链表，实现头部插入结点可分为两种情况，一种是只有一个头结点的时候，只需要使<font color="blue">head</font>和<font color="blue">newNode</font>的两个指针关联上即可，另外的两个指针依旧是<font color="blue">NULL</font>状态。另一种情况便是有结点的情况，这个时候跟在中间结点插入相似，需要调整四个指针,首先是让<font color="blue">newNode</font>与后继结点关联，最后让<font color="blue">newNode</font>与<font color="blue">head</font>结点关联。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分两种情况，head的next是否为NULL,然后处理四个指针</span></span><br><span class="line"><span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，双向链表因为两端的指针都是指向<font color="blue">NULL</font>的，所以在尾部插入也只需要调整两个指针就ok.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* lastNode = head;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到调整指针</span></span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都逃不过调整四个指针，但是首先依旧是让新结点和后继结点建立上相关性，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> doubleLinkedList&lt;T&gt;::insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>)<span class="comment">//链表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pMove)<span class="comment">//遍历链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;data == item)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pMove = head;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回，具体的用法在测试函数中写到了的，不会的可以作为参考。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向链表的长度"><a href="#双向链表的长度" class="headerlink" title="双向链表的长度"></a>双向链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向链表"><a href="#打印双向链表" class="headerlink" title="打印双向链表"></a>打印双向链表</h4><p>打印双向链表，从第二个结点开始遍历链表，因为第一个为头结点是不含数据的，打印的过程也就是一个遍历的过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次博文与大家分享的利用C++语言实现双向链表，在用C语言写了之后，感觉写起来就比较轻松，唯一不同的就是要利用类来进行封装。完整的代码，以及测试代码我已经Push到Github,喜欢的小伙伴欢迎Star! <a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">C++语言实现双向链表Github地址</a>，我们一起讨论，如果有写的不好的地方还请多多担待，也欢迎大家在评论区留言，我加以改正，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:43 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;这篇文章是关于利用C++模板的方式实现的双向链表以及双向链表的基本操作，在之前的博文中，以下是链接&lt;br&gt;&lt;a href=&quot;https://www.xiangjunhong.com/posts/beb5106a.html&quot; class=&quot;LinkCard&quot;&gt;C++语言实现双向链表&lt;/a&gt;&lt;br&gt;已经给大家分析了双向链表的结构，并以图示的方式给大家解释了双向链表的基本操作。本篇文章利用C++实现了双向链表的基本操作，其中包括：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;双向链表的基本操作C++语言实现&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;双向链表&lt;/th&gt;&lt;th&gt;实现的功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;头部插入结点建立链表&lt;/td&gt;&lt;td&gt;尾部插入结点建立链表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实现指定位置插入结点&lt;/td&gt;&lt;td&gt;查找给定数值是否存在&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除指定位置的结点&lt;/td&gt;&lt;td&gt;修改指定位置的结点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;双向链表的长度&lt;/td&gt;&lt;td&gt;打印双向链表&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/"/>
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现链式栈</title>
    <link href="https://www.xiangjunhong.com/posts/9b621d6f.html"/>
    <id>https://www.xiangjunhong.com/posts/9b621d6f.html</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-02-01T12:07:57.055Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p><font color="red">链栈</font>，即用<font color="blue">链表</font>实现栈存储结构。链栈的实现思路同顺序栈类似，<font color="blue">顺序栈</font>是将数<font color="blue">顺序表（数组）</font>的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如下下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHYzNEQS5naWY" alt="在这里插入图片描述"></p><blockquote><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p></blockquote><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”<font color="green">入栈</font>“操作时，需要将数据从链表的头部插入；</li><li>在实现数据”<font color="green">出栈</font>“操作时，需要删除链表头部的首元节点；<a id="more"></a></li></ul><p><font color="red">因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</font></p><h3 id="链栈元素入栈"><a href="#链栈元素入栈" class="headerlink" title="链栈元素入栈"></a>链栈元素入栈</h3><p>例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHY3FQSy5naWY" alt><br>C语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="comment">//stack为当前的链栈，a表示入栈元素</span></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储新元素的节点</span></span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    <span class="comment">//新节点与头节点建立逻辑关系</span></span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//更新头指针的指向</span></span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链栈元素出栈"><a href="#链栈元素出栈" class="headerlink" title="链栈元素出栈"></a>链栈元素出栈</h3><p>例如，上图所示的链栈中，若要将元素 3 出栈，根据”先进后出”的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHZ2Jlcy5naWY" alt="在这里插入图片描述"><br>因此，实现栈顶元素出链栈的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶元素出链栈的实现函数</span></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="comment">//声明一个新指针指向栈顶节点</span></span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">//更新头指针</span></span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"新栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中通过使用 if 判断语句，避免了用户执行”栈已空却还要数据出栈”错误操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"弹栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>弹栈元素：4 栈顶元素：3<br>弹栈元素：3 栈顶元素：2<br>弹栈元素：2 栈顶元素：1<br>弹栈元素：1 栈已空<br>栈内没有元素</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次分享给大家的利用C语言实现链栈，二月的第一篇博文，希望得到大家的支持鸭！如果有什么写的不好，不对的地方，还望各路大神指出来，欢迎在下方评论区留言！我们一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;链栈&lt;/font&gt;，即用&lt;font color=&quot;blue&quot;&gt;链表&lt;/font&gt;实现栈存储结构。链栈的实现思路同顺序栈类似，&lt;font color=&quot;blue&quot;&gt;顺序栈&lt;/font&gt;是将数&lt;font color=&quot;blue&quot;&gt;顺序表（数组）&lt;/font&gt;的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如下下图所示：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHYzNEQS5naWY&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;链表的头部作为栈顶，意味着：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在实现数据”&lt;font color=&quot;green&quot;&gt;入栈&lt;/font&gt;“操作时，需要将数据从链表的头部插入；&lt;/li&gt;&lt;li&gt;在实现数据”&lt;font color=&quot;green&quot;&gt;出栈&lt;/font&gt;“操作时，需要删除链表头部的首元节点；
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="链式栈" scheme="https://www.xiangjunhong.com/tags/%E9%93%BE%E5%BC%8F%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现双向循环链表</title>
    <link href="https://www.xiangjunhong.com/posts/538e5180.html"/>
    <id>https://www.xiangjunhong.com/posts/538e5180.html</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-01-31T08:45:49.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --><p>在之前的文章中，我写过一篇关于C语言实现双向链表的博文，下面是链接：<a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">双向链表</a><br>介绍了双向链表的实现过程以及双向链表的优势，接下来我首先给大家介绍一下<font color="red">循环链表</font>和<font color="red">双向链表</font>的区别，之后再给大家介绍<font color="blue">双向循环</font>链表的具体实现。</p><h3 id="循环链表和双向链表的区别"><a href="#循环链表和双向链表的区别" class="headerlink" title="循环链表和双向链表的区别"></a>循环链表和双向链表的区别</h3><p>1、最后一个结点指针指向不同</p><p>在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是像双向链表那样置为NULL。此种情况还用于在最后一个结点后插入一个新的结点。</p><p>2、判断链域值不同</p><p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非像单链表那样判断链域值是否为NULL。</p><a id="more"></a><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQVBiUS5wbmc?x-oss-process=image/format,png" alt><br>3、访问方式：</p><p>循环链表：可以从任何一个结点开始，顺序向后访问到达任意结点</p><p>双向链表：可以从任何结点开始任意向前向后双向访问</p><p>4、操作：</p><p>循环链表：只能在当前结点后插入和删除</p><p>双链表：可以在当前结点前面或者后面插入，可以删除前趋和后继（包括结点自己）</p><p>5、存储：循环链表存储密度大于双链表</p><h3 id="双向循环链表的具体实现"><a href="#双向循环链表的具体实现" class="headerlink" title="双向循环链表的具体实现"></a>双向循环链表的具体实现</h3><p>双向循环链表：最后一个节点的next指向head，而head的prior指向最后一个节点，构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQTJNOC5tZC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>由上图可以看出，双向循环链表的结点结构与双向链表的结构是一样的，都是含有三项：<font color="blue">前驱指针prior</font>,<font color="blue">数据项data</font>,<font color="blue">后驱指针next</font>,因此双向循环链表结点结构用C语言实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">prior</span>;</span><span class="comment">//结点的前驱指针</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//结点的数据项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//结点的后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h5 id="双向循环链表的初始化"><a href="#双向循环链表的初始化" class="headerlink" title="双向循环链表的初始化"></a>双向循环链表的初始化</h5><p>只有一个头节点head，就让prior和next都指向自己，形成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkNETy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>初始化头结点代码实现：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头结点，数据差异化当作表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">headNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//循环链表，所以初始化头指针，尾指针都是指向自身的，data数据域不做初始化</span></span><br><span class="line">headNode-&gt;prior = headNode;<span class="comment">//头结点指向自身</span></span><br><span class="line">headNode-&gt;next = headNode;<span class="comment">//尾结点指向自身</span></span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="创建一个新的结点"><a href="#创建一个新的结点" class="headerlink" title="创建一个新的结点"></a>创建一个新的结点</h5><p>与单向循环链表类似的，只是多了一个prior要考虑，为插入做准备。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkRJSi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//动态申请内存malloc+free c语言的特点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//创建结点过程相当于初始化过程</span></span><br><span class="line">newNode-&gt;data = data;<span class="comment">//传入data数值初始化数据域</span></span><br><span class="line">newNode-&gt;prior = <span class="literal">NULL</span>;<span class="comment">//初始化头结点为null</span></span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化尾结点为null</span></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="插入新的元素"><a href="#插入新的元素" class="headerlink" title="插入新的元素"></a>插入新的元素</h5><p>与单向循环链表类似，只是多了一个prior要考虑。这里就不需判断插入的位置是不是在最后了，已经构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzZXVXUi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h6 id="表头插入实现"><a href="#表头插入实现" class="headerlink" title="表头插入实现"></a>表头插入实现</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeByHead</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点，调用创建新结点的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//修改四个指针变量</span></span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h6 id="表尾插入实现"><a href="#表尾插入实现" class="headerlink" title="表尾插入实现"></a>表尾插入实现</h6><blockquote><p>在表尾插入，比表头插入更容易出错，大家多加注意！首先找到尾部最后一个元素，然后再进行插入操作</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeBynext</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//首先找到最后一个结点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">lastNode</span> = <span class="title">headNode</span>;</span></span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h5><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可，<font color="red">删除之后不要忘了释放空间哟！</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzbU1OUS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpecifyLocationToDelete</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在指定位置，无法删除！\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNodeprior-&gt;next = posNode-&gt;next;</span><br><span class="line">posNode-&gt;next-&gt;prior=posNodeprior;</span><br><span class="line"><span class="built_in">free</span>(posNode);<span class="comment">//删除之后，释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素"><a href="#查找指定元素" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchSpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该元素存在！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素-1"><a href="#查找指定元素-1" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifySpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData,<span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNode-&gt;data = elem;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a>打印数据</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct doubleCircularLinkedList* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line"><span class="comment">//也可以通过前指针进行打印，只需将next改为prior即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">pMove</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考博文：<br><a href="https://blog.csdn.net/baweiyaoji/article/details/76071053" target="_blank" rel="noopener">https://blog.csdn.net/baweiyaoji/article/details/76071053</a></p><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现双向循环链表，完整的代码已经push到了githubs上面（<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/doubleCircularLinkedList.c" target="_blank" rel="noopener">传送门</a>），欢迎各位clone，如果觉得还不错的话，欢迎Star! 如果有哪里有问题，欢迎大家在下面评论区留言，我及时修改更正，坚持就是胜利！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Jul 30 2020 14:10:44 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在之前的文章中，我写过一篇关于C语言实现双向链表的博文，下面是链接：&lt;a href=&quot;https://www.xiangjunhong.com/posts/beb5106a.html&quot; class=&quot;LinkCard&quot;&gt;双向链表&lt;/a&gt;&lt;br&gt;介绍了双向链表的实现过程以及双向链表的优势，接下来我首先给大家介绍一下&lt;font color=&quot;red&quot;&gt;循环链表&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;双向链表&lt;/font&gt;的区别，之后再给大家介绍&lt;font color=&quot;blue&quot;&gt;双向循环&lt;/font&gt;链表的具体实现。&lt;/p&gt;&lt;h3 id=&quot;循环链表和双向链表的区别&quot;&gt;&lt;a href=&quot;#循环链表和双向链表的区别&quot; class=&quot;headerlink&quot; title=&quot;循环链表和双向链表的区别&quot;&gt;&lt;/a&gt;循环链表和双向链表的区别&lt;/h3&gt;&lt;p&gt;1、最后一个结点指针指向不同&lt;/p&gt;&lt;p&gt;在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是像双向链表那样置为NULL。此种情况还用于在最后一个结点后插入一个新的结点。&lt;/p&gt;&lt;p&gt;2、判断链域值不同&lt;/p&gt;&lt;p&gt;在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非像单链表那样判断链域值是否为NULL。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
