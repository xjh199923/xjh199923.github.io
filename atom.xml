<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BeiXi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.xiangjunhong.com/"/>
  <updated>2020-04-15T07:03:21.908Z</updated>
  <id>https://www.xiangjunhong.com/</id>
  
  <author>
    <name>北徯。</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sql create table</title>
    <link href="https://www.xiangjunhong.com/posts/e4bced2a.html"/>
    <id>https://www.xiangjunhong.com/posts/e4bced2a.html</id>
    <published>2020-04-09T10:05:36.030Z</published>
    <updated>2020-04-15T07:03:21.908Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h4 id="Sql-create-table-语句"><a href="#Sql-create-table-语句" class="headerlink" title="Sql create table 语句"></a>Sql create table 语句</h4><p>Sql create table 语句用于创建数据库中的表。<br>表由行和列组成，每个表都必须有个表名。</p><h4 id="create-table-语法"><a href="#create-table-语法" class="headerlink" title="create table 语法"></a>create table 语法</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>),</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>),</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>),</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>column_name 参数规定表中列的名称。<br>data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。<br>size 参数规定表中列的最大长度。</p></blockquote><a id="more"></a><h4 id="create-table-实例"><a href="#create-table-实例" class="headerlink" title="create table 实例"></a>create table 实例</h4><p>现在我们想要创建一个名为 “Persons” 的表，包含五列：PersonID、Name、Address 和 City。<br>我们使用下面的 create table语句：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonID <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>PersonID 列的数据类型是 int，包含整数。<br>Name、Address 和 City 列的数据类型是 varchar，包含字符，且这些字段的最大长度为 255 个字符。</p></blockquote><p>空的 “Persons” 表如下所示：</p><table><thead><tr><th>PersonID</th><th>Name</th><th>Address</th><th>City</th></tr></thead></table><p>在Sql server创建表如图所示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvYnlGaDQzWDlvekNmNnZ0LnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><p>可使用 insert into 语句向空表写入数据,这个语法我们在后面的教程会讲到。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-create-table-语句&quot;&gt;&lt;a href=&quot;#Sql-create-table-语句&quot; class=&quot;headerlink&quot; title=&quot;Sql create table 语句&quot;&gt;&lt;/a&gt;Sql create table 语句&lt;/h4&gt;&lt;p&gt;Sql create table 语句用于创建数据库中的表。&lt;br&gt;表由行和列组成，每个表都必须有个表名。&lt;/p&gt;&lt;h4 id=&quot;create-table-语法&quot;&gt;&lt;a href=&quot;#create-table-语法&quot; class=&quot;headerlink&quot; title=&quot;create table 语法&quot;&gt;&lt;/a&gt;create table 语法&lt;/h4&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name1 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name2 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name3 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;column_name 参数规定表中列的名称。&lt;br&gt;data_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。&lt;br&gt;size 参数规定表中列的最大长度。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="create table" scheme="https://www.xiangjunhong.com/tags/create-table/"/>
    
  </entry>
  
  <entry>
    <title>Sql insert into</title>
    <link href="https://www.xiangjunhong.com/posts/be01953a.html"/>
    <id>https://www.xiangjunhong.com/posts/be01953a.html</id>
    <published>2020-04-09T10:04:39.854Z</published>
    <updated>2020-04-09T14:13:02.826Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h4 id="Sql-insert-into语句"><a href="#Sql-insert-into语句" class="headerlink" title="Sql insert into语句"></a>Sql insert into语句</h4><p>insert into 语句用于向表中插入新记录。</p><h4 id="insert-into-语法"><a href="#insert-into-语法" class="headerlink" title="insert into 语法"></a>insert into 语法</h4><p>insert into 语句可以有两种编写形式。</p><ol><li>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name</span><br><span class="line"><span class="keyword">values</span>(value1,value2,value3,...);</span><br></pre></td></tr></table></figure></div><ol start="2"><li>第二种形式需要指定列名及被插入的值：</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name (column1,column2,column3,...)</span><br><span class="line"><span class="keyword">values</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></div><a id="more"></a><h4 id="insert-into-实例"><a href="#insert-into-实例" class="headerlink" title="insert into 实例"></a>insert into 实例</h4><p>在本教程中，我们将使用上一节建立的Persons空表进行演示,假设我们要向 “Persons” 表中插入一个新行。<br>我们可以使用下面的 SQL 语句：</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Persons(PersonID,<span class="keyword">Name</span>,Address,City)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">2001</span>,<span class="string">'小明'</span>,<span class="string">'ChongQing'</span>,<span class="string">'Wushan'</span>);</span><br></pre></td></tr></table></figure></div><p>执行以上 SQL，再读取 “Persons” 表，数据如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvZGZvVzc2QWpuRUczdVljLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><h5 id="在指定的列插入数据"><a href="#在指定的列插入数据" class="headerlink" title="在指定的列插入数据"></a>在指定的列插入数据</h5><p>我们也可以在指定的列插入数据。<br>下面的 SQL 语句将插入一个新行，但是只在 “PersonID”、和 “Name” 列插入数据：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Persons(PersonID,<span class="keyword">Name</span>)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">2001</span>,<span class="string">'小花'</span>);</span><br></pre></td></tr></table></figure></div><p>执行以上 SQL，再读取 “Persons” 表，数据如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvSlpLMnY2em1vZWtGZE0zLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-insert-into语句&quot;&gt;&lt;a href=&quot;#Sql-insert-into语句&quot; class=&quot;headerlink&quot; title=&quot;Sql insert into语句&quot;&gt;&lt;/a&gt;Sql insert into语句&lt;/h4&gt;&lt;p&gt;insert into 语句用于向表中插入新记录。&lt;/p&gt;&lt;h4 id=&quot;insert-into-语法&quot;&gt;&lt;a href=&quot;#insert-into-语法&quot; class=&quot;headerlink&quot; title=&quot;insert into 语法&quot;&gt;&lt;/a&gt;insert into 语法&lt;/h4&gt;&lt;p&gt;insert into 语句可以有两种编写形式。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;(value1,value2,value3,...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;第二种形式需要指定列名及被插入的值：&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;into&lt;/span&gt; table_name (column1,column2,column3,...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt; (value1,value2,value3,...);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="insert into" scheme="https://www.xiangjunhong.com/tags/insert-into/"/>
    
  </entry>
  
  <entry>
    <title>Sql 约束（Constraints)</title>
    <link href="https://www.xiangjunhong.com/posts/6d7376dd.html"/>
    <id>https://www.xiangjunhong.com/posts/6d7376dd.html</id>
    <published>2020-04-09T10:03:01.294Z</published>
    <updated>2020-04-09T14:12:38.756Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h2 id="SQL-约束（Constraints）"><a href="#SQL-约束（Constraints）" class="headerlink" title="SQL 约束（Constraints）"></a>SQL 约束（Constraints）</h2><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 create table 语句），或者在表创建之后规定（通过 alter table 语句）。</p><h3 id="create-table-constraint-语法"><a href="#create-table-constraint-语法" class="headerlink" title="create table + constraint 语法"></a>create table + constraint 语法</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line">(</span><br><span class="line">column_name1 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name2 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">column_name3 data_type(<span class="keyword">size</span>) constraint_name,</span><br><span class="line">....</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><blockquote><p>在 SQL 中，我们有如下约束：</p><ul><li>not null - 指示某列不能存储 NULL 值。</li><li>unique - 保证某列的每行必须有唯一的值。</li><li>primary key - not null 和 unique 的结合。确保某列（或两个列多个列的结合）有唯&gt;一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li>foreign key - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li>check - 保证列中的值符合指定的条件。</li><li>default - 规定没有给列赋值时的默认值</li></ul></blockquote><p>接下来，我们依次给大家分享每一种约束。</p><a id="more"></a><h3 id="Sql-not-null-约束"><a href="#Sql-not-null-约束" class="headerlink" title="Sql not null 约束"></a>Sql not null 约束</h3><p>在默认的情况下，表的列接受 NULL 值。not null 约束强制列不接受 NULL 值。not null 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</p><p>下面的 SQL 强制 “PersonID” 列、 “Name” 列以及 “Address” 列不接受 NULL 值：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonID <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="添加-not-null-约束"><a href="#添加-not-null-约束" class="headerlink" title="添加 not null 约束"></a>添加 not null 约束</h4><p>在一个已创建的表的 “City” 字段中添加 not null 约束如下所示：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><h4 id="删除-not-null-约束"><a href="#删除-not-null-约束" class="headerlink" title="删除 not null 约束"></a>删除 not null 约束</h4><p>在一个已创建的表的 “Age” 字段中删除 NOT NULL 约束如下所示：<br>实例</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="built_in">varchar</span>(<span class="number">255</span>)  <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div><blockquote><p>注意：在添加和删除not null约束，我用change和modify命令始终报错，这是因为我用的是sql server数据库，而change和modify命令是在my sql 和oracle下才能用的语法。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvMjRZbmU5N2ZBTlZCMXlXLnBuZw?x-oss-process=image/format,png#pic_center" alt=" "></p><h3 id="Sql-unique-约束"><a href="#Sql-unique-约束" class="headerlink" title="Sql unique 约束"></a>Sql unique 约束</h3><p>unique 约束唯一标识数据库表中的每条记录。unique 和primary key约束均为列或列集合提供了唯一性的保证。primary key 约束拥有自动定义的 unique 约束。请注意，每个表可以有多个 unique约束，但是每个表只能有一个 primary key 约束。</p><h4 id="create-table-时的-unique-约束"><a href="#create-table-时的-unique-约束" class="headerlink" title="create table 时的 unique 约束"></a>create table 时的 unique 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonId” 列上创建unique 约束：</p><h6 id="MySQL："><a href="#MySQL：" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access："><a href="#SQL-Server-Oracle-MS-Access：" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">unique</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access："><a href="#MySQL-SQL-Server-Oracle-MS-Access：" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">unique</span> (PersonID),</span><br><span class="line"><span class="keyword">constraint</span> uc_PersonID <span class="keyword">unique</span> (PersonId,<span class="keyword">Name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h4 id="alter-时的-unique-约束"><a href="#alter-时的-unique-约束" class="headerlink" title="alter 时的 unique 约束"></a>alter 时的 unique 约束</h4><p>当表已被创建时，如需在 “PersonID” 列创建unique 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-1"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-1" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">unique</span> (PersonID)</span><br></pre></td></tr></table></figure></div><p>如需命名 unique 约束，并定义多个列的 unique 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-2"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-2" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> uc_PersonID <span class="keyword">unique</span> (PersonId,<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></div><h4 id="撤销-unique-约束"><a href="#撤销-unique-约束" class="headerlink" title="撤销 unique 约束"></a>撤销 unique 约束</h4><p>如需撤销 unique 约束，请使用下面的 SQL：</p><h6 id="MySQL：-1"><a href="#MySQL：-1" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> uc_PersonID</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-1"><a href="#SQL-Server-Oracle-MS-Access：-1" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> uc_PersonID</span><br></pre></td></tr></table></figure></div><h3 id="primary-key-约束"><a href="#primary-key-约束" class="headerlink" title="primary key 约束"></a>primary key 约束</h3><p>primary key 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值。主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。</p><h4 id="create-table-时的-primary-key-约束"><a href="#create-table-时的-primary-key-约束" class="headerlink" title="create table 时的 primary key 约束"></a>create table 时的 primary key 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonID” 列上创建 primary key 约束：</p><h6 id="MySQL：-2"><a href="#MySQL：-2" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">primary <span class="keyword">key</span> (PersonID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-2"><a href="#SQL-Server-Oracle-MS-Access：-2" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>如需命名 primary key 约束，并定义多个列的 primary key 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-3"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-3" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">constraint</span> pk_PersonID primary <span class="keyword">key</span> (PersonID,<span class="keyword">Name</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>注释：在上面的实例中，只有一个主键 primary key（pk_PersonID）。然而，pk_PersonID 的值是由两个列（PersonID和 Name）组成的。</p><h4 id="alter-table-时的-primary-key-约束"><a href="#alter-table-时的-primary-key-约束" class="headerlink" title="alter table 时的 primary key 约束"></a>alter table 时的 primary key 约束</h4><p>当表已被创建时，如需在 “PersonId” 列创建 primary key 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-4"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-4" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> primary <span class="keyword">key</span> (PersonID)</span><br></pre></td></tr></table></figure></div><p>如需命名 primary key 约束，并定义多个列的 primary key 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-5"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-5" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> pk_PersonID primary <span class="keyword">key</span> (PersonID,<span class="keyword">Name</span>)</span><br></pre></td></tr></table></figure></div><p>注释：如果您使用 alter table 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。</p><h4 id="撤销-primary-key-约束"><a href="#撤销-primary-key-约束" class="headerlink" title="撤销 primary key 约束"></a>撤销 primary key 约束</h4><p>如需撤销 primary key 约束，请使用下面的 SQL：</p><h6 id="MySQL：-3"><a href="#MySQL：-3" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> primary <span class="keyword">key</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-3"><a href="#SQL-Server-Oracle-MS-Access：-3" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> pk_PersonID</span><br></pre></td></tr></table></figure></div><h3 id="foreign-key-约束"><a href="#foreign-key-约束" class="headerlink" title="foreign key 约束"></a>foreign key 约束</h3><p>一个表中的 foreign key 指向另一个表中的 unique key(唯一约束的键)。<br>让我们通过一个实例来解释外键。请看下面两个表：<br>Persons 表：</p><table><thead><tr><th>PersonId</th><th>Name</th><th>Address</th><th>City</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>Timoteivn</td><td>Sandnes</td></tr><tr><td>2</td><td>小红</td><td>Timoteivn</td><td>Sandnes</td></tr><tr><td>3</td><td>小军</td><td>Timoteivn</td><td>Stavanger</td></tr></tbody></table><p>Orders表：</p><table><thead><tr><th>OrderId</th><th>OrderNo</th><th>PersonId</th></tr></thead><tbody><tr><td>1</td><td>77895</td><td>3</td></tr><tr><td>2</td><td>44678</td><td>3</td></tr><tr><td>3</td><td>22456</td><td>2</td></tr><tr><td>4</td><td>24562</td><td>1</td></tr></tbody></table><blockquote><p>请注意:</p><ul><li>Orders”表中的 “PersonId” 列指向 “Persons” 表中的 “PersonId” 列。</li><li>“Persons” 表中的 “PersonId” 列是 “Persons” 表中的 primary key。</li><li>“Orders” 表中的 “PersonId” 列是 “Orders” 表中的 foreign key。</li><li>foreign key约束用于预防破坏表之间连接的行为。</li><li>foreign key约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li></ul></blockquote><h4 id="create-table-时的foreign-key-约束"><a href="#create-table-时的foreign-key-约束" class="headerlink" title="create table 时的foreign key 约束"></a>create table 时的foreign key 约束</h4><p>下面的 SQL 在 “Orders” 表创建时在 “PersonId” 列上创建 foreign key 约束：</p><h6 id="MySQL：-4"><a href="#MySQL：-4" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(OrderId),</span><br><span class="line"> <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId) <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-4"><a href="#SQL-Server-Oracle-MS-Access：-4" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span> <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如需命名foreign key 约束，并定义多个列的foreign key约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-6"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-6" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line"> OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> PesonId <span class="built_in">int</span>,</span><br><span class="line"> primary <span class="keyword">key</span>(OrderId),</span><br><span class="line"> <span class="keyword">constraint</span> fk_PerOrders <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId) <span class="keyword">references</span> Persons(P_Id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table时的foreign-key约束"><a href="#alter-table时的foreign-key约束" class="headerlink" title="alter table时的foreign key约束"></a>alter table时的foreign key约束</h4><p>当 “Orders” 表已被创建时，如需在 “P_Id” 列创建 foreign key约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-7"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-7" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId)</span><br><span class="line"><span class="keyword">references</span> Persons(PersonId)</span><br></pre></td></tr></table></figure></div><p>如需命名 foreign key约束，并定义多个列的 foreign key约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-8"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-8" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> fk_PerOrders</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (PersonId)</span><br><span class="line"><span class="keyword">references</span> Persons(PersonId)</span><br></pre></td></tr></table></figure></div><h4 id="撤销foreign-key约束"><a href="#撤销foreign-key约束" class="headerlink" title="撤销foreign key约束"></a>撤销foreign key约束</h4><p>如需撤销 foreign key约束，请使用下面的 SQL：</p><h6 id="MySQL：-5"><a href="#MySQL：-5" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> fk_PerOrders</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-5"><a href="#SQL-Server-Oracle-MS-Access：-5" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Orders</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> fk_PerOrders</span><br></pre></td></tr></table></figure></div><h3 id="check-约束"><a href="#check-约束" class="headerlink" title="check 约束"></a>check 约束</h3><p>check 约束用于限制列中的值的范围。如果对单个列定义 check 约束，那么该列只允许特定的值。如果对一个表定义 check 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。</p><h4 id="create-table-时的check-约束"><a href="#create-table-时的check-约束" class="headerlink" title="create table 时的check 约束"></a>create table 时的check 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “PersonId” 列上创建 check 约束。check 约束规定 “PersonId” 列必须只包含大于 0 的整数。</p><h6 id="MySQL：-6"><a href="#MySQL：-6" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line"><span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-6"><a href="#SQL-Server-Oracle-MS-Access：-6" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>)  </span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-9"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-9" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>),  </span><br><span class="line"><span class="keyword">constraint</span> chk_Person <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span> <span class="keyword">and</span> City=<span class="string">'Sandnes'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table-时的check-约束"><a href="#alter-table-时的check-约束" class="headerlink" title="alter table 时的check 约束"></a>alter table 时的check 约束</h4><p>当表已被创建时，如需在 “P_Id” 列创建 check 约束，请使用下面的 SQL：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access"><a href="#MySQL-SQL-Server-Oracle-MS-Access" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access:"></a>MySQL / SQL Server / Oracle / MS Access:</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><p>如需命名 check 约束，并定义多个列的 check 约束，请使用下面的 SQL 语法：</p><h6 id="MySQL-SQL-Server-Oracle-MS-Access：-10"><a href="#MySQL-SQL-Server-Oracle-MS-Access：-10" class="headerlink" title="MySQL / SQL Server / Oracle / MS Access："></a>MySQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span>  Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> chk_Person <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span> <span class="keyword">and</span> City=<span class="string">'Sandnes'</span>)</span><br></pre></td></tr></table></figure></div><h4 id="撤销-check-约束"><a href="#撤销-check-约束" class="headerlink" title="撤销 check 约束"></a>撤销 check 约束</h4><p>如需撤销 check 约束，请使用下面的 SQL：</p><h6 id="SQL-Server-Oracle-MS-Access：-7"><a href="#SQL-Server-Oracle-MS-Access：-7" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">constraint</span> chk_Person</span><br></pre></td></tr></table></figure></div><h6 id="MySQL：-7"><a href="#MySQL：-7" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">check</span> chk_Person</span><br></pre></td></tr></table></figure></div><h3 id="Sql-default-约束"><a href="#Sql-default-约束" class="headerlink" title="Sql default 约束"></a>Sql default 约束</h3><p>default 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p><h4 id="create-table-时的default-约束"><a href="#create-table-时的default-约束" class="headerlink" title="create table 时的default 约束"></a>create table 时的default 约束</h4><p>下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 default 约束：</p><h6 id="My-SQL-SQL-Server-Oracle-MS-Access："><a href="#My-SQL-SQL-Server-Oracle-MS-Access：" class="headerlink" title="My SQL / SQL Server / Oracle / MS Access："></a>My SQL / SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Persons</span><br><span class="line">(</span><br><span class="line">PersonId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span> (PersonId&gt;<span class="number">0</span>),</span><br><span class="line"><span class="keyword">Name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">City <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">'Sandnes'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><p>通过使用类似getdata()这样的函数，default 约束也可以用于插入系统值：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Orders</span><br><span class="line">(</span><br><span class="line">OrderId <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">OrderNo <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">PersonId <span class="built_in">int</span>,</span><br><span class="line">OrderDate <span class="built_in">date</span> <span class="keyword">default</span> getdata()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h4 id="alter-table-时的default-约束"><a href="#alter-table-时的default-约束" class="headerlink" title="alter table 时的default 约束"></a>alter table 时的default 约束</h4><p>当表已被创建时，如需在 “City” 列创建 default 约束，请使用下面的 SQL：</p><h6 id="MySQL：-8"><a href="#MySQL：-8" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> City <span class="keyword">set</span> <span class="keyword">default</span> <span class="string">'SANDNES'</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-MS-Access："><a href="#SQL-Server-MS-Access：" class="headerlink" title="SQL Server / MS Access："></a>SQL Server / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">add</span> <span class="keyword">constraint</span> ab_c <span class="keyword">default</span> <span class="string">'SANDNES'</span> <span class="keyword">for</span> City</span><br></pre></td></tr></table></figure></div><h6 id="Oracle："><a href="#Oracle：" class="headerlink" title="Oracle："></a>Oracle：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">modify</span> City <span class="keyword">default</span> <span class="string">'SANDNES'</span></span><br></pre></td></tr></table></figure></div><h4 id="撤销-default-约束"><a href="#撤销-default-约束" class="headerlink" title="撤销 default 约束"></a>撤销 default 约束</h4><p>如需撤销 default 约束，请使用下面的 SQL：</p><h6 id="MySQL：-9"><a href="#MySQL：-9" class="headerlink" title="MySQL："></a>MySQL：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> City <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div><h6 id="SQL-Server-Oracle-MS-Access：-8"><a href="#SQL-Server-Oracle-MS-Access：-8" class="headerlink" title="SQL Server / Oracle / MS Access："></a>SQL Server / Oracle / MS Access：</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> Persons</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">column</span> City <span class="keyword">drop</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;SQL-约束（Constraints）&quot;&gt;&lt;a href=&quot;#SQL-约束（Constraints）&quot; class=&quot;headerlink&quot; title=&quot;SQL 约束（Constraints）&quot;&gt;&lt;/a&gt;SQL 约束（Constraints）&lt;/h2&gt;&lt;p&gt;SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 create table 语句），或者在表创建之后规定（通过 alter table 语句）。&lt;/p&gt;&lt;h3 id=&quot;create-table-constraint-语法&quot;&gt;&lt;a href=&quot;#create-table-constraint-语法&quot; class=&quot;headerlink&quot; title=&quot;create table + constraint 语法&quot;&gt;&lt;/a&gt;create table + constraint 语法&lt;/h3&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; table_name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name1 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name2 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;column_name3 data_type(&lt;span class=&quot;keyword&quot;&gt;size&lt;/span&gt;) constraint_name,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;在 SQL 中，我们有如下约束：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;not null - 指示某列不能存储 NULL 值。&lt;/li&gt;&lt;li&gt;unique - 保证某列的每行必须有唯一的值。&lt;/li&gt;&lt;li&gt;primary key - not null 和 unique 的结合。确保某列（或两个列多个列的结合）有唯&amp;gt;一标识，有助于更容易更快速地找到表中的一个特定的记录。&lt;/li&gt;&lt;li&gt;foreign key - 保证一个表中的数据匹配另一个表中的值的参照完整性。&lt;/li&gt;&lt;li&gt;check - 保证列中的值符合指定的条件。&lt;/li&gt;&lt;li&gt;default - 规定没有给列赋值时的默认值&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;接下来，我们依次给大家分享每一种约束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="Constraints" scheme="https://www.xiangjunhong.com/tags/Constraints/"/>
    
  </entry>
  
  <entry>
    <title>SQL-create database</title>
    <link href="https://www.xiangjunhong.com/posts/259f9205.html"/>
    <id>https://www.xiangjunhong.com/posts/259f9205.html</id>
    <published>2020-04-09T02:34:26.410Z</published>
    <updated>2020-04-09T02:35:54.361Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h4 id="Sql-create-database语句"><a href="#Sql-create-database语句" class="headerlink" title="Sql create database语句"></a>Sql create database语句</h4><p>create database 语句用于创建数据库。</p><h4 id="create-database-语法"><a href="#create-database-语法" class="headerlink" title="create database 语法"></a>create database 语法</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname;</span><br></pre></td></tr></table></figure></div><h4 id="create-database-实例"><a href="#create-database-实例" class="headerlink" title="create database  实例"></a>create database 实例</h4><p>下面的 SQL 语句创建一个名为 “my_db” 的数据库：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> dbname my_db;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;Sql-create-database语句&quot;&gt;&lt;a href=&quot;#Sql-create-database语句&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="create database" scheme="https://www.xiangjunhong.com/tags/create-database/"/>
    
  </entry>
  
  <entry>
    <title>Sql语法</title>
    <link href="https://www.xiangjunhong.com/posts/d4b9b850.html"/>
    <id>https://www.xiangjunhong.com/posts/d4b9b850.html</id>
    <published>2020-04-08T15:31:04.603Z</published>
    <updated>2020-04-08T15:32:59.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><p>一个数据库通常包含一个或多个表。每个表有一个名字标识,表包含带有数据的记录（行）。</p><h4 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h4><p>您需要在数据库上执行的大部分工作都由 SQL 语句完成。<br>在本教程中，我们将为您讲解各种不同的 SQL 语句。</p><a id="more"></a><blockquote><p>请记住…<br>SQL 对大小写不敏感：SELECT 与 select 是相同的。所以本教程基本上采用小写完成</p></blockquote><h4 id="SQL-语句后面的分号？"><a href="#SQL-语句后面的分号？" class="headerlink" title="SQL 语句后面的分号？"></a>SQL 语句后面的分号？</h4><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。<br>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。<br>在本教程中，我们将在每条 SQL 语句的末端使用分号。</p><h4 id="一些最重要的-SQL-命令"><a href="#一些最重要的-SQL-命令" class="headerlink" title="一些最重要的 SQL 命令"></a>一些最重要的 SQL 命令</h4><ul><li>select - 从数据库中提取数据</li><li>update - 更新数据库中的数据</li><li>delete- 从数据库中删除数据</li><li>insert into - 向数据库中插入新数据</li><li>create database - 创建新数据库</li><li>alter database - 修改数据库</li><li>create table - 创建新表</li><li>alter table - 变更（改变）数据库表</li><li>drop table - 删除表</li><li>create index - 创建索引（搜索键）</li><li>drop index - 删除索引</li><li>等等。。。。。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h4 id=&quot;数据库表&quot;&gt;&lt;a href=&quot;#数据库表&quot; class=&quot;headerlink&quot; title=&quot;数据库表&quot;&gt;&lt;/a&gt;数据库表&lt;/h4&gt;&lt;p&gt;一个数据库通常包含一个或多个表。每个表有一个名字标识,表包含带有数据的记录（行）。&lt;/p&gt;&lt;h4 id=&quot;SQL-语句&quot;&gt;&lt;a href=&quot;#SQL-语句&quot; class=&quot;headerlink&quot; title=&quot;SQL 语句&quot;&gt;&lt;/a&gt;SQL 语句&lt;/h4&gt;&lt;p&gt;您需要在数据库上执行的大部分工作都由 SQL 语句完成。&lt;br&gt;在本教程中，我们将为您讲解各种不同的 SQL 语句。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL简介</title>
    <link href="https://www.xiangjunhong.com/posts/4d4e6c19.html"/>
    <id>https://www.xiangjunhong.com/posts/4d4e6c19.html</id>
    <published>2020-04-08T14:49:47.967Z</published>
    <updated>2020-04-08T14:52:37.622Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><h3 id="SQL-是什么？"><a href="#SQL-是什么？" class="headerlink" title="SQL 是什么？"></a>SQL 是什么？</h3><ul><li>SQL，指结构化查询语言，全称是 Structured Query Language。</li><li>SQL 让您可以访问和处理数据库。<ul><li>SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。</li></ul></li></ul><blockquote><p>SQL是操作关系数据库的标准语言，是所有关系数据库通用的。SQL只是制定的一个标准，由具体的关系数据库厂商来实现，所以某些关系数据库可能不支持SQL中的少数语句。</p></blockquote><a id="more"></a><h3 id="SQL-能做什么？"><a href="#SQL-能做什么？" class="headerlink" title="SQL 能做什么？"></a>SQL 能做什么？</h3><ul><li>SQL 面向数据库执行查询</li><li>SQL 可从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul><h3 id="在您的网站中使用-SQL"><a href="#在您的网站中使用-SQL" class="headerlink" title="在您的网站中使用 SQL"></a>在您的网站中使用 SQL</h3><p>要创建一个显示数据库中数据的网站，您需要：</p><ol><li>RDBMS 数据库程序（比如 MS Access、SQL Server、MySQL）</li><li>使用服务器端脚本语言，比如 PHP 或 ASP</li><li>使用 SQL 来获取您想要的数据</li><li>使用 HTML / CSS</li></ol><h3 id="使用SQL须知"><a href="#使用SQL须知" class="headerlink" title="使用SQL须知"></a>使用SQL须知</h3><p>虽然SQL作为访问和处理数据库的标准语言，依然存在着多种版本，但是与ANSI标准相兼容，必须以相似的方式支持主要的命令(如：select updata insert where)<br>-除了SQL标准之外，大部分SQL数据库程序都拥有自己的专有扩展。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;SQL-是什么？&quot;&gt;&lt;a href=&quot;#SQL-是什么？&quot; class=&quot;headerlink&quot; title=&quot;SQL 是什么？&quot;&gt;&lt;/a&gt;SQL 是什么？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;SQL，指结构化查询语言，全称是 Structured Query Language。&lt;/li&gt;&lt;li&gt;SQL 让您可以访问和处理数据库。&lt;ul&gt;&lt;li&gt;SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;SQL是操作关系数据库的标准语言，是所有关系数据库通用的。SQL只是制定的一个标准，由具体的关系数据库厂商来实现，所以某些关系数据库可能不支持SQL中的少数语句。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="https://www.xiangjunhong.com/posts/4d712855.html"/>
    <id>https://www.xiangjunhong.com/posts/4d712855.html</id>
    <published>2020-04-08T14:40:49.441Z</published>
    <updated>2020-04-09T14:21:36.693Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>SQL，指结构化查询语言，全称是 Structured Query Language。SQL可以让您可以访问和处理数据库。SQL是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。在本教程中，您将学到如何使用SQL访问和处理数据系统中的数据.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvb081TFJDblE2WjhYcnQ3LmpwZw?x-oss-process=image/format,png#pic_center" alt=" "></p><a id="more"></a><h1 id="SQL-目录"><a href="#SQL-目录" class="headerlink" title="SQL 目录"></a>SQL 目录</h1><ul><li><a href="https://www.xiangjunhong.com/posts/4d4e6c19.html">Sql 简介</a></li><li><a href="https://www.xiangjunhong.com/posts/d4b9b850.html">Sql 语法</a></li><li><a href="https://www.xiangjunhong.com/posts/259f9205.html">Sql create database</a></li><li><a href="https://www.xiangjunhong.com/posts/e4bced2a.html">Sql create table</a></li><li><a href="https://www.xiangjunhong.com/posts/be01953a.html">Sql insert into</a></li><li><a href="https://www.xiangjunhong.com/posts/6d7376dd.html">Sql 约束</a></li><li><a href>Sql update</a></li><li><a href>Sql delete</a></li><li><a href>Sql select</a></li><li><a href>Sql select top</a></li><li><a href>Sql where</a></li><li><a href>Sql and &amp; or</a></li><li><a href>Sql like</a></li><li><a href>Sql 通配符</a></li><li><a href>Sql order by</a></li><li><a href>Sql in</a></li><li><a href>Sql between</a></li><li><a href>Sql 别名</a></li><li><a href>Sql 连接（join</a></li><li><a href>Sql inner join</a></li><li><a href>Sql left join</a></li><li><a href>Sql right join</a></li><li><a href>Sql full join</a></li><li><a href>Sql union</a></li><li><a href>Sql select into</a></li><li><a href>Sql insert into select</a></li><li><a href>Sql not null</a></li><li><a href>Sql unique</a></li><li><a href>Sql check</a></li><li><a href>Sql default</a></li><li><a href>Sql create index</a></li><li><a href>Sql drop</a></li><li><a href>Sql alter</a></li><li><a href>Sql auto increment</a></li><li><a href>Sql 视图</a></li><li><a href>Sql 日期</a></li><li><a href>Sql null值</a></li><li><a href>Sql null函数</a></li><li><a href>Sql 通用数据类型</a></li><li><a href>Sql db数据类型</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;SQL，指结构化查询语言，全称是 Structured Query Language。SQL可以让您可以访问和处理数据库。SQL是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。在本教程中，您将学到如何使用SQL访问和处理数据系统中的数据.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDQvMDkvb081TFJDblE2WjhYcnQ3LmpwZw?x-oss-process=image/format,png#pic_center&quot; alt=&quot; &quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/categories/SQL/"/>
    
    
      <category term="SQL" scheme="https://www.xiangjunhong.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop在Ubuntu的安装</title>
    <link href="https://www.xiangjunhong.com/posts/ae1da46b.html"/>
    <id>https://www.xiangjunhong.com/posts/ae1da46b.html</id>
    <published>2020-03-09T16:00:00.000Z</published>
    <updated>2020-04-13T06:59:06.343Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>由于小编在本学期有一门课程需要学习hadoop,需要在ubuntu的linux系统下搭建Hadoop环境，在这个过程中遇到一些问题，写下这篇博客来记录这个过程，并把分享给大家。</p><h3 id="Hadoop的安装方式"><a href="#Hadoop的安装方式" class="headerlink" title="Hadoop的安装方式"></a>Hadoop的安装方式</h3><ul><li>单机模式:Hadoop默认模式为非分布式模式(本地模式)，无需 进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试</li><li>伪分布式模式:Hadoop可以在单节点上以伪分布式的方式运行， Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也 作为 DataNode，同时，读取的是 HDFS 中的文件</li><li>分布式模式:使用多个节点构成集群环境来运行Hadoop</li></ul><a id="more"></a><h3 id="创建Hadoop用户-可选"><a href="#创建Hadoop用户-可选" class="headerlink" title="创建Hadoop用户(可选)"></a>创建Hadoop用户(可选)</h3><p>如果安装 Ubuntu 的时候不是用的 “hadoop” 用户，那么需要增加一个名为hadoop 的用户，首先按打开终端窗口，输入如下命令创建新用户 :</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd –m hadoop –s /bin/bash</span><br></pre></td></tr></table></figure></div><p>上面这条命令创建了可以登陆的 hadoop 用户，并使用 /bin/bash 作为 shell 接着使用如下命令设置密码，可简单设置为 hadoop，按提示输入两次密码:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd hadoop</span><br></pre></td></tr></table></figure></div><p>可为 hadoop 用户增加管理员权限，方便部署，避免一些对新手来说比较棘 手的权限问题:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser hadoop sudo</span><br></pre></td></tr></table></figure></div><h3 id="SSH登录权限设置"><a href="#SSH登录权限设置" class="headerlink" title="SSH登录权限设置"></a>SSH登录权限设置</h3><h4 id="SSH是什么"><a href="#SSH是什么" class="headerlink" title="SSH是什么?"></a>SSH是什么?</h4><p>SSH 为 Secure Shell 的缩写，是建立在应用层和传输层基础上的安全协议。 SSH 是目前较可靠、专为远程登录会话和其他网络服务提供安全性的协议。 利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是 UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。 SSH是由客 户端和服务端的软件组成，服务端是一个守护进程(daemon)，它在后台运 行并响应来自客户端的连接请求，客户端包含ssh程序以及像scp(远程拷 贝)、slogin(远程登陆)、sftp(安全文件传输)等其他的应用程序.</p><h4 id="配置SSH的原因"><a href="#配置SSH的原因" class="headerlink" title="配置SSH的原因"></a>配置SSH的原因</h4><p>Hadoop名称节点(NameNode)需要启动集群中所有机器的Hadoop守护进程，这个过 程需要通过SSH登录来实现。Hadoop并没有提供SSH输入密码登录的形式，因此，为 了能够顺利登录每台机器，需要将所有机器配置为名称节点可以无密码登录它们。</p><h4 id="配置SSH的无密码登录"><a href="#配置SSH的无密码登录" class="headerlink" title="配置SSH的无密码登录"></a>配置SSH的无密码登录</h4><p>安装openssh-server( 通常Linux系统会默认安装openssh的客户端软件openssh-client)，所以需要自己安装一下服务端。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></div><p>输入 cd .ssh目录下，如果没有.ssh文件 输入 ssh localhost生成。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh/</span><br></pre></td></tr></table></figure></div><p>生成秘钥</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvYXJKQ0x1UjNYb1NkRXhULnBuZw?x-oss-process=image/format,png" alt="  "><br>将Master中生成的密钥加入授权（authorized_keys）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub                     # 查看生成的公钥</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvd05pejNiZ1VhRHNsNHVjLnBuZw?x-oss-process=image/format,png" alt=" "></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys    # 加入授权</span><br><span class="line">chmod 600 authorized_keys    # 修改文件权限，如果不修改文件权限，那么其它用户就能查看该授权</span><br></pre></td></tr></table></figure></div><p>完成后，直接键入“ssh localhost”，能无密码登录即可，<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvTkxjNjJ2ZDdSdEJqbmJ1LnBuZw?x-oss-process=image/format,png" alt=" "><br>键入“exit”退出，到此SSH无密码登录配置就成功了。</p><h3 id="安装Java环境"><a href="#安装Java环境" class="headerlink" title="安装Java环境"></a>安装Java环境</h3><h4 id="scp命令传输Mac的文件到ubuntu"><a href="#scp命令传输Mac的文件到ubuntu" class="headerlink" title="scp命令传输Mac的文件到ubuntu"></a>scp命令传输Mac的文件到ubuntu</h4><p>因为老师给了我们的java的jdk安装包，想着不用去ubuntu重新下载，所以就想到了利用scp命令传输Mac的文件到ubuntu，利用这个命令前提是Ubuntu安装了SSH服务器，在之前我们已经有了这步操作。</p><p>利用ifconfig查看ubuntu服务器的局域网IP地址<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvSHlNQTg5UlZtYkZ1bGpvLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>以下是利用scp命令传输文件的基本格式：<br><strong>1. 本地文件传输到服务器</strong></p><table><thead><tr><th>从本地将文件传输到服务器</th><th>从本地将文件夹传输到服务器</th></tr></thead><tbody><tr><td>scp[本地文件的路径] [服务器用户名]@[服务器地址]:[服务器上存放文件的路径]</td><td>scp -r[本地文件的路径] [服务器用户名]@[服务器地址]:[服务器上存放文件的路径]</td></tr><tr><td>scp /Users/mac/Desktop/test.txt <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root</td><td>scp -r /Users/mac/Desktop/test <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root</td></tr></tbody></table><p><strong>2. 服务器文件传输到本地</strong></p><table><thead><tr><th>将服务器上的文件传输到本地</th><th>将服务器上的文件夹传输到本地</th></tr></thead><tbody><tr><td>scp [服务器用户名]@[服务器地址]:[服务器上存放文件的路径] [本地文件的路径]</td><td>scp -r [服务器用户名]@[服务器地址]:[服务器上存放文件的路径] [本地文件的路径]</td></tr><tr><td>scp <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root/default/test.txt /Users/mac/Desktop</td><td>scp -r <a href="mailto:root@192.168.1.1" target="_blank" rel="noopener">root@192.168.1.1</a>:/root/default/test /Users/mac/Desktop</td></tr></tbody></table><h4 id="mac客户端执行传输命令"><a href="#mac客户端执行传输命令" class="headerlink" title="mac客户端执行传输命令"></a>mac客户端执行传输命令</h4><p>在选择Linux服务器端的储存文件地址时，由于权限原因，默认的是在/tmp有权限，可以先把文件放到tmp文件目录下，然后在进行mv 或者scp到其他目录，即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /Users/xjh/Desktop/jdk-8u221-linux-x64.tar.gz hadoop@172.16.186.128:/tmp</span><br></pre></td></tr></table></figure></div><p>传输速度还是蛮快的，如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkveGJldjJSeWg5YVBHcDZuLnBuZw?x-oss-process=image/format,png" alt=" "><br>在Ubuntu将jdk移动到我们新建的java目录下（没建的新建一个就是），到此传输文件成功，可以开始配置Java环境了。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /tmp/jdk-8u221-linux-x64.tar.gz usr/java</span><br></pre></td></tr></table></figure></div><p>在java目录中，使用sudo tar命令解压jdk文件;<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvZlRWSkVVdEEzYnJNNUhLLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>解压成功后，java目录中会有对应的目录文件存在</p><h4 id="配置Java环境"><a href="#配置Java环境" class="headerlink" title="配置Java环境"></a>配置Java环境</h4><p>使用命令“sudo gedit ~/.bashrc”打开配置文件，在末尾添加以下几行文字，注意自己的jdk版本号。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#set java env</span><br><span class="line">export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_221</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre    </span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib    </span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></div><p>使用命令“source ~/.bashrc”使环境变量生效。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></div><p>配置软连接，软连接相当于windows系统中的快捷键，部分软件可能会从/usr/bin目录下查找Java，因此添加该软连接防止其他软件查找不到的情况。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java  java  /usr/java/jdk1.8.0_221/bin/java 300</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/javac  javac  /usr/java/jdk1.8.0_221/bin/javac 300</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvNUpES3VvWUx3dmtpSVg0LnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="测试java是否安装成功"><a href="#测试java是否安装成功" class="headerlink" title="测试java是否安装成功"></a>测试java是否安装成功</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvUW1HT2d5M3A2RGxBajFuLnBuZw?x-oss-process=image/format,png" alt=" "></p><h3 id="Hadoop单机安装配置"><a href="#Hadoop单机安装配置" class="headerlink" title="Hadoop单机安装配置"></a>Hadoop单机安装配置</h3><p>将我们下载的Hadoop解压到 /usr/local/ 中</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar zxvf tmp/hadoop-3.2.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></div><p>利用cd /usr/local/ 命令切换操作空间，将文件夹名改为hadoop</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv ./hadoop-3.2.1/ ./hadoop</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvRXRDZWpwY1VNNjFLREdhLnBuZw?x-oss-process=image/format,png" alt=" "><br>修改文件权限</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown -R hadoop:hadoop ./hadoop</span><br></pre></td></tr></table></figure></div><p>Hadoop 解压后，在Hadoop目录下的etc/hadoop/hadoop-env.sh文件中添加如下的 Java环境信息。</p><blockquote><p>export JAVA_HOME=/usr/java/jdk1.8.0_221</p></blockquote><p>然后，保存hadoop-env.sh文件，即完成单机模式的Hadoop基本安装。测试Hadoop是否安装成功，如出现如下图所示的版本信息，即可。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvdVhKYkxsRWZwVDVDM095LnBuZw?x-oss-process=image/format,png" alt=" "><br>默认情况下，单机模式的Hadoop以Java进程的方式运行，可依次运行如下命令进行进一步测试。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir input</span><br><span class="line">sudo cp etc/hadoop/*.xml input</span><br></pre></td></tr></table></figure></div><p>执行下列命令，运行MapReduce程序，完成测试计算。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.1.jar grep input output 'dfs[a-z.]+'</span><br></pre></td></tr></table></figure></div><p>执行下列命令，查看计算结果。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat output/*</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvdlJFaUlxbVgzY1FZV0hKLnBuZw?x-oss-process=image/format,png" alt=" "><br>Hadoop目录下，会有input和output两个新建的文件，output中有上述程序 的运算结果，到此Hadoop单机安装配置成功。</p><h3 id="Hadoop伪分布式安装配置"><a href="#Hadoop伪分布式安装配置" class="headerlink" title="Hadoop伪分布式安装配置"></a>Hadoop伪分布式安装配置</h3><blockquote><ul><li>Hadoop可以在单节点上以伪分布式的方式运行，Hadoop进程以分 离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode， 同时，读取的是 HDFS 中的文件</li><li>Hadoop的配置文件位于/usr/local/hadoop/etc/hadoop/中，伪分布式 需要修改2个配置文件 core-site.xml 和 hdfs-site.xml</li><li>Hadoop的配置文件是xml格式，每个配置以声明property的name 和 value 的方式来实现<br>hadoop目录认识</li></ul></blockquote><h4 id="hadoop下的目录"><a href="#hadoop下的目录" class="headerlink" title="hadoop下的目录"></a>hadoop下的目录</h4><p>修改配置文件之前，先看一下hadoop下的目录：</p><div class="note primary"><ul><li>bin：hadoop最基本的管理脚本和使用脚本所在目录，这些脚本是sbin目录下管理脚本的基础实现，用户可以直接使用这些脚本管理和使用hadoop</li><li>etc：配置文件存放的目录，包括core-site.xml,hdfs-site.xml,mapred-site.xml等从hadoop1.x继承而来的配置文件和yarn-site.xml等hadoop2.x新增的配置文件</li><li>include：对外提供的编程库头文件（具体动态库和静态库在lib目录中，这些头文件军事用c++定义的，通常用于c++程序访问hdfs或者编写mapreduce程序）</li><li>Lib：该目录包含了hadoop对外提供的才变成动态库和静态库，与include目录中的头文件结合使用</li><li>libexec：各个服务对应的shell配置文件所在目录，可用于配置日志输出目录、启动参数等信息</li><li>sbin：hadoop管理脚本所在目录，主要包含hdfs和yarn中各类服务的启动、关闭脚本</li><li>share：hadoop各个模块编译后的jar包所在目录。</li></ul></div><h4 id="修改配置文件-core-site-xml"><a href="#修改配置文件-core-site-xml" class="headerlink" title="修改配置文件 core-site.xml"></a>修改配置文件 core-site.xml</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &lt;configuration&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div><ul><li>hadoop.tmp.dir表示存放临时数据的目录，即包括NameNode的数据，也包 括DataNode的数据。该路径任意指定，只要实际存在该文件夹即可</li><li>name为fs.defaultFS的值，表示hdfs路径的逻辑名称</li></ul><h4 id="修改配置文件-hdfs-site-xml"><a href="#修改配置文件-hdfs-site-xml" class="headerlink" title="修改配置文件 hdfs-site.xml"></a>修改配置文件 hdfs-site.xml</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;1&lt;/value&gt; </span><br><span class="line">   &lt;/property&gt; </span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">       &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">       &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;         </span><br><span class="line">       &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div><ul><li>dfs.replication表示副本的数量，伪分布式要设置为1</li><li>dfs.namenode.name.dir表示本地磁盘目录，是存储fsimage文件的地方</li><li>dfs.datanode.data.dir表示本地磁盘目录，HDFS数据存放block的地方</li></ul><table><thead><tr><th>文件名称</th><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>hadoop-env.sh</td><td>Bash脚本</td><td>记录配置Hadoop运行所需的环境变量，以运行 Hadoop</td></tr><tr><td>core-site.xml</td><td>Hadoop配置XML</td><td>Hadoop core的配置项，例如HDFS和MapReduce 常用的I/O设置等</td></tr><tr><td>hdfs-site.xml</td><td>Hadoop配置XML</td><td>Hadoop的守护进程的配置项，包括NameNode、 SecondaryNameNode和DataNode等</td></tr><tr><td>mapred-site.xml</td><td>Hadoop配置XML</td><td>MapReduce守护进程的配置项，包括JobTracker 和TaskTracker</td></tr><tr><td>masters</td><td>纯文本</td><td>运行SecondaryNameNode的机器列表(每行一 个)</td></tr><tr><td>slaves</td><td></td><td>纯文本</td></tr><tr><td>hadoop- metrics.properties</td><td>Java属性</td><td>控制metrics在Hadoop上如何发布的属性</td></tr></tbody></table><p>至此，配置完毕，但是还不能启动，要对hdfs先进行格式化。类似以前的软盘，使用前要先格式化,执行命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure></div><p>看到日志信息：即格式化成功。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMDkvUXlKRGZQN0IxQzgyTXdGLnBuZw?x-oss-process=image/format,png" alt=" "></p><p>在我们name目录(这个目录是我们自己配置的时候指定的)下也会出现映像文件（fsimage），用于将数据持久化 。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvUUVhWndCcjVoV2xNODNzLnBuZw?x-oss-process=image/format,png" alt=" "></p><h4 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h4><p>输入以下命令启动Hadoop：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br></pre></td></tr></table></figure></div><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvZkJuOEgxYkx6RFpnSnJqLnBuZw?x-oss-process=image/format,png" alt=" "><br>安装jps</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk-headless</span><br></pre></td></tr></table></figure></div><p>安装好之后jps检查角色如果有多个角色，就启动成功。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvdHB6VTN1aFgxOVFCMkNELnBuZw?x-oss-process=image/format,png" alt=" "><br>浏览器访问localhost:9870<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDMvMTAvek8xUlVRVHNseHdnS0wzLnBuZw?x-oss-process=image/format,png" alt=" "></p><div class="note success"><p><strong><font color="#5cb85c">前面的路布满荆棘，我有过迟疑，却从未后退。一无所有，就是拼的理由!</font></strong><br>到这里，在Linux系统配置Hadoop的安装和使用教程就到此结束了，经过了很多的踩坑终于完成了这篇教程。如果有哪里不对的地方，希望各路大神在下方评论区留言，我加以改正！我们一起交流，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于小编在本学期有一门课程需要学习hadoop,需要在ubuntu的linux系统下搭建Hadoop环境，在这个过程中遇到一些问题，写下这篇博客来记录这个过程，并把分享给大家。&lt;/p&gt;&lt;h3 id=&quot;Hadoop的安装方式&quot;&gt;&lt;a href=&quot;#Hadoop的安装方式&quot; class=&quot;headerlink&quot; title=&quot;Hadoop的安装方式&quot;&gt;&lt;/a&gt;Hadoop的安装方式&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;单机模式:Hadoop默认模式为非分布式模式(本地模式)，无需 进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试&lt;/li&gt;&lt;li&gt;伪分布式模式:Hadoop可以在单节点上以伪分布式的方式运行， Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也 作为 DataNode，同时，读取的是 HDFS 中的文件&lt;/li&gt;&lt;li&gt;分布式模式:使用多个节点构成集群环境来运行Hadoop&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Ubuntu" scheme="https://www.xiangjunhong.com/categories/Ubuntu/"/>
    
      <category term="Hadoop" scheme="https://www.xiangjunhong.com/categories/Ubuntu/Hadoop/"/>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/tags/Mac/"/>
    
      <category term="Hadoop的安装" scheme="https://www.xiangjunhong.com/tags/Hadoop%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现链式队列</title>
    <link href="https://www.xiangjunhong.com/posts/7fcb11a7.html"/>
    <id>https://www.xiangjunhong.com/posts/7fcb11a7.html</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2020-03-01T11:23:17.480Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>链式队列，简称”链队列”，即使用链表实现的队列存储结构。<br>链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/v14i9JV6RkacuqT.gif"></div>所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。<a id="more"></a><blockquote><p>在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。</p></blockquote><p>由此，我们可以编写出创建链式队列的 C 语言实现代码为:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个头节点</span></span><br><span class="line">    QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="comment">//对头节点进行初始化</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据入队"><a href="#链式队列数据入队" class="headerlink" title="链式队列数据入队"></a>链式队列数据入队</h3><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：</p><ol><li>将该数据元素用节点包裹，例如新节点名称为 elem；</li><li>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；</li><li>最后移动 rear 指针指向该新节点，即 rear=elem；</li></ol><p>由此，新节点就入队成功了。</p><p>例如，在上图的基础上，我们依次将<code>{1,2,3}</code>依次入队，各个数据元素入队的过程如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/I4cxvyYn6gUzVbR.gif"></div>数据元素入链式队列的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、用节点包裹入队元素</span></span><br><span class="line">    QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    enElem-&gt;data=data;</span><br><span class="line">    enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2、新节点与rear节点建立逻辑关系</span></span><br><span class="line">    rear-&gt;next=enElem;</span><br><span class="line">    <span class="comment">//3、rear指向新节点</span></span><br><span class="line">    rear=enElem;</span><br><span class="line">    <span class="comment">//返回新的rear，为后续新元素入队做准备</span></span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据出队"><a href="#链式队列数据出队" class="headerlink" title="链式队列数据出队"></a>链式队列数据出队</h3><p>当链式队列中，有数据元素需要出队时，按照 “先进先出” 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。</p><p>链式队列中队头元素出队，需要做以下 3 步操作：</p><ol><li>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；</li><li>将 p 节点（即要出队的队头节点）从链表中摘除；</li><li>释放节点 p，回收其所占的内存空间；</li></ol><p>例如，在上图2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如下图所示：</p><div align="center"><img src="https://i.loli.net/2020/02/29/wVhEDjNbPHon9lz.gif"></div>链式队列中队头元素出队的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、</span></span><br><span class="line">    QNode * p=top-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">    top-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">        rear=top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。</p></blockquote><h3 id="链式队列的长度"><a href="#链式队列的长度" class="headerlink" title="链式队列的长度"></a>链式队列的长度</h3><p>链式队列的长度，只需要设置一个移动指针，由队列头部移动直至到队列尾部，来达到计数的效果。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列的打印"><a href="#链式队列的打印" class="headerlink" title="链式队列的打印"></a>链式队列的打印</h3><p>链式队列的打印，实际上也就是一个链表的遍历过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过学习链式队列最基本的数据入队和出队操作，我们可以就实际问题，对以上代码做适当的修改。</p><p>前面在学习顺序队列时，由于顺序表的局限性，我们在顺序队列中实现数据入队和出队的基础上，又对实现代码做了改进，令其能够充分利用数组中的空间。链式队列就不需要考虑空间利用的问题，因为链式队列本身就是实时申请空间。因此，这可以算作是链式队列相比顺序队列的一个优势。</p><p>这里给出链式队列入队和出队的完整 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头节点</span></span><br><span class="line">QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="comment">//对头节点进行初始化</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">enElem-&gt;data=data;</span><br><span class="line">enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//使用尾插法向链队列中添加数据元素</span></span><br><span class="line">rear-&gt;next=enElem;</span><br><span class="line">rear=enElem;</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n队列为空"</span>);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line">QNode * p=top-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"出队的元素是：%d \n"</span>,p-&gt;data);</span><br><span class="line">top-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">rear=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">QNode * <span class="built_in">queue</span>,*top,*rear;</span><br><span class="line"><span class="built_in">queue</span>=top=rear=initQueue();<span class="comment">//创建头结点</span></span><br><span class="line"><span class="comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">rear = enQueue(rear, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">printQueue(top);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列的长度为：%d\n"</span>,QueueLength(top));</span><br><span class="line"><span class="comment">//入队完成，所有数据元素开始出队列</span></span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>1 2 3 4 5 6 7 8 9 10<br>队列的长度为：10<br>出队的元素是：1<br>出队的元素是：2</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现链式队列，如今作为大学生的我，也开始受网课的折磨了，在家上网课的感觉比在学校还要累。每天都在上课，写作业，所以一直更新文章也比较少。如果有什么问题的,大家可在下方评论区留言，我加以改正，我们一起交流分享啊！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;链式队列，简称”链队列”，即使用链表实现的队列存储结构。&lt;br&gt;链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:&lt;/p&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.loli.net/2020/02/29/v14i9JV6RkacuqT.gif&quot;&gt;&lt;/div&gt;所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="链式队列" scheme="https://www.xiangjunhong.com/tags/%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>在MAC上如何使用Sql Server</title>
    <link href="https://www.xiangjunhong.com/posts/e35620b3.html"/>
    <id>https://www.xiangjunhong.com/posts/e35620b3.html</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-03-10T10:53:47.010Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>由于小编在这学期要学习数据库原理这门课程，需要用到<code>SQL Server</code>，然而大家都知道<code>SQL Server</code>目前是只能在Windows上使用，我们在mac电脑上如何使用呢？我们可以借助目前比较火的Docker来完成，接下来就给大家介绍如何在docker上部署。</p><h3 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h3 id="MacOS-Docker-安装"><a href="#MacOS-Docker-安装" class="headerlink" title="MacOS Docker 安装"></a>MacOS Docker 安装</h3><h4 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h4><p>macOS 我们可以使用 Homebrew 来安装 Docker。</p><p>Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用<code>Homebrew Cask</code>来进行安装，在终端运行以下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install docker</span></span><br></pre></td></tr></table></figure></div><a id="more"></a><p>安装成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/42716/Docker.dmg</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask 'docker'.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure></div><p>在载入<code>Docker app</code>后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有个小鲸鱼的图标。</p><h4 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvbkRoZnZsc0dkeFp0U1ZLLnBuZw?x-oss-process=image/format,png"></div><br><p>从应用中找到 Docker 图标并点击运行。可能会询问 macOS 的登陆密码，输入即可。<br>点击顶部状态栏中的鲸鱼图标会弹出操作菜单。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTXhrUUtQcElmVjJlcWNtLnBuZw?x-oss-process=image/format,png"></div><br><br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvcW9KeEdSSDFPdk10RkE1LnBuZw?x-oss-process=image/format,png"></div><br>第一次点击图标，可能会看到这个安装成功的界面，点击 "`Got it!`" 可以关闭这个窗口。<br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTG4xRUN6c2Z1NnBaRjdvLnBuZw?x-oss-process=image/format,png"></div><br><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version                                  </span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br></pre></td></tr></table></figure></div><p>之后我们可以通过 docker info 来查看是否配置成功。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></div><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<code>http://hub-mirror.c.163.com</code>。<br>在之前的版本中，Docker客户端有修改镜像的界面，但是更新版本之后，去除了这个界面，那怎么来修改镜像呢？网上都是Linux的教程，并没有Mac的教程，这两个系统之间文件目录有所差别，费了九牛二虎之力找到了<code>daemon.json</code>这个文件。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .docker</span><br></pre></td></tr></table></figure></div><p><code>daemon.json</code>就在这个文件夹，将里面的内容修改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"experimental"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"debug"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>:[<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重启，Docker就会 应用配置的镜像地址。<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/exQAdcC7giYmBv3.png"></div><br>以上图片就是配置成功的样式。 我们也可以通过 docker info 来查看是否配置成功。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line">....</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br><span class="line"> Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"> Product License: Community Engine</span><br></pre></td></tr></table></figure></div><h3 id="拉取并运行-SQL-Server-容器映像"><a href="#拉取并运行-SQL-Server-容器映像" class="headerlink" title="拉取并运行 SQL Server 容器映像"></a>拉取并运行 SQL Server 容器映像</h3><p>拉取并运行SQL Server 容器映像，参考了<a href="https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-linux-2017&pivots=cs1-bash#pullandrun2017" target="_blank" rel="noopener">微软的官方开发文档</a>.</p><p>从 Microsoft 容器注册表中拉取 SQL Server 2017 Linux 容器映像，打开我们的终端，输入命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><p>这里会将sql server for linux docker下载到我们计算机上。</p><h4 id="使用-Docker-运行容器映像"><a href="#使用-Docker-运行容器映像" class="headerlink" title="使用 Docker 运行容器映像"></a>使用 Docker 运行容器映像</h4><p>要使用 Docker 运行容器映像，可以从 Bash Shell (Linux/macOS) 或提升的 PowerShell 命令提示符使用以下命令。(也就是终端)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -e <span class="string">"ACCEPT_EULA=Y"</span> -e <span class="string">"SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -p 1433:1433 --name sql1 \</span><br><span class="line">   -d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><blockquote><p><font color="blue"><strong>备注</strong>:</font><br>密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。 默认情况下，密码的长度必须至少为 8 个字符，并且必须包含以下四种字符中的三种：大写字母、小写字母、十进制数字和符号。 你可以通过执行 docker logs 命令检查错误日志。</p></blockquote><p>下表对前一个 docker run 示例中的参数进行了说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e “ACCEPT_EULA=Y”</td><td>将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必需设置。</td></tr><tr><td>-e “SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;“</td><td>指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 SQL Server 映像的必需设置。</td></tr><tr><td>-p 1433:1433</td><td>将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 在此示例中，SQL Server 侦听容器中的 TCP 1433，并对主机上的端口 1433 公开。</td></tr><tr><td>–name sql1</td><td>为容器指定一个自定义名称，而不是使用随机生成的名称。 如果运行多个容器，则无法重复使用相同的名称。</td></tr><tr><td>-d mcr.microsoft.com/mssql/server:2017-latest</td><td>SQL Server 2017 Linux 容器映像。</td></tr></tbody></table><p>要查看 Docker 容器，请使用 docker ps 命令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure></div><p>应会看到与以下类似的输出：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                                        COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">78c2deca0bd6        mcr.microsoft.com/mssql/server:2017-latest   <span class="string">"/opt/mssql/bin/nonr…"</span>   30 minutes ago      Exited (0) 2 minutes ago                       sql1</span><br></pre></td></tr></table></figure></div><p>如果“状态”列显示“正常运行”，则 SQL Server 将在容器中运行，并侦听“端口”列中指定的端口 。</p><h4 id="更改-SA-密码"><a href="#更改-SA-密码" class="headerlink" title="更改 SA 密码"></a>更改 SA 密码</h4><p>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。 创建 SQL Server 容器后，通过在容器中运行 <code>echo $SA_PASSWORD</code>，可发现指定的 <code>SA_PASSWORD</code> 环境变量。 出于安全考虑，请考虑更改 SA 密码。</p><ol><li>选择 SA 用户要使用的强密码。</li><li>使用 docker exec 运行sqlcmd ，以使用 <code>Transact-SQL</code> 更改密码。 在下面的示例中，将旧密码 <code>&lt;YourStrong!Passw0rd&gt;</code>和新密码 <code>&lt;YourNewStrong!Passw0rd&gt;</code> 替换为你自己的密码值。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">   -S localhost -U SA -P <span class="string">"&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -Q <span class="string">'ALTER LOGIN SA WITH PASSWORD="&lt;YourNewStrong@Passw0rd&gt;"'</span></span><br></pre></td></tr></table></figure></div><h4 id="连接到-SQL-Server"><a href="#连接到-SQL-Server" class="headerlink" title="连接到 SQL Server"></a>连接到 SQL Server</h4><p>下列步骤在容器内部使用<code>SQL Server</code>命令行工具<code>sqlcmd</code> 来连接 <code>SQL Server</code>。</p><ol><li>使用 <code>docker exec -it</code> 命令在运行的容器内部启动交互式 <code>Bash Shell</code>。 在下面的示例中，sql1 是在创建容器时由 –name 参数指定的名称。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 <span class="string">"bash"</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>在容器内部使用 sqlcmd 进行本地连接。 默认情况下，sqlcmd 不在路径之中，因此需要指定完整路径。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P <span class="string">"&lt;YourNewStrong@Passw0rd&gt;"</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>如果成功，应会显示 sqlcmd 命令提示符：1&gt;。</li></ol><h3 id="利用Navicat可视化工具连接Sql-Server"><a href="#利用Navicat可视化工具连接Sql-Server" class="headerlink" title="利用Navicat可视化工具连接Sql Server"></a>利用Navicat可视化工具连接Sql Server</h3><h4 id="下载Navicat"><a href="#下载Navicat" class="headerlink" title="下载Navicat"></a>下载Navicat</h4><p>因为正版只有14天的试用期，没Money的小编只有安排破解版了，在这里把安装包也分享给大家：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ" target="_blank" rel="noopener">https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ</a> 密码:cg5s</p></blockquote><p>下载好后添加Sql Server数据库连接:<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/3zoU1tI74yf9kh2.png"></div><br><div class="note danger"><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>密码一定不要填错，如果密码填错，会出现以下错误：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[42000] [FreeTDS][SQL Server]Login failed for user &apos;SA&apos;. (18456)</span><br><span class="line">[08001] [FreeTDS][SQL Server]Unable to connect to data source (0)</span><br></pre></td></tr></table></figure></div><p>最后，连接成功！<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/D6tHIF3PWXSNwir.png"></div><br><div class="note success"><p><strong><font color="#5cb85c">满怀希望就会所向披靡，因为深海不会因为一杯沸水而加温!</font></strong></p><p>以上就是小编本次给大家分享的在Mac上如何使用SQL Server的详细教程,我们一起讨论！如果哪里有写的不好的地方，还希望大家提出来，在下方评论区留言，我加以修正！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;由于小编在这学期要学习数据库原理这门课程，需要用到&lt;code&gt;SQL Server&lt;/code&gt;，然而大家都知道&lt;code&gt;SQL Server&lt;/code&gt;目前是只能在Windows上使用，我们在mac电脑上如何使用呢？我们可以借助目前比较火的Docker来完成，接下来就给大家介绍如何在docker上部署。&lt;/p&gt;&lt;h3 id=&quot;Docker介绍&quot;&gt;&lt;a href=&quot;#Docker介绍&quot; class=&quot;headerlink&quot; title=&quot;Docker介绍&quot;&gt;&lt;/a&gt;Docker介绍&lt;/h3&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;&lt;p&gt;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p&gt;&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;&lt;h3 id=&quot;MacOS-Docker-安装&quot;&gt;&lt;a href=&quot;#MacOS-Docker-安装&quot; class=&quot;headerlink&quot; title=&quot;MacOS Docker 安装&quot;&gt;&lt;/a&gt;MacOS Docker 安装&lt;/h3&gt;&lt;h4 id=&quot;使用-Homebrew-安装&quot;&gt;&lt;a href=&quot;#使用-Homebrew-安装&quot; class=&quot;headerlink&quot; title=&quot;使用 Homebrew 安装&quot;&gt;&lt;/a&gt;使用 Homebrew 安装&lt;/h4&gt;&lt;p&gt;macOS 我们可以使用 Homebrew 来安装 Docker。&lt;/p&gt;&lt;p&gt;Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用&lt;code&gt;Homebrew Cask&lt;/code&gt;来进行安装，在终端运行以下命令：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; brew cask install docker&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/categories/Mac/"/>
    
      <category term="Sql Server" scheme="https://www.xiangjunhong.com/categories/Mac/Sql-Server/"/>
    
    
      <category term="Mac" scheme="https://www.xiangjunhong.com/tags/Mac/"/>
    
      <category term="Sql Server" scheme="https://www.xiangjunhong.com/tags/Sql-Server/"/>
    
  </entry>
  
  <entry>
    <title>队列的含义以及C语言实现顺序队列</title>
    <link href="https://www.xiangjunhong.com/posts/2d063bc3.html"/>
    <id>https://www.xiangjunhong.com/posts/2d063bc3.html</id>
    <published>2020-02-15T16:00:00.000Z</published>
    <updated>2020-03-10T10:54:20.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p><font color="green">队列</font>，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。</p><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>与栈结构不同的是，<font color="red">队列</font>的两端都”开口”，要求数据只能从一端进，从另一端出，如下图示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwb0hscS5naWY" alt></p><blockquote><p>通常，称进数据的一端为 “<font color="green">队尾</font>“，出数据的一端为 “<font color="green">队头</font>“，数据元素进队列的过程称为 “<font color="green">入队</font>“，出队列的过程称为 “<font color="green">出队</font>“。</p></blockquote><a id="more"></a><p>不仅如此，<font color="red">队列中数据的进出要遵循 “先进先出” 的原则</font>，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p><blockquote><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><p>因此，数据从表的一端进，从另一端出，且遵循 “先进先出” 原则的线性存储结构就是队列。</p><h3 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h3><p><font color="blue">顺序队列</font>，即采用顺序表模拟实现的队列结构。</p><blockquote><p>我们知道，队列具有以下两个特点：<br>数据从队列的一端进，另一端出；<br>数据的入队和出队遵循”先进先出”的原则；</p></blockquote><p>因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。</p><h4 id="顺序队列简单实现"><a href="#顺序队列简单实现" class="headerlink" title="顺序队列简单实现"></a>顺序队列简单实现</h4><p>由于顺序队列的底层使用的是<font color="blue">数组</font>，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVGEzbi5naWY" alt><br>由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p><p>在上图的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p><p>例如，在上图的基础上将<code>{1,2,3,4}</code>用顺序队列存储的实现操作如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVFdnMS5naWY" alt><br>在上图基础上，顺序队列中数据出队列的实现过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVE9nSS5naWY" alt><br>因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    a[rear]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (front!=rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队元素：%d\n"</span>,a[front]);</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a, rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序输出结果：</p><blockquote><p>出队元素：1<br>出队元素：2<br>出队元素：3<br>出队元素：4</p></blockquote><p><strong><em>此方法存在的问题</em></strong></p><p>先来分析上面两张图。第一张图的b是有数据进队成功的示意图，而第二张图的b 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；</li></ul><p>为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。</p><h4 id="顺序队列另一种实现方法"><a href="#顺序队列另一种实现方法" class="headerlink" title="顺序队列另一种实现方法"></a>顺序队列另一种实现方法</h4><p>既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。</p><p>为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如下图所示：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwN0JSQS5naWY" alt><br>上图只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 5<span class="comment">//表示顺序表申请的空间大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满</span></span><br><span class="line">    <span class="keyword">if</span> ((rear+<span class="number">1</span>)%max==front) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空间已满"</span>);</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line">    a[rear%max]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(front==rear%max) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[front]);</span><br><span class="line">    <span class="comment">//front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]</span></span><br><span class="line">    front=(front+<span class="number">1</span>)%max;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[max];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果：</p><blockquote><p>1 2 3 4 5 6</p></blockquote><p>使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：</p><ul><li>当队列为空时，队列的头指针等于队列的尾指针；</li><li>当数组满员时，队列的头指针等于队列的尾指针；</li></ul><p>顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。</p><div class="note success"><p><strong><font color="#5cb85c">不去追逐，永远不会拥有。不往前走，永远原地停留!</font></strong><br>利用本篇文章的机会，给大家介绍了C队列以及简单的实现了顺序队列，并作出了一些优化。相关的代码依旧是托管在了github上面，需要的小伙伴请自取。如果有写的不好的地方，大家在评论区留言，我加以改正，和大家一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;green&quot;&gt;队列&lt;/font&gt;，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。&lt;/p&gt;&lt;h3 id=&quot;什么是队列&quot;&gt;&lt;a href=&quot;#什么是队列&quot; class=&quot;headerlink&quot; title=&quot;什么是队列&quot;&gt;&lt;/a&gt;什么是队列&lt;/h3&gt;&lt;p&gt;与栈结构不同的是，&lt;font color=&quot;red&quot;&gt;队列&lt;/font&gt;的两端都”开口”，要求数据只能从一端进，从另一端出，如下图示：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwb0hscS5naWY&quot; alt&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;通常，称进数据的一端为 “&lt;font color=&quot;green&quot;&gt;队尾&lt;/font&gt;“，出数据的一端为 “&lt;font color=&quot;green&quot;&gt;队头&lt;/font&gt;“，数据元素进队列的过程称为 “&lt;font color=&quot;green&quot;&gt;入队&lt;/font&gt;“，出队列的过程称为 “&lt;font color=&quot;green&quot;&gt;出队&lt;/font&gt;“。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="顺序队列" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现链式栈</title>
    <link href="https://www.xiangjunhong.com/posts/6163d4b5.html"/>
    <id>https://www.xiangjunhong.com/posts/6163d4b5.html</id>
    <published>2020-02-11T16:00:00.000Z</published>
    <updated>2020-02-12T05:40:35.532Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>在之前写的C语言实现链式栈篇博文中，我已经给大家大概介绍了关于<a href="https://www.xiangjunhong.com/posts/9b621d6f.html">链式栈</a>的意义以及相关操作,我会在下面给大家分享百度百科对链式栈的定义，以及给大家介绍利用C++实现链式栈的基本操作。</p><h3 id="百度百科链式栈"><a href="#百度百科链式栈" class="headerlink" title="百度百科链式栈"></a>百度百科链式栈</h3><blockquote><p>链式栈是一种数据存储结构，可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。</p></blockquote><p><font color="blue">栈</font>是只能在某一端插入和删除的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底（push），最后的数据在栈顶（top），需要读数据的时候从栈顶开始弹出数据（top）最后一个数据被第一个读出来。链式栈中的元素以Node的形式存储，节点Node中存有此节点存于栈中的元素以及指向下个节点的指针。链式栈的数据成员只用保存指向栈顶节点的指针 *top_node。</p><a id="more"></a><p><font color="blue">顺序栈</font>的实现在于使用了数组这个基本数据结构，数组中的元素在内存中的存储位置是连续的，且编译器要求我们在编译期就要确定数组的大小，这样<font color="DarkViolet">对内存的使用效率并不高，一来无法避免因数组空间用光而引起的溢出问题，二在系统将内存分配给数组后，则这些内存对于其他任务就不可用</font>；而对于链栈而言，使用了<font color="gree">链表来实现栈，链表中的元素存储在不连续的地址，由于是动态申请内存，所以我们可以以非常小的内存空间开始，另外当某个项不使用时也可将内存返还给系统</font>。</p><h3 id="C-实现链式栈"><a href="#C-实现链式栈" class="headerlink" title="C++实现链式栈"></a>C++实现链式栈</h3><p>利用C++语言实现了数据结构的链式栈，主要完成了以下操作：</p><table><thead><tr><th>链式栈的</th><th>基本操作</th></tr></thead><tbody><tr><td>元素进栈</td><td>元素出栈</td></tr><tr><td>返回栈顶元素</td><td>判断栈是否为空</td></tr><tr><td>打印栈的元素</td><td></td></tr></tbody></table><h4 id="链式栈的结点"><a href="#链式栈的结点" class="headerlink" title="链式栈的结点"></a>链式栈的结点</h4><p>链式栈的结点其实跟链式结构的顺序结构差不多类似，包含两部分，一是储存数据的<font color="red">数据域</font>，二是储存下一结点地址的<font color="red">指针域</font>,因此以结构体封装的结点如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainStackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T data;<span class="comment">//链式栈储存结点的数据</span></span><br><span class="line">chainStackNode&lt;T&gt; *next;<span class="comment">//链式栈指向下一结点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="链式栈的基本操作"><a href="#链式栈的基本操作" class="headerlink" title="链式栈的基本操作"></a>链式栈的基本操作</h4><p>在写这次链式栈的时候，我在所有的函数实现前都加上了<font color="red">inline</font>,在这里给大家解释一下。inline是<font color="green">C++关键字</font>，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为<font color="green">内联函数</font>，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造函数，就是实现成员的初始化操作，当然在这里实现链式栈的初始化就只需要创建一个头指针，并初始化头指针的各个成员。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:chainStack()</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="keyword">new</span> chainStackNode&lt;T&gt;;<span class="comment">//创建一个新的结点</span></span><br><span class="line">top-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将top的next指针指向空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素进栈"><a href="#元素进栈" class="headerlink" title="元素进栈"></a>元素进栈</h5><p>链式栈的进栈操作，顾名思义就是一个新的元素进入栈，当然首先要创建一个新的结点，然后就是将这个新的结点插入到栈顶，只需要调整来两个指针操作。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Push(T newData)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *newNode = <span class="keyword">new</span> chainStackNode&lt;T&gt;;</span><br><span class="line"><span class="keyword">if</span>(!newNode)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"分配内存失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;data = newData;<span class="comment">//修改指针，添加元素</span></span><br><span class="line">newNode-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h5><p>元素出栈，就跟线性表的删除元素类似，不过只能删除顶部结点，这个栈的特性是不可以违背的，调整指针删除结点之后不要忘了释放删除的结点的内存。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Pop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *temporaryNode;<span class="comment">//创建一个临时指针指向删除结点</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"该栈为空！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temporaryNode = top-&gt;next;</span><br><span class="line">x = temporaryNode-&gt;data;<span class="comment">//以引用返回</span></span><br><span class="line">top-&gt;next = temporaryNode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temporaryNode;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="返回栈顶元素"><a href="#返回栈顶元素" class="headerlink" title="返回栈顶元素"></a>返回栈顶元素</h5><p>返回栈顶的元素，判断栈是否为空，如果为空自然没有元素可以返回，否则就返回top指向的下一个结点的数据即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:getTop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = top-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h5><p>有了top指针，就只需要判断top指针的下一结点是否为空即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(top-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//top指针的下一结点是否为空，以此来判断是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印栈的元素"><a href="#打印栈的元素" class="headerlink" title="打印栈的元素"></a>打印栈的元素</h5><p>打印栈的元素，就是一个遍历的过程，定义一个指针，输出结点数据，调整指针位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">void</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:printChainStackData()</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *pMove;</span><br><span class="line">pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]-&gt;"</span>;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">冰冻三尺，非一日之寒!</font></strong><br>到这里，利用C++语言实现链式栈的介绍就已经结束了，如果有哪里写的不好的地方，还希望大家给我提出了，我加以修正，完整的代码包括测试代码我已经push到了github<a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E9%93%BE%E5%BC%8F%E6%A0%88" target="_blank" rel="noopener">C++实现链式栈</a>，如果大家有什么想法的，欢迎在下方评论区留言，我们一起讨论，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在之前写的C语言实现链式栈篇博文中，我已经给大家大概介绍了关于&lt;a href=&quot;https://www.xiangjunhong.com/posts/9b621d6f.html&quot;&gt;链式栈&lt;/a&gt;的意义以及相关操作,我会在下面给大家分享百度百科对链式栈的定义，以及给大家介绍利用C++实现链式栈的基本操作。&lt;/p&gt;&lt;h3 id=&quot;百度百科链式栈&quot;&gt;&lt;a href=&quot;#百度百科链式栈&quot; class=&quot;headerlink&quot; title=&quot;百度百科链式栈&quot;&gt;&lt;/a&gt;百度百科链式栈&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;链式栈是一种数据存储结构，可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;栈&lt;/font&gt;是只能在某一端插入和删除的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底（push），最后的数据在栈顶（top），需要读数据的时候从栈顶开始弹出数据（top）最后一个数据被第一个读出来。链式栈中的元素以Node的形式存储，节点Node中存有此节点存于栈中的元素以及指向下个节点的指针。链式栈的数据成员只用保存指向栈顶节点的指针 *top_node。&lt;/p&gt;
    
    </summary>
    
    
      <category term="链式栈" scheme="https://www.xiangjunhong.com/categories/%E9%93%BE%E5%BC%8F%E6%A0%88/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%93%BE%E5%BC%8F%E6%A0%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现双向循环链表</title>
    <link href="https://www.xiangjunhong.com/posts/a530f7f0.html"/>
    <id>https://www.xiangjunhong.com/posts/a530f7f0.html</id>
    <published>2020-02-06T16:00:00.000Z</published>
    <updated>2020-02-07T13:02:37.492Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>本次博文是关于利用C++模板的方式实现的双向循环链表以及双向循环链表的基本操作，在之前的博文C++语言实现双向链表中，以下是链接<a href="https://www.xiangjunhong.com/posts/5394fce7.html" class="LinkCard">C++语言实现双向循环链表</a>已经给大家分析了双向循环链表的结构，并以图示的方式给大家解释了双向循环链表的基本操作。本篇文章利用C++实现了双向循环链表的基本操作，其中包括：</p><table><thead><tr><th>双向循环链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>双向循环链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>在之前的C++语言实现双向链表时已经给大家解释了封装的结点的特点，不需要作太大的改变，我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向循环链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedList</span>;</span><span class="comment">//声明一下双向循环链表，以免定义友元时报错</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向循环链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleCircularLinkedListNode(T _data,doubleCircularLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleCircularLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>本次实现的操作跟双向链表实现的操作基本一样，实现了双向循环链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向循环链表的长度，打印双向循环链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>实现双向循环链表的头部插入结点，之前的双向链表因为在头部和尾部的指针都是指向<font color="green">NULL</font>的,所以需要分情况来处理，然而双向循环链表没有元素时这两个指针都是指向自身的，因此并不需要分情况处理，都需要修改四个指针。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，调整四个指针即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* lastNode = headNode;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都需要调整四个指针，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历双向循环链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next; <span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMoveprior = headNode;<span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;data != item)</span><br><span class="line">&#123;</span><br><span class="line">pMoveprior = pMove;</span><br><span class="line">pMove = pMoveprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(pMove == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pMove = headNode;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向循环链表的长度"><a href="#双向循环链表的长度" class="headerlink" title="双向循环链表的长度"></a>双向循环链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向循环链表"><a href="#打印双向循环链表" class="headerlink" title="打印双向循环链表"></a>打印双向循环链表</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove !=headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">与其用泪水悔恨今天，不如用汗水拼搏明天!</font></strong><br>以上就是我简要的给大家分享的C++实现双向循环链表，因为实现了双向链表，所以基本上实现思路差不多，唯一的不同就是在<font color="red">循环</font>一词不同，这一不同就是头结点的前驱指针和尾结点的后驱指针指向不同，要是还是不太清楚的可以去那篇博客看看。本次的完整代码已经全部上传到github! <a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">(C++实现双向循环链表)</a>,如果有什么问题，欢迎在下方评论区留言啊，我们一起讨论啊，一起进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本次博文是关于利用C++模板的方式实现的双向循环链表以及双向循环链表的基本操作，在之前的博文C++语言实现双向链表中，以下是链接&lt;a href=&quot;https://www.xiangjunhong.com/posts/5394fce7.html&quot; class=&quot;LinkCard&quot;&gt;C++语言实现双向循环链表&lt;/a&gt;已经给大家分析了双向循环链表的结构，并以图示的方式给大家解释了双向循环链表的基本操作。本篇文章利用C++实现了双向循环链表的基本操作，其中包括：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;双向循环链表&lt;/th&gt;&lt;th&gt;实现的功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;头部插入结点建立链表&lt;/td&gt;&lt;td&gt;尾部插入结点建立链表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实现指定位置插入结点&lt;/td&gt;&lt;td&gt;查找给定数值是否存在&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除指定位置的结点&lt;/td&gt;&lt;td&gt;修改指定位置的结点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;双向链表的长度&lt;/td&gt;&lt;td&gt;打印双向链表&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/"/>
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现双向链表</title>
    <link href="https://www.xiangjunhong.com/posts/5394fce7.html"/>
    <id>https://www.xiangjunhong.com/posts/5394fce7.html</id>
    <published>2020-02-01T16:00:00.000Z</published>
    <updated>2020-02-03T10:13:36.208Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>这篇文章是关于利用C++模板的方式实现的双向链表以及双向链表的基本操作，在之前的博文中，以下是链接<br><a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">C++语言实现双向链表</a><br>已经给大家分析了双向链表的结构，并以图示的方式给大家解释了双向链表的基本操作。本篇文章利用C++实现了双向链表的基本操作，其中包括：</p><blockquote><p><strong>双向链表的基本操作C++语言实现</strong></p></blockquote><table><thead><tr><th>双向链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>因为双向链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>因此，首先我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleLinkedListNode(T _data,doubleLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>实现了双向链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向链表的长度，打印双向链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>带头结点实现的双向链表，实现头部插入结点可分为两种情况，一种是只有一个头结点的时候，只需要使<font color="blue">head</font>和<font color="blue">newNode</font>的两个指针关联上即可，另外的两个指针依旧是<font color="blue">NULL</font>状态。另一种情况便是有结点的情况，这个时候跟在中间结点插入相似，需要调整四个指针,首先是让<font color="blue">newNode</font>与后继结点关联，最后让<font color="blue">newNode</font>与<font color="blue">head</font>结点关联。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分两种情况，head的next是否为NULL,然后处理四个指针</span></span><br><span class="line"><span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，双向链表因为两端的指针都是指向<font color="blue">NULL</font>的，所以在尾部插入也只需要调整两个指针就ok.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* lastNode = head;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到调整指针</span></span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都逃不过调整四个指针，但是首先依旧是让新结点和后继结点建立上相关性，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> doubleLinkedList&lt;T&gt;::insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>)<span class="comment">//链表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pMove)<span class="comment">//遍历链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;data == item)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pMove = head;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回，具体的用法在测试函数中写到了的，不会的可以作为参考。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向链表的长度"><a href="#双向链表的长度" class="headerlink" title="双向链表的长度"></a>双向链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向链表"><a href="#打印双向链表" class="headerlink" title="打印双向链表"></a>打印双向链表</h4><p>打印双向链表，从第二个结点开始遍历链表，因为第一个为头结点是不含数据的，打印的过程也就是一个遍历的过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次博文与大家分享的利用C++语言实现双向链表，在用C语言写了之后，感觉写起来就比较轻松，唯一不同的就是要利用类来进行封装。完整的代码，以及测试代码我已经Push到Github,喜欢的小伙伴欢迎Star! <a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">C++语言实现双向链表Github地址</a>，我们一起讨论，如果有写的不好的地方还请多多担待，也欢迎大家在评论区留言，我加以改正，共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;这篇文章是关于利用C++模板的方式实现的双向链表以及双向链表的基本操作，在之前的博文中，以下是链接&lt;br&gt;&lt;a href=&quot;https://www.xiangjunhong.com/posts/beb5106a.html&quot; class=&quot;LinkCard&quot;&gt;C++语言实现双向链表&lt;/a&gt;&lt;br&gt;已经给大家分析了双向链表的结构，并以图示的方式给大家解释了双向链表的基本操作。本篇文章利用C++实现了双向链表的基本操作，其中包括：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;双向链表的基本操作C++语言实现&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;双向链表&lt;/th&gt;&lt;th&gt;实现的功能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;头部插入结点建立链表&lt;/td&gt;&lt;td&gt;尾部插入结点建立链表&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;实现指定位置插入结点&lt;/td&gt;&lt;td&gt;查找给定数值是否存在&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除指定位置的结点&lt;/td&gt;&lt;td&gt;修改指定位置的结点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;双向链表的长度&lt;/td&gt;&lt;td&gt;打印双向链表&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/"/>
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现链式栈</title>
    <link href="https://www.xiangjunhong.com/posts/9b621d6f.html"/>
    <id>https://www.xiangjunhong.com/posts/9b621d6f.html</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-02-01T12:07:57.055Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p><font color="red">链栈</font>，即用<font color="blue">链表</font>实现栈存储结构。链栈的实现思路同顺序栈类似，<font color="blue">顺序栈</font>是将数<font color="blue">顺序表（数组）</font>的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如下下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHYzNEQS5naWY" alt="在这里插入图片描述"></p><blockquote><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p></blockquote><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”<font color="green">入栈</font>“操作时，需要将数据从链表的头部插入；</li><li>在实现数据”<font color="green">出栈</font>“操作时，需要删除链表头部的首元节点；<a id="more"></a></li></ul><p><font color="red">因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</font></p><h3 id="链栈元素入栈"><a href="#链栈元素入栈" class="headerlink" title="链栈元素入栈"></a>链栈元素入栈</h3><p>例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHY3FQSy5naWY" alt><br>C语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="comment">//stack为当前的链栈，a表示入栈元素</span></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储新元素的节点</span></span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    <span class="comment">//新节点与头节点建立逻辑关系</span></span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//更新头指针的指向</span></span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链栈元素出栈"><a href="#链栈元素出栈" class="headerlink" title="链栈元素出栈"></a>链栈元素出栈</h3><p>例如，上图所示的链栈中，若要将元素 3 出栈，根据”先进后出”的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHZ2Jlcy5naWY" alt="在这里插入图片描述"><br>因此，实现栈顶元素出链栈的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶元素出链栈的实现函数</span></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="comment">//声明一个新指针指向栈顶节点</span></span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">//更新头指针</span></span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"新栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中通过使用 if 判断语句，避免了用户执行”栈已空却还要数据出栈”错误操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"弹栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>弹栈元素：4 栈顶元素：3<br>弹栈元素：3 栈顶元素：2<br>弹栈元素：2 栈顶元素：1<br>弹栈元素：1 栈已空<br>栈内没有元素</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次分享给大家的利用C语言实现链栈，二月的第一篇博文，希望得到大家的支持鸭！如果有什么写的不好，不对的地方，还望各路大神指出来，欢迎在下方评论区留言！我们一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;链栈&lt;/font&gt;，即用&lt;font color=&quot;blue&quot;&gt;链表&lt;/font&gt;实现栈存储结构。链栈的实现思路同顺序栈类似，&lt;font color=&quot;blue&quot;&gt;顺序栈&lt;/font&gt;是将数&lt;font color=&quot;blue&quot;&gt;顺序表（数组）&lt;/font&gt;的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如下下图所示：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHYzNEQS5naWY&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;链表的头部作为栈顶，意味着：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;在实现数据”&lt;font color=&quot;green&quot;&gt;入栈&lt;/font&gt;“操作时，需要将数据从链表的头部插入；&lt;/li&gt;&lt;li&gt;在实现数据”&lt;font color=&quot;green&quot;&gt;出栈&lt;/font&gt;“操作时，需要删除链表头部的首元节点；
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="链式栈" scheme="https://www.xiangjunhong.com/tags/%E9%93%BE%E5%BC%8F%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现双向循环链表</title>
    <link href="https://www.xiangjunhong.com/posts/538e5180.html"/>
    <id>https://www.xiangjunhong.com/posts/538e5180.html</id>
    <published>2020-01-30T16:00:00.000Z</published>
    <updated>2020-01-31T08:45:49.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>在之前的文章中，我写过一篇关于C语言实现双向链表的博文，下面是链接：<a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">双向链表</a><br>介绍了双向链表的实现过程以及双向链表的优势，接下来我首先给大家介绍一下<font color="red">循环链表</font>和<font color="red">双向链表</font>的区别，之后再给大家介绍<font color="blue">双向循环</font>链表的具体实现。</p><h3 id="循环链表和双向链表的区别"><a href="#循环链表和双向链表的区别" class="headerlink" title="循环链表和双向链表的区别"></a>循环链表和双向链表的区别</h3><p>1、最后一个结点指针指向不同</p><p>在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是像双向链表那样置为NULL。此种情况还用于在最后一个结点后插入一个新的结点。</p><p>2、判断链域值不同</p><p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非像单链表那样判断链域值是否为NULL。</p><a id="more"></a><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQVBiUS5wbmc?x-oss-process=image/format,png" alt><br>3、访问方式：</p><p>循环链表：可以从任何一个结点开始，顺序向后访问到达任意结点</p><p>双向链表：可以从任何结点开始任意向前向后双向访问</p><p>4、操作：</p><p>循环链表：只能在当前结点后插入和删除</p><p>双链表：可以在当前结点前面或者后面插入，可以删除前趋和后继（包括结点自己）</p><p>5、存储：循环链表存储密度大于双链表</p><h3 id="双向循环链表的具体实现"><a href="#双向循环链表的具体实现" class="headerlink" title="双向循环链表的具体实现"></a>双向循环链表的具体实现</h3><p>双向循环链表：最后一个节点的next指向head，而head的prior指向最后一个节点，构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQTJNOC5tZC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>由上图可以看出，双向循环链表的结点结构与双向链表的结构是一样的，都是含有三项：<font color="blue">前驱指针prior</font>,<font color="blue">数据项data</font>,<font color="blue">后驱指针next</font>,因此双向循环链表结点结构用C语言实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">prior</span>;</span><span class="comment">//结点的前驱指针</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//结点的数据项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//结点的后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h5 id="双向循环链表的初始化"><a href="#双向循环链表的初始化" class="headerlink" title="双向循环链表的初始化"></a>双向循环链表的初始化</h5><p>只有一个头节点head，就让prior和next都指向自己，形成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkNETy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>初始化头结点代码实现：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头结点，数据差异化当作表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">headNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//循环链表，所以初始化头指针，尾指针都是指向自身的，data数据域不做初始化</span></span><br><span class="line">headNode-&gt;prior = headNode;<span class="comment">//头结点指向自身</span></span><br><span class="line">headNode-&gt;next = headNode;<span class="comment">//尾结点指向自身</span></span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="创建一个新的结点"><a href="#创建一个新的结点" class="headerlink" title="创建一个新的结点"></a>创建一个新的结点</h5><p>与单向循环链表类似的，只是多了一个prior要考虑，为插入做准备。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkRJSi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//动态申请内存malloc+free c语言的特点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//创建结点过程相当于初始化过程</span></span><br><span class="line">newNode-&gt;data = data;<span class="comment">//传入data数值初始化数据域</span></span><br><span class="line">newNode-&gt;prior = <span class="literal">NULL</span>;<span class="comment">//初始化头结点为null</span></span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化尾结点为null</span></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="插入新的元素"><a href="#插入新的元素" class="headerlink" title="插入新的元素"></a>插入新的元素</h5><p>与单向循环链表类似，只是多了一个prior要考虑。这里就不需判断插入的位置是不是在最后了，已经构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzZXVXUi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h6 id="表头插入实现"><a href="#表头插入实现" class="headerlink" title="表头插入实现"></a>表头插入实现</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeByHead</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点，调用创建新结点的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//修改四个指针变量</span></span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h6 id="表尾插入实现"><a href="#表尾插入实现" class="headerlink" title="表尾插入实现"></a>表尾插入实现</h6><blockquote><p>在表尾插入，比表头插入更容易出错，大家多加注意！首先找到尾部最后一个元素，然后再进行插入操作</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeBynext</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//首先找到最后一个结点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">lastNode</span> = <span class="title">headNode</span>;</span></span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h5><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可，<font color="red">删除之后不要忘了释放空间哟！</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzbU1OUS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpecifyLocationToDelete</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在指定位置，无法删除！\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNodeprior-&gt;next = posNode-&gt;next;</span><br><span class="line">posNode-&gt;next-&gt;prior=posNodeprior;</span><br><span class="line"><span class="built_in">free</span>(posNode);<span class="comment">//删除之后，释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素"><a href="#查找指定元素" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchSpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该元素存在！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素-1"><a href="#查找指定元素-1" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifySpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData,<span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNode-&gt;data = elem;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a>打印数据</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct doubleCircularLinkedList* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line"><span class="comment">//也可以通过前指针进行打印，只需将next改为prior即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">pMove</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考博文：<br><a href="https://blog.csdn.net/baweiyaoji/article/details/76071053" target="_blank" rel="noopener">https://blog.csdn.net/baweiyaoji/article/details/76071053</a></p><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现双向循环链表，完整的代码已经push到了githubs上面（<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/doubleCircularLinkedList.c" target="_blank" rel="noopener">传送门</a>），欢迎各位clone，如果觉得还不错的话，欢迎Star! 如果有哪里有问题，欢迎大家在下面评论区留言，我及时修改更正，坚持就是胜利！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在之前的文章中，我写过一篇关于C语言实现双向链表的博文，下面是链接：&lt;a href=&quot;https://www.xiangjunhong.com/posts/beb5106a.html&quot; class=&quot;LinkCard&quot;&gt;双向链表&lt;/a&gt;&lt;br&gt;介绍了双向链表的实现过程以及双向链表的优势，接下来我首先给大家介绍一下&lt;font color=&quot;red&quot;&gt;循环链表&lt;/font&gt;和&lt;font color=&quot;red&quot;&gt;双向链表&lt;/font&gt;的区别，之后再给大家介绍&lt;font color=&quot;blue&quot;&gt;双向循环&lt;/font&gt;链表的具体实现。&lt;/p&gt;&lt;h3 id=&quot;循环链表和双向链表的区别&quot;&gt;&lt;a href=&quot;#循环链表和双向链表的区别&quot; class=&quot;headerlink&quot; title=&quot;循环链表和双向链表的区别&quot;&gt;&lt;/a&gt;循环链表和双向链表的区别&lt;/h3&gt;&lt;p&gt;1、最后一个结点指针指向不同&lt;/p&gt;&lt;p&gt;在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是像双向链表那样置为NULL。此种情况还用于在最后一个结点后插入一个新的结点。&lt;/p&gt;&lt;p&gt;2、判断链域值不同&lt;/p&gt;&lt;p&gt;在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非像单链表那样判断链域值是否为NULL。&lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/C%E8%AF%AD%E8%A8%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="双向循环链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现顺序栈</title>
    <link href="https://www.xiangjunhong.com/posts/278598dc.html"/>
    <id>https://www.xiangjunhong.com/posts/278598dc.html</id>
    <published>2020-01-28T16:00:00.000Z</published>
    <updated>2020-01-31T14:23:32.892Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>C语言实现顺序栈以及栈的特点</p><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h3><p>同<font color="blue">顺序表</font>和<font color="blue">链表</font>一样，栈也是<font color="red">用来存储逻辑关系为 “一对一” 数据的线性存储结构</font>，如下图所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNSERkcy5naWY" alt="图一"><br>从上图我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：</p><blockquote><ol><li>栈只能从表的一端存取数据，另一端是封闭的，如上图所示；</li><li>在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。拿上图的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。</li></ol></blockquote><a id="more"></a><p>因此，我们可以给栈下一个定义，即<font color="red">栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构</font>。</p><p>通常，栈的开口端被称为<font color="green">栈顶</font>；相应地，封口端被称为<font color="green">栈底</font>。因此，栈顶元素指的就是距离栈顶最近的元素，拿下图来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，下图中的栈底元素为元素。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNSExRTy5naWY" alt="1MHLQO.gif"></p><h3 id="进栈和出栈"><a href="#进栈和出栈" class="headerlink" title="进栈和出栈"></a>进栈和出栈</h3><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：</p><ul><li>向栈中添加元素，此过程被称为”<font color="green">进栈</font>“（<font color="green">入栈</font>或<font color="green">压栈</font>）；</li><li>从栈中提取出指定元素，此过程被称为”<font color="green">出栈</font>“（或<font color="green">弹栈</font>）；</li></ul><h3 id="栈的具体实现"><a href="#栈的具体实现" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h3><p>栈是一种 “特殊” 的线性存储结构，因此栈的具体实现有以下两种方式：</p><ol><li><font color="blue">顺序栈</font>：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；</li><li><font color="blue">链栈</font>：采用链式存储结构实现栈结构；<blockquote><p>两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。</p></blockquote></li></ol><h3 id="顺序栈基本操作"><a href="#顺序栈基本操作" class="headerlink" title="顺序栈基本操作"></a>顺序栈基本操作</h3><p><font color="blue">顺序栈</font>，即用<font color="blue">顺序表</font>实现栈存储结构。通过前面介绍我们知道，使用栈存储结构操作数据元素必须遵守 “先进后出” 的原则，下面就 “如何使用顺序表模拟栈以及实现对栈中数据的基本操作（出栈和入栈）” 给大家做一些介绍。</p><p>如果你仔细观察顺序表（底层实现是<font color="blue">数组</font>）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。</p><p>例如，我们先使用顺序表（a 数组）存储<code>{1,2,3,4}</code>，存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNYlJodC5naWY" alt="在这里插入图片描述"><br>同样，使用栈存储结构存储<code>{1,2,3,4}</code>，其存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNYm9uZy5naWY" alt="在这里插入图片描述"><br>通过上面两张图对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。</p><blockquote><p>从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。</p></blockquote><p>了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有”<font color="red">先进后出</font>“的要求，如果想将图中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。</p><p>这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是”空栈”。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。</p><h4 id="顺序栈元素”入栈”"><a href="#顺序栈元素”入栈”" class="headerlink" title="顺序栈元素”入栈”"></a>顺序栈元素”入栈”</h4><p>比如，还是模拟栈存储<code>{1,2,3,4}</code> 的过程。最初，栈是”空栈”，即数组是空的，top 值为初始值 -1，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcVZnSy5naWY" alt="在这里插入图片描述"><br>首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcVpqTy5naWY" alt="在这里插入图片描述"><br>采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcU1FZC5naWY" alt="在这里插入图片描述"></p><p>因此，C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素elem进栈，a为数组，top值为当前栈的栈顶位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> top,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。</p><h4 id="顺序栈元素”出栈”"><a href="#顺序栈元素”出栈”" class="headerlink" title="顺序栈元素”出栈”"></a>顺序栈元素”出栈”</h4><p>其实，top 变量的设置对模拟数据的 “入栈” 操作没有实际的帮助，它是为实现数据的 “出栈” 操作做准备的。</p><p>比如，将上图中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如下图a) 和 下图b) 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcXdVcy5naWY" alt="在这里插入图片描述"></p><blockquote><p>注意，上图数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。</p></blockquote><p>元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空栈"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"弹栈元素：%d\n"</span>,a[top]);</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中的 if 语句是为了防止用户做 “栈中已无数据却还要数据出栈” 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。</p><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的利用C语言简单的实现顺序栈以及向大家介绍了栈的特点，完整的代码已经上传到github,<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E9%A1%BA%E5%BA%8F%E6%A0%88/SequenceStack.c" target="_blank" rel="noopener">C语言实现顺序栈</a> 欢迎大家Star ! 有什么写的不好的地方希望大家在评论区留言，我加以改正，我们一起交流，一起进步啊！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;C语言实现顺序栈以及栈的特点&lt;/p&gt;&lt;h3 id=&quot;什么是栈？&quot;&gt;&lt;a href=&quot;#什么是栈？&quot; class=&quot;headerlink&quot; title=&quot;什么是栈？&quot;&gt;&lt;/a&gt;什么是栈？&lt;/h3&gt;&lt;p&gt;同&lt;font color=&quot;blue&quot;&gt;顺序表&lt;/font&gt;和&lt;font color=&quot;blue&quot;&gt;链表&lt;/font&gt;一样，栈也是&lt;font color=&quot;red&quot;&gt;用来存储逻辑关系为 “一对一” 数据的线性存储结构&lt;/font&gt;，如下图所示。&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNSERkcy5naWY&quot; alt=&quot;图一&quot;&gt;&lt;br&gt;从上图我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;栈只能从表的一端存取数据，另一端是封闭的，如上图所示；&lt;/li&gt;&lt;li&gt;在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。拿上图的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="顺序栈" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E6%A0%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C语言" scheme="https://www.xiangjunhong.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++语言实现顺序栈</title>
    <link href="https://www.xiangjunhong.com/posts/dd845106.html"/>
    <id>https://www.xiangjunhong.com/posts/dd845106.html</id>
    <published>2020-01-27T16:00:00.000Z</published>
    <updated>2020-01-31T14:23:49.372Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>在写C语言实现<font color="red">顺序栈</font>的时候,我已经向大家介绍了<font color="blue">栈的特点</font>以及介绍了栈的相关操作，并利用C语言实现了相关算法。在这里小编就不在继续给大家介绍了，需要温习的可以看看之前的文章,下面是链接<a href="https://www.xiangjunhong.com/posts/278598dc.html" class="LinkCard">C语言实现顺序栈</a>在这篇博客我就给大家分享一下利用C++模板类来实现顺序栈的相关操作，主要实现了以下功能：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzE4VmZZOS5wbmc?x-oss-process=image/format,png" alt="18VfY9.png"></p><a id="more"></a><h3 id="私有成员的封装"><a href="#私有成员的封装" class="headerlink" title="私有成员的封装"></a>私有成员的封装</h3><p>根据顺序栈的特点，封装了<font color="green">elements</font>这样的数组存放栈中元素，<font color="green">top</font>代表栈顶指针，<font color="green">maxSize</font>代表栈的最大容纳量，其中还封装了一个<font color="green">overflowProcess()</font>函数来对栈的溢出进行处理。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">T* elements;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span> maxSize;<span class="comment">//栈的最大容纳元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflowProcess</span><span class="params">()</span></span>;<span class="comment">//栈的溢出处理操作</span></span><br></pre></td></tr></table></figure></div><p>overflowProcess()函数的实现如下<br>在栈满的情况下，按照最大容纳量的2倍来扩展栈的容纳量，重新分配空间赋值给elements数组。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:overflowProcess()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;maxSize = <span class="keyword">int</span> (<span class="number">2</span>*<span class="keyword">this</span>-&gt;maxSize);</span><br><span class="line">T * temp = <span class="keyword">new</span> T [<span class="keyword">this</span>-&gt;maxSize];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="keyword">this</span>-&gt;top ; i++)&#123;</span><br><span class="line">temp[i] = <span class="keyword">this</span>-&gt;elements[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []elements;       <span class="comment">//释放原来的空间</span></span><br><span class="line"><span class="keyword">this</span> -&gt;elements = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="公有函数的封装"><a href="#公有函数的封装" class="headerlink" title="公有函数的封装"></a>公有函数的封装</h3><p>栈的操作自然少不了<code>进栈，出栈，判空，判满</code>等相关操作，下面分别给大家进行介绍：</p><h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>默认最大容纳量为10，可自行进行调整。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">Stack</span>&lt;T&gt;:</span>:Stack()   </span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">this</span> -&gt;maxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;elements = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt;maxSize];</span><br><span class="line"><span class="keyword">if</span>(elements==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h4><p>根据自身传递size大小来分配储存空间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Stack(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt;maxSize = size;</span><br><span class="line"><span class="keyword">this</span> -&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;elements = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt;maxSize];</span><br><span class="line"><span class="keyword">if</span>(elements==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“入栈”操作"><a href="#顺序栈的“入栈”操作" class="headerlink" title="顺序栈的“入栈”操作"></a>顺序栈的“入栈”操作</h4><p>入栈操作前，首先要判断栈是否溢出，如果栈isFull(),则进行溢出处理，否则将其插入到栈顶。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Push(<span class="keyword">const</span> T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isFull()==<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"The stack is full , so need to enlarge 2x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">overflowProcess();<span class="comment">//溢出处理，调整空间大小</span></span><br><span class="line">elements[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">elements[++top]=x;<span class="comment">//将x入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“出栈”操作"><a href="#顺序栈的“出栈”操作" class="headerlink" title="顺序栈的“出栈”操作"></a>顺序栈的“出栈”操作</h4><p>栈顶元素出栈，如果栈为空返回false;若栈不为空，栈顶元素出栈，top指针减一就OK啦。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Pop(T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">x=getTopelements();</span><br><span class="line"></span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“判满”"><a href="#顺序栈的“判满”" class="headerlink" title="顺序栈的“判满”"></a>顺序栈的“判满”</h4><p>判断栈是否满，只需要将top指针与最大容纳量进行比较就行，如果满返回true,未满返回false</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isFull()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()&lt;<span class="keyword">this</span>-&gt;getMaxsize()<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“判空”"><a href="#顺序栈的“判空”" class="headerlink" title="顺序栈的“判空”"></a>顺序栈的“判空”</h4><p>判断栈是否空，直接判断top指针，如果满返回true,未满返回false</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印顺序栈的元素"><a href="#打印顺序栈的元素" class="headerlink" title="打印顺序栈的元素"></a>打印顺序栈的元素</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:print()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"This Stack is empty!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"栈的元素为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getTop();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[i]&lt;&lt;<span class="string">"]&lt;-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[getTop()]&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>到这里C++实现顺序栈的文章就结束了，相对而言还是挺简单的，本来打算把顺序栈的应用也写在这篇文章一起的，工作量实在挺大，也害怕大家接受不了，所以我就后面在更新喽。完整的代码我已经上传到github(<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E9%A1%BA%E5%BA%8F%E6%A0%88" target="_blank" rel="noopener">C++实现顺序栈</a>)，欢迎Star!我们一起讨论，我也是一个学生，如果有写的不好的地方，还忘各路大神提出来，在下面评论区留言，我加以改正！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在写C语言实现&lt;font color=&quot;red&quot;&gt;顺序栈&lt;/font&gt;的时候,我已经向大家介绍了&lt;font color=&quot;blue&quot;&gt;栈的特点&lt;/font&gt;以及介绍了栈的相关操作，并利用C语言实现了相关算法。在这里小编就不在继续给大家介绍了，需要温习的可以看看之前的文章,下面是链接&lt;a href=&quot;https://www.xiangjunhong.com/posts/278598dc.html&quot; class=&quot;LinkCard&quot;&gt;C语言实现顺序栈&lt;/a&gt;在这篇博客我就给大家分享一下利用C++模板类来实现顺序栈的相关操作，主要实现了以下功能：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzE4VmZZOS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;18VfY9.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="顺序栈" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E9%A1%BA%E5%BA%8F%E6%A0%88/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C++语言" scheme="https://www.xiangjunhong.com/tags/C-%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Parallels Desktop的安装</title>
    <link href="https://www.xiangjunhong.com/posts/201e1121.html"/>
    <id>https://www.xiangjunhong.com/posts/201e1121.html</id>
    <published>2020-01-21T16:00:00.000Z</published>
    <updated>2020-01-23T01:44:42.477Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p><font color="green">Parallels Desktop</font>是一款运行在 Mac 电脑上的极为优秀的<font color="red">虚拟机</font>软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。</p><h3 id="Parallels-Desktop的安装"><a href="#Parallels-Desktop的安装" class="headerlink" title="Parallels Desktop的安装"></a>Parallels Desktop的安装</h3><p>小编考虑到大家可能找不到资源，就特地把自己的分享给大家：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA</a><br>密码:2k25</p></blockquote><a id="more"></a><p>下载之后先不要急着安装，现在安装肯定会报软件解析错误等相关的警告，这是因为没有设置<strong>mac安装软件允许任何来源</strong></p><p>解决允许任何来源问题办法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 -&gt; 选择“任何来源”</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.  显示&quot;任何来源&quot;选项在控制台中执行：</span><br><span class="line">    sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div><p>mac安装软件允许任何来源之后就可以安装软件了，打开dmg文件后双击箭头所指，按照提示一步步点击确定就可以<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzIyLzFBY3VDRC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h3 id="Windows10-镜像文件"><a href="#Windows10-镜像文件" class="headerlink" title="Windows10 镜像文件"></a>Windows10 镜像文件</h3><p>根据自己电脑的情况选择32bit或者64bit的Win10文件，Mac运行内存有16G可以选择64bit，小编当然是选择了32bit,对Windows不想给它分多了,毕竟Mac=亲生的 Windows=捡来的</p><p>仍然把我的镜像文件分享给大家，给大家省点麻烦</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1ODUGILKYN_FeVgOPPkX44A" target="_blank" rel="noopener">https://pan.baidu.com/s/1ODUGILKYN_FeVgOPPkX44A</a><br>密码:ow8b</p></blockquote><p>镜像文件下载好好之后就选择相应的镜像文件，之后安装助手就会帮你搞定了，你只需要静静地等待，安装成功后如下图：</p><p>是不是看起来就很nice!</p><p><img src="https://s2.ax1x.com/2020/01/22/1A25Ax.png" alt="1A25Ax.png"></p><h3 id="开启体验之旅"><a href="#开启体验之旅" class="headerlink" title="开启体验之旅"></a>开启体验之旅</h3><p>理论上Parallels Desktop可以让你在苹果的Mac OS系统上同时运行多个 Windows系统，你可以随意在它们之间进行切换，并且能够运行各个平台上几乎所有的应用程序和游戏，让原本枯燥的Mac变得可玩性极高。</p><p>另外，PD支持各种 USB 硬件设备，并且支持 USB-C / USB 3.0。用户可以随意将 USB 设备分配给 Mac 或分配到虚拟机系统里去。例如手机刷ROM、连接老式打印机、使用U盘加密狗等等。</p><p>性能方面，Parallels Desktop支持 DirectX 11，如果你之前对比过其它虚拟机软件，相信你肯定有所感触，PD 在 3D 游戏和图形性能方面比 VMware Fusion、VirtualBox等更加流畅和出色，而且新版本对《守望先锋》、XBox One 游戏串流等进行了专项优化，来保证游戏的流畅性。<br>另外，Parallels Desktop还提供了“一键自动优化”功能，你可以根据不同的用途（效能应用程序、设计或开发，游戏）对 PD 虚拟机进行调整和优化，让它更加适合你的工作场景(我选择的设计开发方面)</p><p><strong><em>实用的特色功能</em></strong><br>值得一提的是，在Parallels Desktop中还提供了不少非常实用的特色功能，如果能够熟练掌握并加以应用，可以大大提升用户的工作效率。</p><ol><li><p><strong>“融合模式”无缝衔接Windows和Mac OS</strong><br>最新版PD支持“融合模式”，你可以将Windows 的软件任意拖拽到Mac当中进行使用，例如PPT、Word等等Office软件。PD13对界面进行了优化，将两个系统常用的菜单按钮和界面融为一体，此时你完全感觉不出自己是在Mac中使用Windows，你也可以以全屏模式来运行 Windows。不用时只需轻松点击右上角的退出融合模式进行关闭。</p></li><li><p><strong>让时光倒流的“快照功能”</strong><br>你可能喜欢尝试各种新软件，或者喜欢折腾系统、应用软件。然而一些不完善的测试版软件、非官方渠道下载的小程序等等都有可能对系统留下垃圾或造成不良影响。这时候，Parallels Desktop的快照功能就派上用场了。</p></li></ol><p>你可以随时给当前的虚拟机系统“拍”上一张快照，它能够帮你备份当前系统的整个状态 ，例如未关闭的word文档等等。然后你就可以任意折腾你的系统了，等想恢复系统原来的状态时，只需要在菜单里选择“管理快照”，找到刚才拍过的快照进行恢复就可以了。</p><ol start="3"><li><strong>懒人福利“Parallel Toolbox 工具箱”</strong><br>新版PD新增了一款独立应用——Parallel Toolbox（一键式实用工具集），可以帮助用户方便地截图、录制屏幕、制作 GIF等，非常方便实用，可以让你的工作效率大幅提升。</li></ol><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次分享给大家的我认为还不错的Mac虚拟机，我后面还会继续分享其他的玩转Mac技巧，如果觉得这篇文章对你有的话就给我一个小小的赞吧，你的鼓励就是我前进的动力。后面我继续加油，坚持就是胜利！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;font color=&quot;green&quot;&gt;Parallels Desktop&lt;/font&gt;是一款运行在 Mac 电脑上的极为优秀的&lt;font color=&quot;red&quot;&gt;虚拟机&lt;/font&gt;软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。&lt;/p&gt;&lt;h3 id=&quot;Parallels-Desktop的安装&quot;&gt;&lt;a href=&quot;#Parallels-Desktop的安装&quot; class=&quot;headerlink&quot; title=&quot;Parallels Desktop的安装&quot;&gt;&lt;/a&gt;Parallels Desktop的安装&lt;/h3&gt;&lt;p&gt;小编考虑到大家可能找不到资源，就特地把自己的分享给大家：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;链接:&lt;a href=&quot;https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA&lt;/a&gt;&lt;br&gt;密码:2k25&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="玩转Mac" scheme="https://www.xiangjunhong.com/categories/%E7%8E%A9%E8%BD%ACMac/"/>
    
    
      <category term="Parallels Desktop" scheme="https://www.xiangjunhong.com/tags/Parallels-Desktop/"/>
    
  </entry>
  
  <entry>
    <title>C语言实现双向链表</title>
    <link href="https://www.xiangjunhong.com/posts/beb5106a.html"/>
    <id>https://www.xiangjunhong.com/posts/beb5106a.html</id>
    <published>2020-01-16T16:00:00.000Z</published>
    <updated>2020-01-22T12:06:39.640Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --><p>目前我们所学到的<font color="blue">链表</font>，无论是动态链表还是<font color="blue">静态链表</font>，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为<font color="green">单向链表</font>（或<font color="green">单链表</font>）。</p><p>虽然使用单链表能 100% 解决逻辑关系为 “一对一” 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 “从前往后” 找，而 “从后往前” 找并不是它的强项。</p><p>为了能够高效率解决类似的问题，本篇文章我们一起来讨论<font color="green">双向链表</font>（简称<font color="green">双链表</font>）。<br>从名字上理解双向链表，即链表是 “双向” 的,如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4S3dqSi5naWY" alt="图一"></p><a id="more"></a><blockquote><p>双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要。</p></blockquote><p>从上图中可以看到，双向链表中各节点包含以下 3 部分信息（如下图 所示）：</p><ul><li><font color="green">指针域 </font>：用于指向当前节点的直接前驱节点；</li><li><font color="green">数据域 </font>：用于存储数据元素。</li><li><font color="green">指针域</font>：用于指向当前节点的直接后继节点；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4SzdVUC5naWY" alt="在这里插入图片描述"><br>因此，双链表的节点结构用 C 语言实现为:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span><span class="comment">//指向直接前趋</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span><span class="comment">//指向直接后继</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h4><p>同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。</p><p>需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：</p><blockquote><ol><li>将新节点的 prior 指针指向直接前驱节点；</li><li>将直接前驱节点的 next 指针指向新节点；</li></ol></blockquote><p>这里给出创建双向链表的 C 语言实现代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line">head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建链表第一个结点（首元结点）</span></span><br><span class="line">head-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;data=<span class="number">1</span>;</span><br><span class="line">Node * <span class="built_in">list</span>=head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="comment">//创建并初始化一个新结点</span></span><br><span class="line">Node * body=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">body-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;data=i;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">list</span>-&gt;next=body;<span class="comment">//直接前趋结点的next指针指向新结点</span></span><br><span class="line">body-&gt;prior=<span class="built_in">list</span>;<span class="comment">//新结点指向直接前趋结点</span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//双链表的创建函数</span></span><br><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>;</span><br><span class="line"><span class="comment">//输出双链表的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Node * head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个头指针</span></span><br><span class="line">Node * head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//调用链表创建函数</span></span><br><span class="line">head=initNode(head);</span><br><span class="line"><span class="comment">//输出创建好的链表</span></span><br><span class="line">display(head);</span><br><span class="line"><span class="comment">//显示双链表的优点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表中第 4 个节点的直接前驱是：%d"</span>,head-&gt;next-&gt;next-&gt;next-&gt;prior-&gt;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个首元节点，链表的头指针为head</span></span><br><span class="line">head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">//对节点进行初始化</span></span><br><span class="line">head-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;data=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点</span></span><br><span class="line">Node * <span class="built_in">list</span>=head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//创建新的节点并初始化</span></span><br><span class="line">Node * body=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">body-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;data=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点与链表最后一个节点建立关系</span></span><br><span class="line"><span class="built_in">list</span>-&gt;next=body;</span><br><span class="line">body-&gt;prior=<span class="built_in">list</span>;</span><br><span class="line"><span class="comment">//list永远指向链表中最后一个节点</span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回新创建的链表</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line">Node * temp=head;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="comment">//如果该节点无后继节点，说明此节点是链表的最后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp-&gt;data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d &lt;-&gt; "</span>,temp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果：</p><blockquote><p>1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5<br>链表中第 4 个节点的直接前驱是：3</p></blockquote><h4 id="双向链表基本操作"><a href="#双向链表基本操作" class="headerlink" title="双向链表基本操作"></a>双向链表基本操作</h4><p>下面继续讨论有关双向链表的一些基本操作，即如何在双向链表中添加、删除、查找或更改数据元素。</p><p>创建好的双向链表如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UVF3bi5naWY" alt="在这里插入图片描述"></p><h5 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h5><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：<br><strong>添加至表头</strong><br>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</p><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：</p><blockquote><ol><li>temp-&gt;next=head; head-&gt;prior=temp;</li><li>将 head 移至 temp，重新指向新的表头；</li></ol></blockquote><p>例如，将新元素 7 添加至双链表的表头，则实现过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UXNmSy5naWY" alt="在这里插入图片描述"><br><strong>添加至表的中间位置</strong><br>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如下图所示：</p><blockquote><ol><li>新节点先与其直接后继节点建立双层逻辑关系；</li><li>新节点的直接前驱节点与之建立双层逻辑关系；</li></ol></blockquote><p><a href="https://imgchr.com/i/lxQWmd" target="_blank" rel="noopener"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UVdtZC5naWY" alt="lxQWmd.gif"></a><br><strong>添加至表尾</strong><br>与添加到表头是一个道理，实现过程如下（如下图所示）：</p><blockquote><ol><li>找到双链表中最后一个节点；</li><li>让新节点与最后一个节点进行双层逻辑关系；</li></ol></blockquote><p><a href="https://imgchr.com/i/lxQ2OH" target="_blank" rel="noopener"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UTJPSC5naWY" alt="lxQ2OH.gif"></a></p><p>因此，双向链表添加数据的 C 语言代码，参考代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">insertNode</span><span class="params">(Node * head,<span class="keyword">int</span> data,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line"><span class="comment">//新建数据域为data的结点</span></span><br><span class="line">Node * temp=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">temp-&gt;data=data;</span><br><span class="line">temp-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//插入到链表头，要特殊考虑</span></span><br><span class="line"><span class="keyword">if</span> (add==<span class="number">1</span>) &#123;</span><br><span class="line">temp-&gt;next=head;</span><br><span class="line">head-&gt;prior=temp;</span><br><span class="line">head=temp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node * body=head;</span><br><span class="line"><span class="comment">//找到要插入位置的前一个结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add<span class="number">-1</span>; i++) &#123;</span><br><span class="line">body=body-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断条件为真，说明插入位置为链表尾</span></span><br><span class="line"><span class="keyword">if</span> (body-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;prior=body;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">body-&gt;next-&gt;prior=temp;</span><br><span class="line">temp-&gt;next=body-&gt;next;</span><br><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;prior=body;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h5><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。<br>例如，删除上面图中的元素2，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4bGlYNC5naWY" alt="lxliX4.gif">]<br>双向链表删除节点的 C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点的函数，data为要删除结点的数据域的值</span></span><br><span class="line"><span class="function">Node * <span class="title">delNode</span><span class="params">(Node * head,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">Node * temp=head;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="comment">//判断当前结点中数据域和data是否相等，若相等，摘除该结点</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data==data) &#123;</span><br><span class="line">temp-&gt;prior-&gt;next=temp-&gt;next;</span><br><span class="line">temp-&gt;next-&gt;prior=temp-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表中无该数据元素"</span>);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表查找节点"><a href="#双向链表查找节点" class="headerlink" title="双向链表查找节点"></a>双向链表查找节点</h5><p>通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><p>C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head为原双链表，elem表示被查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectElem</span><span class="params">(Node * head,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line"><span class="comment">//新建一个指针t，初始化为头指针 head</span></span><br><span class="line">Node * t=head;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (t) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data==elem) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表更改节点"><a href="#双向链表更改节点" class="headerlink" title="双向链表更改节点"></a>双向链表更改节点</h5><p>更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><p>实现此操作的 C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值</span></span><br><span class="line"><span class="function">Node *<span class="title">amendElem</span><span class="params">(Node * p,<span class="keyword">int</span> add,<span class="keyword">int</span> newElem)</span></span>&#123;</span><br><span class="line">Node * temp=p;</span><br><span class="line"><span class="comment">//遍历到被删除结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add; i++) &#123;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data=newElem;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong><br>基本上写到这里这篇关于C语言实现双向链表的文章就结束了，总的实现代码已经push到github，喜欢的小伙伴欢迎Star！<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">传送门</a>，小编如果有什么写的不好的地方，欢迎大家留言提出来，多多指教，我们一起进步！明天继续更新C++语言实现双向链表，坚持就是胜利！加油！</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 16 2020 12:46:35 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;目前我们所学到的&lt;font color=&quot;blue&quot;&gt;链表&lt;/font&gt;，无论是动态链表还是&lt;font color=&quot;blue&quot;&gt;静态链表&lt;/font&gt;，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为&lt;font color=&quot;green&quot;&gt;单向链表&lt;/font&gt;（或&lt;font color=&quot;green&quot;&gt;单链表&lt;/font&gt;）。&lt;/p&gt;&lt;p&gt;虽然使用单链表能 100% 解决逻辑关系为 “一对一” 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 “从前往后” 找，而 “从后往前” 找并不是它的强项。&lt;/p&gt;&lt;p&gt;为了能够高效率解决类似的问题，本篇文章我们一起来讨论&lt;font color=&quot;green&quot;&gt;双向链表&lt;/font&gt;（简称&lt;font color=&quot;green&quot;&gt;双链表&lt;/font&gt;）。&lt;br&gt;从名字上理解双向链表，即链表是 “双向” 的,如下图所示：&lt;br&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4S3dqSi5naWY&quot; alt=&quot;图一&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/"/>
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/C/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="双向链表" scheme="https://www.xiangjunhong.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
      <category term="C" scheme="https://www.xiangjunhong.com/tags/C/"/>
    
  </entry>
  
</feed>
