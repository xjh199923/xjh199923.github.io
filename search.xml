<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言实现链式队列</title>
      <link href="/posts/7fcb11a7.html"/>
      <url>/posts/7fcb11a7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>链式队列，简称”链队列”，即使用链表实现的队列存储结构。<br>链式队列的实现思想同顺序队列类似，只需创建两个指针（命名为 top 和 rear）分别指向链表中队列的队头元素和队尾元素，如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/v14i9JV6RkacuqT.gif"></div>所示为链式队列的初始状态，此时队列中没有存储任何数据元素，因此 top 和 rear 指针都同时指向头节点。<a id="more"></a><blockquote><p>在创建链式队列时，强烈建议初学者创建一个带有头节点的链表，这样实现链式队列会更简单。</p></blockquote><p>由此，我们可以编写出创建链式队列的 C 语言实现代码为:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个头节点</span></span><br><span class="line">    QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="comment">//对头节点进行初始化</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据入队"><a href="#链式队列数据入队" class="headerlink" title="链式队列数据入队"></a>链式队列数据入队</h3><p>链队队列中，当有新的数据元素入队，只需进行以下 3 步操作：</p><ol><li>将该数据元素用节点包裹，例如新节点名称为 elem；</li><li>与 rear 指针指向的节点建立逻辑关系，即执行 rear-&gt;next=elem；</li><li>最后移动 rear 指针指向该新节点，即 rear=elem；</li></ol><p>由此，新节点就入队成功了。</p><p>例如，在上图的基础上，我们依次将<code>{1,2,3}</code>依次入队，各个数据元素入队的过程如下图所示:</p><div align="center"><img src="https://i.loli.net/2020/02/29/I4cxvyYn6gUzVbR.gif"></div>数据元素入链式队列的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、用节点包裹入队元素</span></span><br><span class="line">    QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    enElem-&gt;data=data;</span><br><span class="line">    enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//2、新节点与rear节点建立逻辑关系</span></span><br><span class="line">    rear-&gt;next=enElem;</span><br><span class="line">    <span class="comment">//3、rear指向新节点</span></span><br><span class="line">    rear=enElem;</span><br><span class="line">    <span class="comment">//返回新的rear，为后续新元素入队做准备</span></span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列数据出队"><a href="#链式队列数据出队" class="headerlink" title="链式队列数据出队"></a>链式队列数据出队</h3><p>当链式队列中，有数据元素需要出队时，按照 “先进先出” 的原则，只需将存储该数据的节点以及它之前入队的元素节点按照原则依次出队即可。这里，我们先学习如何将队头元素出队。</p><p>链式队列中队头元素出队，需要做以下 3 步操作：</p><ol><li>通过 top 指针直接找到队头节点，创建一个新指针 p 指向此即将出队的节点；</li><li>将 p 节点（即要出队的队头节点）从链表中摘除；</li><li>释放节点 p，回收其所占的内存空间；</li></ol><p>例如，在上图2b) 的基础上，我们将元素 1 和 2 出队，则操作过程如下图所示：</p><div align="center"><img src="https://i.loli.net/2020/02/29/wVhEDjNbPHon9lz.gif"></div>链式队列中队头元素出队的 C 语言实现代码为：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、</span></span><br><span class="line">    QNode * p=top-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,p-&gt;data);</span><br><span class="line">    top-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">        rear=top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>注意，将队头元素做出队操作时，需提前判断队列中是否还有元素，如果没有，要提示用户无法做出队操作，保证程序的健壮性。</p></blockquote><h3 id="链式队列的长度"><a href="#链式队列的长度" class="headerlink" title="链式队列的长度"></a>链式队列的长度</h3><p>链式队列的长度，只需要设置一个移动指针，由队列头部移动直至到队列尾部，来达到计数的效果。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链式队列的打印"><a href="#链式队列的打印" class="headerlink" title="链式队列的打印"></a>链式队列的打印</h3><p>链式队列的打印，实际上也就是一个链表的遍历过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过学习链式队列最基本的数据入队和出队操作，我们可以就实际问题，对以上代码做适当的修改。</p><p>前面在学习顺序队列时，由于顺序表的局限性，我们在顺序队列中实现数据入队和出队的基础上，又对实现代码做了改进，令其能够充分利用数组中的空间。链式队列就不需要考虑空间利用的问题，因为链式队列本身就是实时申请空间。因此，这可以算作是链式队列相比顺序队列的一个优势。</p><p>这里给出链式队列入队和出队的完整 C 语言代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br><span class="line"><span class="comment">//创建链式队列的函数</span></span><br><span class="line"><span class="function">QNode * <span class="title">initQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头节点</span></span><br><span class="line">QNode * <span class="built_in">queue</span>=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="comment">//对头节点进行初始化</span></span><br><span class="line"><span class="built_in">queue</span>-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">enQueue</span><span class="params">(QNode * rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">QNode * enElem=(QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">enElem-&gt;data=data;</span><br><span class="line">enElem-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//使用尾插法向链队列中添加数据元素</span></span><br><span class="line">rear-&gt;next=enElem;</span><br><span class="line">rear=enElem;</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode* <span class="title">DeQueue</span><span class="params">(QNode * top,QNode * rear)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (top-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n队列为空"</span>);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line">QNode * p=top-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"出队的元素是：%d \n"</span>,p-&gt;data);</span><br><span class="line">top-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (rear==p) &#123;</span><br><span class="line">rear=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">QNode * pMove = top;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//头指针指向空，长度为0</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove-&gt;next !=<span class="literal">NULL</span>) &#123;<span class="comment">//头指针不为空，移动指针计算长度</span></span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printQueue</span><span class="params">(QNode * top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QNode * pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该队列为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pMove!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">QNode * <span class="built_in">queue</span>,*top,*rear;</span><br><span class="line"><span class="built_in">queue</span>=top=rear=initQueue();<span class="comment">//创建头结点</span></span><br><span class="line"><span class="comment">//向链队列中添加结点，使用尾插法添加的同时，队尾指针需要指向链表的最后一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">rear = enQueue(rear, i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">printQueue(top);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"队列的长度为：%d\n"</span>,QueueLength(top));</span><br><span class="line"><span class="comment">//入队完成，所有数据元素开始出队列</span></span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line">rear=DeQueue(top, rear);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>1 2 3 4 5 6 7 8 9 10<br>队列的长度为：10<br>出队的元素是：1<br>出队的元素是：2</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现链式队列，如今作为大学生的我，也开始受网课的折磨了，在家上网课的感觉比在学校还要累。每天都在上课，写作业，所以一直更新文章也比较少。如果有什么问题的,大家可在下方评论区留言，我加以改正，我们一起交流分享啊！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 链式队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在MAC上如何使用Sql Server</title>
      <link href="/posts/e35620b3.html"/>
      <url>/posts/e35620b3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>由于小编在这学期要学习数据库原理这门课程，需要用到<code>SQL Server</code>，然而大家都知道<code>SQL Server</code>目前是只能在Windows上使用，我们在mac电脑上如何使用呢？我们可以借助目前比较火的Docker来完成，接下来就给大家介绍如何在docker上部署。</p><h3 id="Docker介绍"><a href="#Docker介绍" class="headerlink" title="Docker介绍"></a>Docker介绍</h3><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h3 id="MacOS-Docker-安装"><a href="#MacOS-Docker-安装" class="headerlink" title="MacOS Docker 安装"></a>MacOS Docker 安装</h3><h4 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h4><p>macOS 我们可以使用 Homebrew 来安装 Docker。</p><p>Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用<code>Homebrew Cask</code>来进行安装，在终端运行以下命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew cask install docker</span></span><br></pre></td></tr></table></figure></div><a id="more"></a><p>安装成功：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading https://download.docker.com/mac/stable/42716/Docker.dmg</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Verifying SHA-256 checksum for Cask 'docker'.</span><br><span class="line">==&gt; Installing Cask docker</span><br><span class="line">==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.</span><br><span class="line">🍺  docker was successfully installed!</span><br></pre></td></tr></table></figure></div><p>在载入<code>Docker app</code>后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有个小鲸鱼的图标。</p><h4 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h4><p>如果需要手动下载，请点击以下链接下载 <a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Stable</a> 或 <a href="https://download.docker.com/mac/edge/Docker.dmg" target="_blank" rel="noopener">Edge</a> 版本的 Docker for Mac。</p><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到 Application 文件夹即可。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvbkRoZnZsc0dkeFp0U1ZLLnBuZw?x-oss-process=image/format,png"></div><br><p>从应用中找到 Docker 图标并点击运行。可能会询问 macOS 的登陆密码，输入即可。<br>点击顶部状态栏中的鲸鱼图标会弹出操作菜单。<br><br></p><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTXhrUUtQcElmVjJlcWNtLnBuZw?x-oss-process=image/format,png"></div><br><br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvcW9KeEdSSDFPdk10RkE1LnBuZw?x-oss-process=image/format,png"></div><br>第一次点击图标，可能会看到这个安装成功的界面，点击 "`Got it!`" 可以关闭这个窗口。<br><div align="center"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDIvMjIvTG4xRUN6c2Z1NnBaRjdvLnBuZw?x-oss-process=image/format,png"></div><br><p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version                                  </span><br><span class="line">Docker version 19.03.5, build 633a0ea</span><br></pre></td></tr></table></figure></div><p>之后我们可以通过 docker info 来查看是否配置成功。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure></div><h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<code>http://hub-mirror.c.163.com</code>。<br>在之前的版本中，Docker客户端有修改镜像的界面，但是更新版本之后，去除了这个界面，那怎么来修改镜像呢？网上都是Linux的教程，并没有Mac的教程，这两个系统之间文件目录有所差别，费了九牛二虎之力找到了<code>daemon.json</code>这个文件。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .docker</span><br></pre></td></tr></table></figure></div><p><code>daemon.json</code>就在这个文件夹，将里面的内容修改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"experimental"</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"debug"</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>:[<span class="string">"http://hub-mirror.c.163.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>重启，Docker就会 应用配置的镜像地址。<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/exQAdcC7giYmBv3.png"></div><br>以上图片就是配置成功的样式。 我们也可以通过 docker info 来查看是否配置成功。<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line">....</span><br><span class="line"> Registry Mirrors:</span><br><span class="line">  http://hub-mirror.c.163.com/</span><br><span class="line"> Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"> Product License: Community Engine</span><br></pre></td></tr></table></figure></div><h3 id="拉取并运行-SQL-Server-容器映像"><a href="#拉取并运行-SQL-Server-容器映像" class="headerlink" title="拉取并运行 SQL Server 容器映像"></a>拉取并运行 SQL Server 容器映像</h3><p>拉取并运行SQL Server 容器映像，参考了<a href="https://docs.microsoft.com/zh-cn/sql/linux/quickstart-install-connect-docker?view=sql-server-linux-2017&pivots=cs1-bash#pullandrun2017" target="_blank" rel="noopener">微软的官方开发文档</a>.</p><p>从 Microsoft 容器注册表中拉取 SQL Server 2017 Linux 容器映像，打开我们的终端，输入命令：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><p>这里会将sql server for linux docker下载到我们计算机上。</p><h4 id="使用-Docker-运行容器映像"><a href="#使用-Docker-运行容器映像" class="headerlink" title="使用 Docker 运行容器映像"></a>使用 Docker 运行容器映像</h4><p>要使用 Docker 运行容器映像，可以从 Bash Shell (Linux/macOS) 或提升的 PowerShell 命令提示符使用以下命令。(也就是终端)。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -e <span class="string">"ACCEPT_EULA=Y"</span> -e <span class="string">"SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -p 1433:1433 --name sql1 \</span><br><span class="line">   -d mcr.microsoft.com/mssql/server:2017-latest</span><br></pre></td></tr></table></figure></div><blockquote><p><font color="blue"><strong>备注</strong>:</font><br>密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。 默认情况下，密码的长度必须至少为 8 个字符，并且必须包含以下四种字符中的三种：大写字母、小写字母、十进制数字和符号。 你可以通过执行 docker logs 命令检查错误日志。</p></blockquote><p>下表对前一个 docker run 示例中的参数进行了说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e “ACCEPT_EULA=Y”</td><td>将 ACCEPT_EULA 变量设置为任意值，以确认接受最终用户许可协议。 SQL Server 映像的必需设置。</td></tr><tr><td>-e “SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;“</td><td>指定至少包含 8 个字符且符合 SQL Server 密码要求的强密码。 SQL Server 映像的必需设置。</td></tr><tr><td>-p 1433:1433</td><td>将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。 在此示例中，SQL Server 侦听容器中的 TCP 1433，并对主机上的端口 1433 公开。</td></tr><tr><td>–name sql1</td><td>为容器指定一个自定义名称，而不是使用随机生成的名称。 如果运行多个容器，则无法重复使用相同的名称。</td></tr><tr><td>-d mcr.microsoft.com/mssql/server:2017-latest</td><td>SQL Server 2017 Linux 容器映像。</td></tr></tbody></table><p>要查看 Docker 容器，请使用 docker ps 命令。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure></div><p>应会看到与以下类似的输出：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                                        COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">78c2deca0bd6        mcr.microsoft.com/mssql/server:2017-latest   <span class="string">"/opt/mssql/bin/nonr…"</span>   30 minutes ago      Exited (0) 2 minutes ago                       sql1</span><br></pre></td></tr></table></figure></div><p>如果“状态”列显示“正常运行”，则 SQL Server 将在容器中运行，并侦听“端口”列中指定的端口 。</p><h4 id="更改-SA-密码"><a href="#更改-SA-密码" class="headerlink" title="更改 SA 密码"></a>更改 SA 密码</h4><p>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。 创建 SQL Server 容器后，通过在容器中运行 <code>echo $SA_PASSWORD</code>，可发现指定的 <code>SA_PASSWORD</code> 环境变量。 出于安全考虑，请考虑更改 SA 密码。</p><ol><li>选择 SA 用户要使用的强密码。</li><li>使用 docker exec 运行sqlcmd ，以使用 <code>Transact-SQL</code> 更改密码。 在下面的示例中，将旧密码 <code>&lt;YourStrong!Passw0rd&gt;</code>和新密码 <code>&lt;YourNewStrong!Passw0rd&gt;</code> 替换为你自己的密码值。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">   -S localhost -U SA -P <span class="string">"&lt;YourStrong@Passw0rd&gt;"</span> \</span><br><span class="line">   -Q <span class="string">'ALTER LOGIN SA WITH PASSWORD="&lt;YourNewStrong@Passw0rd&gt;"'</span></span><br></pre></td></tr></table></figure></div><h4 id="连接到-SQL-Server"><a href="#连接到-SQL-Server" class="headerlink" title="连接到 SQL Server"></a>连接到 SQL Server</h4><p>下列步骤在容器内部使用<code>SQL Server</code>命令行工具<code>sqlcmd</code> 来连接 <code>SQL Server</code>。</p><ol><li>使用 <code>docker exec -it</code> 命令在运行的容器内部启动交互式 <code>Bash Shell</code>。 在下面的示例中，sql1 是在创建容器时由 –name 参数指定的名称。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it sql1 <span class="string">"bash"</span></span><br></pre></td></tr></table></figure></div><ol start="2"><li>在容器内部使用 sqlcmd 进行本地连接。 默认情况下，sqlcmd 不在路径之中，因此需要指定完整路径。</li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P <span class="string">"&lt;YourNewStrong@Passw0rd&gt;"</span></span><br></pre></td></tr></table></figure></div><ol start="3"><li>如果成功，应会显示 sqlcmd 命令提示符：1&gt;。</li></ol><h3 id="利用Navicat可视化工具连接Sql-Server"><a href="#利用Navicat可视化工具连接Sql-Server" class="headerlink" title="利用Navicat可视化工具连接Sql Server"></a>利用Navicat可视化工具连接Sql Server</h3><h4 id="下载Navicat"><a href="#下载Navicat" class="headerlink" title="下载Navicat"></a>下载Navicat</h4><p>因为正版只有14天的试用期，没Money的小编只有安排破解版了，在这里把安装包也分享给大家：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ" target="_blank" rel="noopener">https://pan.baidu.com/s/198LYSswTRqlVUmST8ZepeQ</a> 密码:cg5s</p></blockquote><p>下载好后添加Sql Server数据库连接:<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/3zoU1tI74yf9kh2.png"></div><br><div class="note danger"><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>密码一定不要填错，如果密码填错，会出现以下错误：</p></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[42000] [FreeTDS][SQL Server]Login failed for user &apos;SA&apos;. (18456)</span><br><span class="line">[08001] [FreeTDS][SQL Server]Unable to connect to data source (0)</span><br></pre></td></tr></table></figure></div><p>最后，连接成功！<br><br></p><div align="center"><img src="https://i.loli.net/2020/02/23/D6tHIF3PWXSNwir.png"></div><br><div class="note success"><p><strong><font color="#5cb85c">满怀希望就会所向披靡，因为深海不会因为一杯沸水而加温!</font></strong></p><p>以上就是小编本次给大家分享的在Mac上如何使用SQL Server的详细教程,我们一起讨论！如果哪里有写的不好的地方，还希望大家提出来，在下方评论区留言，我加以修正！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> Sql Server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Sql Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的含义以及C语言实现顺序队列</title>
      <link href="/posts/2d063bc3.html"/>
      <url>/posts/2d063bc3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p><font color="green">队列</font>，和栈一样，也是一种对数据的”存”和”取”有严格要求的线性存储结构。</p><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>与栈结构不同的是，<font color="red">队列</font>的两端都”开口”，要求数据只能从一端进，从另一端出，如下图示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwb0hscS5naWY" alt></p><blockquote><p>通常，称进数据的一端为 “<font color="green">队尾</font>“，出数据的一端为 “<font color="green">队头</font>“，数据元素进队列的过程称为 “<font color="green">入队</font>“，出队列的过程称为 “<font color="green">出队</font>“。</p></blockquote><a id="more"></a><p>不仅如此，<font color="red">队列中数据的进出要遵循 “先进先出” 的原则</font>，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 “先进先出” 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。</p><blockquote><p>栈和队列不要混淆，栈结构是一端封口，特点是”先进后出”；而队列的两端全是开口，特点是”先进先出”。</p></blockquote><p>因此，数据从表的一端进，从另一端出，且遵循 “先进先出” 原则的线性存储结构就是队列。</p><h3 id="顺序队列的实现"><a href="#顺序队列的实现" class="headerlink" title="顺序队列的实现"></a>顺序队列的实现</h3><p><font color="blue">顺序队列</font>，即采用顺序表模拟实现的队列结构。</p><blockquote><p>我们知道，队列具有以下两个特点：<br>数据从队列的一端进，另一端出；<br>数据的入队和出队遵循”先进先出”的原则；</p></blockquote><p>因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。</p><h4 id="顺序队列简单实现"><a href="#顺序队列简单实现" class="headerlink" title="顺序队列简单实现"></a>顺序队列简单实现</h4><p>由于顺序队列的底层使用的是<font color="blue">数组</font>，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVGEzbi5naWY" alt><br>由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。</p><p>在上图的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。</p><p>例如，在上图的基础上将<code>{1,2,3,4}</code>用顺序队列存储的实现操作如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVFdnMS5naWY" alt><br>在上图基础上，顺序队列中数据出队列的实现过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwVE9nSS5naWY" alt><br>因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    a[rear]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果 front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (front!=rear) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出队元素：%d\n"</span>,a[front]);</span><br><span class="line">        front++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a, rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a, rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序输出结果：</p><blockquote><p>出队元素：1<br>出队元素：2<br>出队元素：3<br>出队元素：4</p></blockquote><p><strong><em>此方法存在的问题</em></strong></p><p>先来分析上面两张图。第一张图的b是有数据进队成功的示意图，而第二张图的b 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。</p><p>顺序队列整体后移造成的影响是：</p><ul><li>顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；</li><li>如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；</li></ul><p>为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。</p><h4 id="顺序队列另一种实现方法"><a href="#顺序队列另一种实现方法" class="headerlink" title="顺序队列另一种实现方法"></a>顺序队列另一种实现方法</h4><p>既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。</p><p>为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如下图所示：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzE2LzNwN0JSQS5naWY" alt><br>上图只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 5<span class="comment">//表示顺序表申请的空间大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满</span></span><br><span class="line">    <span class="keyword">if</span> ((rear+<span class="number">1</span>)%max==front) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空间已满"</span>);</span><br><span class="line">        <span class="keyword">return</span> rear;</span><br><span class="line">    &#125;</span><br><span class="line">    a[rear%max]=data;</span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">deQueue</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> front,<span class="keyword">int</span> rear)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果front==rear，表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span>(front==rear%max) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[front]);</span><br><span class="line">    <span class="comment">//front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]</span></span><br><span class="line">    front=(front+<span class="number">1</span>)%max;</span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[max];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">    <span class="comment">//设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址</span></span><br><span class="line">    front=rear=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">1</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">2</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">3</span>);</span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="comment">//再入队</span></span><br><span class="line">    rear=enQueue(a,front,rear, <span class="number">6</span>);</span><br><span class="line">    <span class="comment">//再出队</span></span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    front=deQueue(a, front, rear);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果：</p><blockquote><p>1 2 3 4 5 6</p></blockquote><p>使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：</p><ul><li>当队列为空时，队列的头指针等于队列的尾指针；</li><li>当数组满员时，队列的头指针等于队列的尾指针；</li></ul><p>顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。</p><div class="note success"><p><strong><font color="#5cb85c">不去追逐，永远不会拥有。不往前走，永远原地停留!</font></strong><br>利用本篇文章的机会，给大家介绍了C队列以及简单的实现了顺序队列，并作出了一些优化。相关的代码依旧是托管在了github上面，需要的小伙伴请自取。如果有写的不好的地方，大家在评论区留言，我加以改正，和大家一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 顺序队列 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现链式栈</title>
      <link href="/posts/6163d4b5.html"/>
      <url>/posts/6163d4b5.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>在之前写的C语言实现链式栈篇博文中，我已经给大家大概介绍了关于<a href="https://www.xiangjunhong.com/posts/9b621d6f.html">链式栈</a>的意义以及相关操作,我会在下面给大家分享百度百科对链式栈的定义，以及给大家介绍利用C++实现链式栈的基本操作。</p><h3 id="百度百科链式栈"><a href="#百度百科链式栈" class="headerlink" title="百度百科链式栈"></a>百度百科链式栈</h3><blockquote><p>链式栈是一种数据存储结构，可以通过单链表的方式来实现，使用链式栈的优点在于它能够克服用数组实现的顺序栈空间利用率不高的特点，但是需要为每个栈元素分配额外的指针空间用来存放指针域。</p></blockquote><p><font color="blue">栈</font>是只能在某一端插入和删除的特殊线性表。它按照后进先出的原则存储数据，先进入的数据被压入栈底（push），最后的数据在栈顶（top），需要读数据的时候从栈顶开始弹出数据（top）最后一个数据被第一个读出来。链式栈中的元素以Node的形式存储，节点Node中存有此节点存于栈中的元素以及指向下个节点的指针。链式栈的数据成员只用保存指向栈顶节点的指针 *top_node。</p><a id="more"></a><p><font color="blue">顺序栈</font>的实现在于使用了数组这个基本数据结构，数组中的元素在内存中的存储位置是连续的，且编译器要求我们在编译期就要确定数组的大小，这样<font color="DarkViolet">对内存的使用效率并不高，一来无法避免因数组空间用光而引起的溢出问题，二在系统将内存分配给数组后，则这些内存对于其他任务就不可用</font>；而对于链栈而言，使用了<font color="gree">链表来实现栈，链表中的元素存储在不连续的地址，由于是动态申请内存，所以我们可以以非常小的内存空间开始，另外当某个项不使用时也可将内存返还给系统</font>。</p><h3 id="C-实现链式栈"><a href="#C-实现链式栈" class="headerlink" title="C++实现链式栈"></a>C++实现链式栈</h3><p>利用C++语言实现了数据结构的链式栈，主要完成了以下操作：</p><table><thead><tr><th>链式栈的</th><th>基本操作</th></tr></thead><tbody><tr><td>元素进栈</td><td>元素出栈</td></tr><tr><td>返回栈顶元素</td><td>判断栈是否为空</td></tr><tr><td>打印栈的元素</td><td></td></tr></tbody></table><h4 id="链式栈的结点"><a href="#链式栈的结点" class="headerlink" title="链式栈的结点"></a>链式栈的结点</h4><p>链式栈的结点其实跟链式结构的顺序结构差不多类似，包含两部分，一是储存数据的<font color="red">数据域</font>，二是储存下一结点地址的<font color="red">指针域</font>,因此以结构体封装的结点如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">chainStackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T data;<span class="comment">//链式栈储存结点的数据</span></span><br><span class="line">chainStackNode&lt;T&gt; *next;<span class="comment">//链式栈指向下一结点的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="链式栈的基本操作"><a href="#链式栈的基本操作" class="headerlink" title="链式栈的基本操作"></a>链式栈的基本操作</h4><p>在写这次链式栈的时候，我在所有的函数实现前都加上了<font color="red">inline</font>,在这里给大家解释一下。inline是<font color="green">C++关键字</font>，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为<font color="green">内联函数</font>，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</p><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>构造函数，就是实现成员的初始化操作，当然在这里实现链式栈的初始化就只需要创建一个头指针，并初始化头指针的各个成员。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:chainStack()</span><br><span class="line">&#123;</span><br><span class="line">top = <span class="keyword">new</span> chainStackNode&lt;T&gt;;<span class="comment">//创建一个新的结点</span></span><br><span class="line">top-&gt;next = <span class="literal">NULL</span>;<span class="comment">//将top的next指针指向空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素进栈"><a href="#元素进栈" class="headerlink" title="元素进栈"></a>元素进栈</h5><p>链式栈的进栈操作，顾名思义就是一个新的元素进入栈，当然首先要创建一个新的结点，然后就是将这个新的结点插入到栈顶，只需要调整来两个指针操作。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Push(T newData)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *newNode = <span class="keyword">new</span> chainStackNode&lt;T&gt;;</span><br><span class="line"><span class="keyword">if</span>(!newNode)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"分配内存失败！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;data = newData;<span class="comment">//修改指针，添加元素</span></span><br><span class="line">newNode-&gt;next = top-&gt;next;</span><br><span class="line">top-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h5><p>元素出栈，就跟线性表的删除元素类似，不过只能删除顶部结点，这个栈的特性是不可以违背的，调整指针删除结点之后不要忘了释放删除的结点的内存。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:Pop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *temporaryNode;<span class="comment">//创建一个临时指针指向删除结点</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"该栈为空！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temporaryNode = top-&gt;next;</span><br><span class="line">x = temporaryNode-&gt;data;<span class="comment">//以引用返回</span></span><br><span class="line">top-&gt;next = temporaryNode-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> temporaryNode;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="返回栈顶元素"><a href="#返回栈顶元素" class="headerlink" title="返回栈顶元素"></a>返回栈顶元素</h5><p>返回栈顶的元素，判断栈是否为空，如果为空自然没有元素可以返回，否则就返回top指向的下一个结点的数据即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:getTop(T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty() == <span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = top-&gt;next-&gt;data;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h5><p>有了top指针，就只需要判断top指针的下一结点是否为空即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(top-&gt;next == <span class="literal">NULL</span>)&#123;<span class="comment">//top指针的下一结点是否为空，以此来判断是否为空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印栈的元素"><a href="#打印栈的元素" class="headerlink" title="打印栈的元素"></a>打印栈的元素</h5><p>打印栈的元素，就是一个遍历的过程，定义一个指针，输出结点数据，调整指针位置。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">void</span> <span class="title">chainStack</span>&lt;T&gt;:</span>:printChainStackData()</span><br><span class="line">&#123;</span><br><span class="line">chainStackNode&lt;T&gt; *pMove;</span><br><span class="line">pMove = top-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]-&gt;"</span>;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">冰冻三尺，非一日之寒!</font></strong><br>到这里，利用C++语言实现链式栈的介绍就已经结束了，如果有哪里写的不好的地方，还希望大家给我提出了，我加以修正，完整的代码包括测试代码我已经push到了github<a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E9%93%BE%E5%BC%8F%E6%A0%88" target="_blank" rel="noopener">C++实现链式栈</a>，如果大家有什么想法的，欢迎在下方评论区留言，我们一起讨论，共同进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 链式栈 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现双向循环链表</title>
      <link href="/posts/a530f7f0.html"/>
      <url>/posts/a530f7f0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>本次博文是关于利用C++模板的方式实现的双向循环链表以及双向循环链表的基本操作，在之前的博文C++语言实现双向链表中，以下是链接<a href="https://www.xiangjunhong.com/posts/5394fce7.html" class="LinkCard">C++语言实现双向循环链表</a>已经给大家分析了双向循环链表的结构，并以图示的方式给大家解释了双向循环链表的基本操作。本篇文章利用C++实现了双向循环链表的基本操作，其中包括：</p><table><thead><tr><th>双向循环链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>双向循环链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>在之前的C++语言实现双向链表时已经给大家解释了封装的结点的特点，不需要作太大的改变，我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向循环链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedList</span>;</span><span class="comment">//声明一下双向循环链表，以免定义友元时报错</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">doubleCircularLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向循环链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleCircularLinkedListNode(T _data,doubleCircularLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleCircularLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleCircularLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>本次实现的操作跟双向链表实现的操作基本一样，实现了双向循环链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向循环链表的长度，打印双向循环链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>实现双向循环链表的头部插入结点，之前的双向链表因为在头部和尾部的指针都是指向<font color="green">NULL</font>的,所以需要分情况来处理，然而双向循环链表没有元素时这两个指针都是指向自身的，因此并不需要分情况处理，都需要修改四个指针。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，调整四个指针即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* lastNode = headNode;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都需要调整四个指针，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleCircularLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历双向循环链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next; <span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMoveprior = headNode;<span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(pMove-&gt;data != item)</span><br><span class="line">&#123;</span><br><span class="line">pMoveprior = pMove;</span><br><span class="line">pMove = pMoveprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(pMove == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pMove = headNode;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向循环链表的长度"><a href="#双向循环链表的长度" class="headerlink" title="双向循环链表的长度"></a>双向循环链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt; *pMove = headNode-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向循环链表"><a href="#打印双向循环链表" class="headerlink" title="打印双向循环链表"></a>打印双向循环链表</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleCircularLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleCircularLinkedListNode&lt;T&gt;* pMove = headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove !=headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">与其用泪水悔恨今天，不如用汗水拼搏明天!</font></strong><br>以上就是我简要的给大家分享的C++实现双向循环链表，因为实现了双向链表，所以基本上实现思路差不多，唯一的不同就是在<font color="red">循环</font>一词不同，这一不同就是头结点的前驱指针和尾结点的后驱指针指向不同，要是还是不太清楚的可以去那篇博客看看。本次的完整代码已经全部上传到github! <a href="https://github.com/xjh199923/DataStructures/tree/master/C++/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">(C++实现双向循环链表)</a>,如果有什么问题，欢迎在下方评论区留言啊，我们一起讨论啊，一起进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> 双向循环链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现双向链表</title>
      <link href="/posts/5394fce7.html"/>
      <url>/posts/5394fce7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>这篇文章是关于利用C++模板的方式实现的双向链表以及双向链表的基本操作，在之前的博文中，以下是链接<br><a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">C++语言实现双向链表</a><br>已经给大家分析了双向链表的结构，并以图示的方式给大家解释了双向链表的基本操作。本篇文章利用C++实现了双向链表的基本操作，其中包括：</p><blockquote><p><strong>双向链表的基本操作C++语言实现</strong></p></blockquote><table><thead><tr><th>双向链表</th><th>实现的功能</th></tr></thead><tbody><tr><td>头部插入结点建立链表</td><td>尾部插入结点建立链表</td></tr><tr><td>实现指定位置插入结点</td><td>查找给定数值是否存在</td></tr><tr><td>删除指定位置的结点</td><td>修改指定位置的结点</td></tr><tr><td>双向链表的长度</td><td>打印双向链表</td></tr></tbody></table><a id="more"></a><h3 id="定义双向链表的结点"><a href="#定义双向链表的结点" class="headerlink" title="定义双向链表的结点"></a>定义双向链表的结点</h3><p>因为双向链表的结点由三部分构成，用于<font color="blue">指向当前节点的直接前驱节点</font>的<font color="green">指针域</font>,<font color="blue">用于存储数据元素</font>的<font color="green">数据域</font> ，以及<font color="blue">用于指向当前节点的直接后继节点</font>的<font color="green">指针域</font>。</p><p>因此，首先我们需要封装一个结点类,定义了结点的三个要素，并利用构造函数实现初始化，另外，考虑到在双向链表中要用到结点类，所以将双向链表类定义为结点的友元类。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *prior;<span class="comment">//双向结点前驱指针指向该结点的前驱结点</span></span><br><span class="line">T data;<span class="comment">//储存结点数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; *next;<span class="comment">//双向结点的后驱指针指向该结点的后继结点</span></span><br><span class="line"><span class="comment">//将双向链表类定义为结点的友元类</span></span><br><span class="line"><span class="keyword">friend</span>  <span class="class"><span class="keyword">class</span> <span class="title">doubleLinkedList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//结点的无参构造函数,将结点指针域初始化为NULL</span></span><br><span class="line">doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结点的有参构造函数，初始化指针域和数据域</span></span><br><span class="line">doubleLinkedListNode(T _data,doubleLinkedListNode&lt;T&gt; *_prior = <span class="literal">NULL</span>,doubleLinkedListNode&lt;T&gt; *_next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">prior = _prior;<span class="comment">//初始化前驱指针</span></span><br><span class="line">data = _data;<span class="comment">//初始化数据域</span></span><br><span class="line">next = _next;<span class="comment">//初始化后继指针</span></span><br><span class="line">&#125;</span><br><span class="line">~doubleLinkedListNode()</span><br><span class="line">&#123;</span><br><span class="line">prior = <span class="literal">NULL</span>;</span><br><span class="line">next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><p>实现了双向链表头部插入结点， 尾部插入结点，指定位置插入结点建立链表， 查找给定数值的指定位置，删除指定位置的结点，修改指定位置的结点，双向链表的长度，打印双向链表，接下来逐一进行讲解实现：</p><h4 id="头部插入结点建立链表"><a href="#头部插入结点建立链表" class="headerlink" title="头部插入结点建立链表"></a>头部插入结点建立链表</h4><p>带头结点实现的双向链表，实现头部插入结点可分为两种情况，一种是只有一个头结点的时候，只需要使<font color="blue">head</font>和<font color="blue">newNode</font>的两个指针关联上即可，另外的两个指针依旧是<font color="blue">NULL</font>状态。另一种情况便是有结点的情况，这个时候跟在中间结点插入相似，需要调整四个指针,首先是让<font color="blue">newNode</font>与后继结点关联，最后让<font color="blue">newNode</font>与<font color="blue">head</font>结点关联。<br>因此，头部插入结点实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeByhead(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分两种情况，head的next是否为NULL,然后处理四个指针</span></span><br><span class="line"><span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">newNode-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;prior = head;</span><br><span class="line">head-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="尾部插入结点建立链表"><a href="#尾部插入结点建立链表" class="headerlink" title="尾部插入结点建立链表"></a>尾部插入结点建立链表</h4><p>在尾部插入结点，当然第一步需要找到最后一个结点，然后在其后进行插入，双向链表因为两端的指针都是指向<font color="blue">NULL</font>的，所以在尾部插入也只需要调整两个指针就ok.</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:insertNodeBytail(T item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首先找到最后一个结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* lastNode = head;</span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;<span class="comment">//没找到就一直循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到调整指针</span></span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="实现指定位置插入结点"><a href="#实现指定位置插入结点" class="headerlink" title="实现指定位置插入结点"></a>实现指定位置插入结点</h4><p>在指定位置插入只需要两步走，首先也是找到指定的位置，然后就是插入新结点的指针的调整，中间插入是最复杂的，都逃不过调整四个指针，但是首先依旧是让新结点和后继结点建立上相关性，最后让新结点与前继结点建立关系，实现新结点的插入。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> doubleLinkedList&lt;T&gt;::insertNode(T item,<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的非有效位置！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head;<span class="comment">//创建一个新的指针，设置为游标指针</span></span><br><span class="line"><span class="comment">//首先找到插入位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>&amp;&amp; i&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"插入位置无效！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新的结点</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* newNode = <span class="keyword">new</span> doubleLinkedListNode&lt;T&gt;(item);</span><br><span class="line"><span class="keyword">if</span> (newNode == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败，新结点无法创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入新的结点</span></span><br><span class="line">newNode-&gt;next = pMove-&gt;next;   </span><br><span class="line"><span class="keyword">if</span> (pMove-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove-&gt;next-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line">newNode-&gt;prior = pMove;</span><br><span class="line">pMove-&gt;next = newNode;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找给定数值是否存在"><a href="#查找给定数值是否存在" class="headerlink" title="查找给定数值是否存在"></a>查找给定数值是否存在</h4><p>查找给定元素，也就是一个遍历链表的过程，从头结点的下一个结点开始遍历，毕竟第一个头结点是没有储存数据项的。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:findData(T item)</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">if</span>(pMove == <span class="literal">NULL</span>)<span class="comment">//链表为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(pMove)<span class="comment">//遍历链表</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pMove-&gt;data == item)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定位置的结点"><a href="#删除指定位置的结点" class="headerlink" title="删除指定位置的结点"></a>删除指定位置的结点</h4><p>删除指定的结点，第一步查找到删除的结点，需要定义一个删除指针临时指向将要删除的结点，最后指针处理删除之后别忘了<font color="red">释放</font>该结点空间。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:deleteData(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pMove = head;<span class="comment">//设置游标指针</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt; * pDelete;             </span><br><span class="line"><span class="comment">//查找删除结点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;                                         <span class="comment">//游标指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line">pDelete = pMove;      </span><br><span class="line">pMove-&gt;prior-&gt;next = pDelete-&gt;next;</span><br><span class="line">pMove-&gt;next-&gt;prior = pDelete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> pDelete;<span class="comment">//释放空间</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="修改指定位置的结点"><a href="#修改指定位置的结点" class="headerlink" title="修改指定位置的结点"></a>修改指定位置的结点</h4><p>修改指定位置的结点数据，当然还是得找到指定位置，然后对其进行修改，修改之后将原来的数据以引用的形式返回，具体的用法在测试函数中写到了的，不会的可以作为参考。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:changeListElements(<span class="keyword">int</span> n,T item,T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">1</span>||n&gt;getLength())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入非有效位置"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//找到指定位置1</span></span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">x = pMove-&gt;data;</span><br><span class="line">pMove-&gt;data = item;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="双向链表的长度"><a href="#双向链表的长度" class="headerlink" title="双向链表的长度"></a>双向链表的长度</h4><p>计算双向链表的长度的函数，在双向链表的私有成员封装了一个变量<font color="green">length</font>,以此来记录双向链表的长度，遍历双向链表，逐一进行计算结点数就是双向链表的长度。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:getLength()</span><br><span class="line">&#123;</span><br><span class="line">doubleLinkedListNode&lt;T&gt; *pMove = head-&gt;next;  <span class="comment">//设置游标指针</span></span><br><span class="line"><span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//遍历链表，计算结点数</span></span><br><span class="line"><span class="keyword">while</span>(pMove!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pMove = pMove-&gt;next;  <span class="comment">//游标指针后移</span></span><br><span class="line">length++;       <span class="comment">//计算length</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印双向链表"><a href="#打印双向链表" class="headerlink" title="打印双向链表"></a>打印双向链表</h4><p>打印双向链表，从第二个结点开始遍历链表，因为第一个为头结点是不含数据的，打印的过程也就是一个遍历的过程。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doubleLinkedList</span>&lt;T&gt;:</span>:printLinkedlist()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line">doubleLinkedListNode&lt;T&gt;* pMove = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(pMove)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pMove-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次博文与大家分享的利用C++语言实现双向链表，在用C语言写了之后，感觉写起来就比较轻松，唯一不同的就是要利用类来进行封装。完整的代码，以及测试代码我已经Push到Github,喜欢的小伙伴欢迎Star! <a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">C++语言实现双向链表Github地址</a>，我们一起讨论，如果有写的不好的地方还请多多担待，也欢迎大家在评论区留言，我加以改正，共同进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 双向链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现链式栈</title>
      <link href="/posts/9b621d6f.html"/>
      <url>/posts/9b621d6f.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p><font color="red">链栈</font>，即用<font color="blue">链表</font>实现栈存储结构。链栈的实现思路同顺序栈类似，<font color="blue">顺序栈</font>是将数<font color="blue">顺序表（数组）</font>的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如下下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHYzNEQS5naWY" alt="在这里插入图片描述"></p><blockquote><p>将链表头部作为栈顶的一端，可以避免在实现数据 “入栈” 和 “出栈” 操作时做大量遍历链表的耗时操作。</p></blockquote><p>链表的头部作为栈顶，意味着：</p><ul><li>在实现数据”<font color="green">入栈</font>“操作时，需要将数据从链表的头部插入；</li><li>在实现数据”<font color="green">出栈</font>“操作时，需要删除链表头部的首元节点；<a id="more"></a></li></ul><p><font color="red">因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。</font></p><h3 id="链栈元素入栈"><a href="#链栈元素入栈" class="headerlink" title="链栈元素入栈"></a>链栈元素入栈</h3><p>例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHY3FQSy5naWY" alt><br>C语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表中的节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="comment">//stack为当前的链栈，a表示入栈元素</span></span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建存储新元素的节点</span></span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    <span class="comment">//新节点与头节点建立逻辑关系</span></span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="comment">//更新头指针的指向</span></span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="链栈元素出栈"><a href="#链栈元素出栈" class="headerlink" title="链栈元素出栈"></a>链栈元素出栈</h3><p>例如，上图所示的链栈中，若要将元素 3 出栈，根据”先进后出”的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAyLzAxLzFHZ2Jlcy5naWY" alt="在这里插入图片描述"><br>因此，实现栈顶元素出链栈的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈顶元素出链栈的实现函数</span></span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        <span class="comment">//声明一个新指针指向栈顶节点</span></span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="comment">//更新头指针</span></span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"出栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"新栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中通过使用 if 判断语句，避免了用户执行”栈已空却还要数据出栈”错误操作。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lineStack</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;lineStack;</span><br><span class="line"><span class="function">lineStack* <span class="title">push</span><span class="params">(lineStack * <span class="built_in">stack</span>,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    lineStack * line=(lineStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(lineStack));</span><br><span class="line">    line-&gt;data=a;</span><br><span class="line">    line-&gt;next=<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=line;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lineStack * <span class="title">pop</span><span class="params">(lineStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">        lineStack * p=<span class="built_in">stack</span>;</span><br><span class="line">        <span class="built_in">stack</span>=<span class="built_in">stack</span>-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"弹栈元素：%d "</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">stack</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈顶元素：%d\n"</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"栈已空\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈内没有元素"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lineStack * <span class="built_in">stack</span>=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">stack</span>=push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">stack</span>=pop(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>弹栈元素：4 栈顶元素：3<br>弹栈元素：3 栈顶元素：2<br>弹栈元素：2 栈顶元素：1<br>弹栈元素：1 栈已空<br>栈内没有元素</p></blockquote><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次分享给大家的利用C语言实现链栈，二月的第一篇博文，希望得到大家的支持鸭！如果有什么写的不好，不对的地方，还望各路大神指出来，欢迎在下方评论区留言！我们一起共同进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 链式栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现双向循环链表</title>
      <link href="/posts/538e5180.html"/>
      <url>/posts/538e5180.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>在之前的文章中，我写过一篇关于C语言实现双向链表的博文，下面是链接：<a href="https://www.xiangjunhong.com/posts/beb5106a.html" class="LinkCard">双向链表</a><br>介绍了双向链表的实现过程以及双向链表的优势，接下来我首先给大家介绍一下<font color="red">循环链表</font>和<font color="red">双向链表</font>的区别，之后再给大家介绍<font color="blue">双向循环</font>链表的具体实现。</p><h3 id="循环链表和双向链表的区别"><a href="#循环链表和双向链表的区别" class="headerlink" title="循环链表和双向链表的区别"></a>循环链表和双向链表的区别</h3><p>1、最后一个结点指针指向不同</p><p>在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是像双向链表那样置为NULL。此种情况还用于在最后一个结点后插入一个新的结点。</p><p>2、判断链域值不同</p><p>在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非像单链表那样判断链域值是否为NULL。</p><a id="more"></a><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQVBiUS5wbmc?x-oss-process=image/format,png" alt><br>3、访问方式：</p><p>循环链表：可以从任何一个结点开始，顺序向后访问到达任意结点</p><p>双向链表：可以从任何结点开始任意向前向后双向访问</p><p>4、操作：</p><p>循环链表：只能在当前结点后插入和删除</p><p>双链表：可以在当前结点前面或者后面插入，可以删除前趋和后继（包括结点自己）</p><p>5、存储：循环链表存储密度大于双链表</p><h3 id="双向循环链表的具体实现"><a href="#双向循环链表的具体实现" class="headerlink" title="双向循环链表的具体实现"></a>双向循环链表的具体实现</h3><p>双向循环链表：最后一个节点的next指向head，而head的prior指向最后一个节点，构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzQTJNOC5tZC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>由上图可以看出，双向循环链表的结点结构与双向链表的结构是一样的，都是含有三项：<font color="blue">前驱指针prior</font>,<font color="blue">数据项data</font>,<font color="blue">后驱指针next</font>,因此双向循环链表结点结构用C语言实现如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">prior</span>;</span><span class="comment">//结点的前驱指针</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//结点的数据项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">next</span>;</span><span class="comment">//结点的后继指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h5 id="双向循环链表的初始化"><a href="#双向循环链表的初始化" class="headerlink" title="双向循环链表的初始化"></a>双向循环链表的初始化</h5><p>只有一个头节点head，就让prior和next都指向自己，形成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkNETy5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>初始化头结点代码实现：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个头结点，数据差异化当作表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">headNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//循环链表，所以初始化头指针，尾指针都是指向自身的，data数据域不做初始化</span></span><br><span class="line">headNode-&gt;prior = headNode;<span class="comment">//头结点指向自身</span></span><br><span class="line">headNode-&gt;next = headNode;<span class="comment">//尾结点指向自身</span></span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="创建一个新的结点"><a href="#创建一个新的结点" class="headerlink" title="创建一个新的结点"></a>创建一个新的结点</h5><p>与单向循环链表类似的，只是多了一个prior要考虑，为插入做准备。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzWkRJSi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct doubleCircularLinkedList* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//动态申请内存malloc+free c语言的特点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">doubleCircularLinkedList</span>));</span></span><br><span class="line"><span class="comment">//创建结点过程相当于初始化过程</span></span><br><span class="line">newNode-&gt;data = data;<span class="comment">//传入data数值初始化数据域</span></span><br><span class="line">newNode-&gt;prior = <span class="literal">NULL</span>;<span class="comment">//初始化头结点为null</span></span><br><span class="line">newNode-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化尾结点为null</span></span><br><span class="line"><span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="插入新的元素"><a href="#插入新的元素" class="headerlink" title="插入新的元素"></a>插入新的元素</h5><p>与单向循环链表类似，只是多了一个prior要考虑。这里就不需判断插入的位置是不是在最后了，已经构成一个环。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzZXVXUi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h6 id="表头插入实现"><a href="#表头插入实现" class="headerlink" title="表头插入实现"></a>表头插入实现</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeByHead</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建一个新的结点，调用创建新结点的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//修改四个指针变量</span></span><br><span class="line">newNode-&gt;prior = headNode;</span><br><span class="line">newNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next-&gt;prior=newNode;</span><br><span class="line">headNode-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h6 id="表尾插入实现"><a href="#表尾插入实现" class="headerlink" title="表尾插入实现"></a>表尾插入实现</h6><blockquote><p>在表尾插入，比表头插入更容易出错，大家多加注意！首先找到尾部最后一个元素，然后再进行插入操作</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNodeBynext</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">newNode</span> = <span class="title">createNode</span>(<span class="title">data</span>);</span></span><br><span class="line"><span class="comment">//首先找到最后一个结点的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">lastNode</span> = <span class="title">headNode</span>;</span></span><br><span class="line"><span class="keyword">while</span>(lastNode-&gt;next != headNode)</span><br><span class="line">&#123;</span><br><span class="line">lastNode = lastNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到之后调整四个指针</span></span><br><span class="line">headNode-&gt;prior = newNode;</span><br><span class="line">newNode-&gt;next = headNode;</span><br><span class="line">lastNode-&gt;next = newNode;</span><br><span class="line">newNode-&gt;prior = lastNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h5><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可，<font color="red">删除之后不要忘了释放空间哟！</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzEzbU1OUS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpecifyLocationToDelete</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在指定位置，无法删除！\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNodeprior-&gt;next = posNode-&gt;next;</span><br><span class="line">posNode-&gt;next-&gt;prior=posNodeprior;</span><br><span class="line"><span class="built_in">free</span>(posNode);<span class="comment">//删除之后，释放空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素"><a href="#查找指定元素" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchSpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"该元素存在！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="查找指定元素-1"><a href="#查找指定元素-1" class="headerlink" title="查找指定元素"></a>查找指定元素</h5><p>通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifySpecifiedElement</span><span class="params">(struct doubleCircularLinkedList* headNode,<span class="keyword">int</span> posData,<span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNode</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span><span class="comment">//指定结点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">posNodeprior</span> = <span class="title">headNode</span>;</span><span class="comment">//指定结点前一个结点的指针</span></span><br><span class="line"><span class="comment">//找到指定位置</span></span><br><span class="line"><span class="keyword">while</span>(posNode-&gt;data != posData)</span><br><span class="line">&#123;</span><br><span class="line">posNodeprior = posNode;</span><br><span class="line">posNode = posNodeprior-&gt;next;</span><br><span class="line"><span class="comment">//如果没有找到特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(posNode-&gt;next == headNode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不存在元素！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">posNode-&gt;data = elem;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改成功！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a>打印数据</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct doubleCircularLinkedList* headNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从第二个结点开始打印，表头不含数据</span></span><br><span class="line"><span class="comment">//也可以通过前指针进行打印，只需将next改为prior即可</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doubleCircularLinkedList</span>* <span class="title">pMove</span> = <span class="title">headNode</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">while</span>(pMove != headNode)<span class="comment">//如果pMove-&gt;next != headNode这样写，最后一个结点是不会打印的</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,pMove-&gt;data);</span><br><span class="line">pMove = pMove-&gt;next;<span class="comment">//移动指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>参考博文：<br><a href="https://blog.csdn.net/baweiyaoji/article/details/76071053" target="_blank" rel="noopener">https://blog.csdn.net/baweiyaoji/article/details/76071053</a></p><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>以上就是本次给大家分享的C语言实现双向循环链表，完整的代码已经push到了githubs上面（<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/doubleCircularLinkedList.c" target="_blank" rel="noopener">传送门</a>），欢迎各位clone，如果觉得还不错的话，欢迎Star! 如果有哪里有问题，欢迎大家在下面评论区留言，我及时修改更正，坚持就是胜利！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双向循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现顺序栈</title>
      <link href="/posts/278598dc.html"/>
      <url>/posts/278598dc.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>C语言实现顺序栈以及栈的特点</p><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h3><p>同<font color="blue">顺序表</font>和<font color="blue">链表</font>一样，栈也是<font color="red">用来存储逻辑关系为 “一对一” 数据的线性存储结构</font>，如下图所示。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNSERkcy5naWY" alt="图一"><br>从上图我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 “存” 和 “取” 的过程有特殊的要求：</p><blockquote><ol><li>栈只能从表的一端存取数据，另一端是封闭的，如上图所示；</li><li>在栈中，无论是存数据还是取数据，都必须遵循”先进后出”的原则，即最先进栈的元素最后出栈。拿上图的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据”先进后出”的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。</li></ol></blockquote><a id="more"></a><p>因此，我们可以给栈下一个定义，即<font color="red">栈是一种只能从表的一端存取数据且遵循 “先进后出” 原则的线性存储结构</font>。</p><p>通常，栈的开口端被称为<font color="green">栈顶</font>；相应地，封口端被称为<font color="green">栈底</font>。因此，栈顶元素指的就是距离栈顶最近的元素，拿下图来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，下图中的栈底元素为元素。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNSExRTy5naWY" alt="1MHLQO.gif"></p><h3 id="进栈和出栈"><a href="#进栈和出栈" class="headerlink" title="进栈和出栈"></a>进栈和出栈</h3><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：</p><ul><li>向栈中添加元素，此过程被称为”<font color="green">进栈</font>“（<font color="green">入栈</font>或<font color="green">压栈</font>）；</li><li>从栈中提取出指定元素，此过程被称为”<font color="green">出栈</font>“（或<font color="green">弹栈</font>）；</li></ul><h3 id="栈的具体实现"><a href="#栈的具体实现" class="headerlink" title="栈的具体实现"></a>栈的具体实现</h3><p>栈是一种 “特殊” 的线性存储结构，因此栈的具体实现有以下两种方式：</p><ol><li><font color="blue">顺序栈</font>：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；</li><li><font color="blue">链栈</font>：采用链式存储结构实现栈结构；<blockquote><p>两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。</p></blockquote></li></ol><h3 id="顺序栈基本操作"><a href="#顺序栈基本操作" class="headerlink" title="顺序栈基本操作"></a>顺序栈基本操作</h3><p><font color="blue">顺序栈</font>，即用<font color="blue">顺序表</font>实现栈存储结构。通过前面介绍我们知道，使用栈存储结构操作数据元素必须遵守 “先进后出” 的原则，下面就 “如何使用顺序表模拟栈以及实现对栈中数据的基本操作（出栈和入栈）” 给大家做一些介绍。</p><p>如果你仔细观察顺序表（底层实现是<font color="blue">数组</font>）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。</p><p>例如，我们先使用顺序表（a 数组）存储<code>{1,2,3,4}</code>，存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNYlJodC5naWY" alt="在这里插入图片描述"><br>同样，使用栈存储结构存储<code>{1,2,3,4}</code>，其存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNYm9uZy5naWY" alt="在这里插入图片描述"><br>通过上面两张图对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。</p><blockquote><p>从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。</p></blockquote><p>了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有”<font color="red">先进后出</font>“的要求，如果想将图中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。</p><p>这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是”空栈”。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。</p><h4 id="顺序栈元素”入栈”"><a href="#顺序栈元素”入栈”" class="headerlink" title="顺序栈元素”入栈”"></a>顺序栈元素”入栈”</h4><p>比如，还是模拟栈存储<code>{1,2,3,4}</code> 的过程。最初，栈是”空栈”，即数组是空的，top 值为初始值 -1，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcVZnSy5naWY" alt="在这里插入图片描述"><br>首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcVpqTy5naWY" alt="在这里插入图片描述"><br>采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcU1FZC5naWY" alt="在这里插入图片描述"></p><p>因此，C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元素elem进栈，a为数组，top值为当前栈的栈顶位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> top,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line">    a[++top]=elem;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。</p><h4 id="顺序栈元素”出栈”"><a href="#顺序栈元素”出栈”" class="headerlink" title="顺序栈元素”出栈”"></a>顺序栈元素”出栈”</h4><p>其实，top 变量的设置对模拟数据的 “入栈” 操作没有实际的帮助，它是为实现数据的 “出栈” 操作做准备的。</p><p>比如，将上图中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如下图a) 和 下图b) 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzI5LzFNcXdVcy5naWY" alt="在这里插入图片描述"></p><blockquote><p>注意，上图数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。</p></blockquote><p>元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素出栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> * a,<span class="keyword">int</span> top)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top==<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"空栈"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"弹栈元素：%d\n"</span>,a[top]);</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>代码中的 if 语句是为了防止用户做 “栈中已无数据却还要数据出栈” 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。</p><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的利用C语言简单的实现顺序栈以及向大家介绍了栈的特点，完整的代码已经上传到github,<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E9%A1%BA%E5%BA%8F%E6%A0%88/SequenceStack.c" target="_blank" rel="noopener">C语言实现顺序栈</a> 欢迎大家Star ! 有什么写的不好的地方希望大家在评论区留言，我加以改正，我们一起交流，一起进步啊！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 顺序栈 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现顺序栈</title>
      <link href="/posts/dd845106.html"/>
      <url>/posts/dd845106.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>在写C语言实现<font color="red">顺序栈</font>的时候,我已经向大家介绍了<font color="blue">栈的特点</font>以及介绍了栈的相关操作，并利用C语言实现了相关算法。在这里小编就不在继续给大家介绍了，需要温习的可以看看之前的文章,下面是链接<a href="https://www.xiangjunhong.com/posts/278598dc.html" class="LinkCard">C语言实现顺序栈</a>在这篇博客我就给大家分享一下利用C++模板类来实现顺序栈的相关操作，主要实现了以下功能：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzMxLzE4VmZZOS5wbmc?x-oss-process=image/format,png" alt="18VfY9.png"></p><a id="more"></a><h3 id="私有成员的封装"><a href="#私有成员的封装" class="headerlink" title="私有成员的封装"></a>私有成员的封装</h3><p>根据顺序栈的特点，封装了<font color="green">elements</font>这样的数组存放栈中元素，<font color="green">top</font>代表栈顶指针，<font color="green">maxSize</font>代表栈的最大容纳量，其中还封装了一个<font color="green">overflowProcess()</font>函数来对栈的溢出进行处理。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">T* elements;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span> maxSize;<span class="comment">//栈的最大容纳元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflowProcess</span><span class="params">()</span></span>;<span class="comment">//栈的溢出处理操作</span></span><br></pre></td></tr></table></figure></div><p>overflowProcess()函数的实现如下<br>在栈满的情况下，按照最大容纳量的2倍来扩展栈的容纳量，重新分配空间赋值给elements数组。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:overflowProcess()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;maxSize = <span class="keyword">int</span> (<span class="number">2</span>*<span class="keyword">this</span>-&gt;maxSize);</span><br><span class="line">T * temp = <span class="keyword">new</span> T [<span class="keyword">this</span>-&gt;maxSize];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="keyword">this</span>-&gt;top ; i++)&#123;</span><br><span class="line">temp[i] = <span class="keyword">this</span>-&gt;elements[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []elements;       <span class="comment">//释放原来的空间</span></span><br><span class="line"><span class="keyword">this</span> -&gt;elements = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="公有函数的封装"><a href="#公有函数的封装" class="headerlink" title="公有函数的封装"></a>公有函数的封装</h3><p>栈的操作自然少不了<code>进栈，出栈，判空，判满</code>等相关操作，下面分别给大家进行介绍：</p><h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>默认最大容纳量为10，可自行进行调整。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">Stack</span>&lt;T&gt;:</span>:Stack()   </span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">this</span> -&gt;maxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;elements = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt;maxSize];</span><br><span class="line"><span class="keyword">if</span>(elements==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="有参构造函数"><a href="#有参构造函数" class="headerlink" title="有参构造函数"></a>有参构造函数</h4><p>根据自身传递size大小来分配储存空间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Stack(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span> -&gt;maxSize = size;</span><br><span class="line"><span class="keyword">this</span> -&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span> -&gt;elements = <span class="keyword">new</span> T[<span class="keyword">this</span> -&gt;maxSize];</span><br><span class="line"><span class="keyword">if</span>(elements==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“入栈”操作"><a href="#顺序栈的“入栈”操作" class="headerlink" title="顺序栈的“入栈”操作"></a>顺序栈的“入栈”操作</h4><p>入栈操作前，首先要判断栈是否溢出，如果栈isFull(),则进行溢出处理，否则将其插入到栈顶。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Push(<span class="keyword">const</span> T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isFull()==<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"The stack is full , so need to enlarge 2x!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">overflowProcess();<span class="comment">//溢出处理，调整空间大小</span></span><br><span class="line">elements[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">elements[++top]=x;<span class="comment">//将x入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“出栈”操作"><a href="#顺序栈的“出栈”操作" class="headerlink" title="顺序栈的“出栈”操作"></a>顺序栈的“出栈”操作</h4><p>栈顶元素出栈，如果栈为空返回false;若栈不为空，栈顶元素出栈，top指针减一就OK啦。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Pop(T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">x=getTopelements();</span><br><span class="line"></span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“判满”"><a href="#顺序栈的“判满”" class="headerlink" title="顺序栈的“判满”"></a>顺序栈的“判满”</h4><p>判断栈是否满，只需要将top指针与最大容纳量进行比较就行，如果满返回true,未满返回false</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isFull()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()&lt;<span class="keyword">this</span>-&gt;getMaxsize()<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序栈的“判空”"><a href="#顺序栈的“判空”" class="headerlink" title="顺序栈的“判空”"></a>顺序栈的“判空”</h4><p>判断栈是否空，直接判断top指针，如果满返回true,未满返回false</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="打印顺序栈的元素"><a href="#打印顺序栈的元素" class="headerlink" title="打印顺序栈的元素"></a>打印顺序栈的元素</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:print()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"This Stack is empty!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"栈的元素为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getTop();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[i]&lt;&lt;<span class="string">"]&lt;-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[getTop()]&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">坚持就是胜利!</font></strong><br>到这里C++实现顺序栈的文章就结束了，相对而言还是挺简单的，本来打算把顺序栈的应用也写在这篇文章一起的，工作量实在挺大，也害怕大家接受不了，所以我就后面在更新喽。完整的代码我已经上传到github(<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E9%A1%BA%E5%BA%8F%E6%A0%88" target="_blank" rel="noopener">C++实现顺序栈</a>)，欢迎Star!我们一起讨论，我也是一个学生，如果有写的不好的地方，还忘各路大神提出来，在下面评论区留言，我加以改正！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 顺序栈 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallels Desktop的安装</title>
      <link href="/posts/201e1121.html"/>
      <url>/posts/201e1121.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p><font color="green">Parallels Desktop</font>是一款运行在 Mac 电脑上的极为优秀的<font color="red">虚拟机</font>软件。用户可以在 Mac OS X 下非常方便运行 Windows、Linux 等操作系统及应用。用户不必繁琐重复地重启电脑即可在 Win 与 Mac 之间切换甚至同时使用它们。</p><h3 id="Parallels-Desktop的安装"><a href="#Parallels-Desktop的安装" class="headerlink" title="Parallels Desktop的安装"></a>Parallels Desktop的安装</h3><p>小编考虑到大家可能找不到资源，就特地把自己的分享给大家：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA" target="_blank" rel="noopener">https://pan.baidu.com/s/1Wc-g1VXUXPH1xqSOUTimfA</a><br>密码:2k25</p></blockquote><a id="more"></a><p>下载之后先不要急着安装，现在安装肯定会报软件解析错误等相关的警告，这是因为没有设置<strong>mac安装软件允许任何来源</strong></p><p>解决允许任何来源问题办法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 系统偏好设置 -&gt; 安全性与隐私 -&gt; 通用 -&gt; 选择“任何来源”</span><br></pre></td></tr></table></figure></div><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.  显示&quot;任何来源&quot;选项在控制台中执行：</span><br><span class="line">    sudo spctl --master-disable</span><br></pre></td></tr></table></figure></div><p>mac安装软件允许任何来源之后就可以安装软件了，打开dmg文件后双击箭头所指，按照提示一步步点击确定就可以<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzIyLzFBY3VDRC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><h3 id="Windows10-镜像文件"><a href="#Windows10-镜像文件" class="headerlink" title="Windows10 镜像文件"></a>Windows10 镜像文件</h3><p>根据自己电脑的情况选择32bit或者64bit的Win10文件，Mac运行内存有16G可以选择64bit，小编当然是选择了32bit,对Windows不想给它分多了,毕竟Mac=亲生的 Windows=捡来的</p><p>仍然把我的镜像文件分享给大家，给大家省点麻烦</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1ODUGILKYN_FeVgOPPkX44A" target="_blank" rel="noopener">https://pan.baidu.com/s/1ODUGILKYN_FeVgOPPkX44A</a><br>密码:ow8b</p></blockquote><p>镜像文件下载好好之后就选择相应的镜像文件，之后安装助手就会帮你搞定了，你只需要静静地等待，安装成功后如下图：</p><p>是不是看起来就很nice!</p><p><img src="https://s2.ax1x.com/2020/01/22/1A25Ax.png" alt="1A25Ax.png"></p><h3 id="开启体验之旅"><a href="#开启体验之旅" class="headerlink" title="开启体验之旅"></a>开启体验之旅</h3><p>理论上Parallels Desktop可以让你在苹果的Mac OS系统上同时运行多个 Windows系统，你可以随意在它们之间进行切换，并且能够运行各个平台上几乎所有的应用程序和游戏，让原本枯燥的Mac变得可玩性极高。</p><p>另外，PD支持各种 USB 硬件设备，并且支持 USB-C / USB 3.0。用户可以随意将 USB 设备分配给 Mac 或分配到虚拟机系统里去。例如手机刷ROM、连接老式打印机、使用U盘加密狗等等。</p><p>性能方面，Parallels Desktop支持 DirectX 11，如果你之前对比过其它虚拟机软件，相信你肯定有所感触，PD 在 3D 游戏和图形性能方面比 VMware Fusion、VirtualBox等更加流畅和出色，而且新版本对《守望先锋》、XBox One 游戏串流等进行了专项优化，来保证游戏的流畅性。<br>另外，Parallels Desktop还提供了“一键自动优化”功能，你可以根据不同的用途（效能应用程序、设计或开发，游戏）对 PD 虚拟机进行调整和优化，让它更加适合你的工作场景(我选择的设计开发方面)</p><p><strong><em>实用的特色功能</em></strong><br>值得一提的是，在Parallels Desktop中还提供了不少非常实用的特色功能，如果能够熟练掌握并加以应用，可以大大提升用户的工作效率。</p><ol><li><p><strong>“融合模式”无缝衔接Windows和Mac OS</strong><br>最新版PD支持“融合模式”，你可以将Windows 的软件任意拖拽到Mac当中进行使用，例如PPT、Word等等Office软件。PD13对界面进行了优化，将两个系统常用的菜单按钮和界面融为一体，此时你完全感觉不出自己是在Mac中使用Windows，你也可以以全屏模式来运行 Windows。不用时只需轻松点击右上角的退出融合模式进行关闭。</p></li><li><p><strong>让时光倒流的“快照功能”</strong><br>你可能喜欢尝试各种新软件，或者喜欢折腾系统、应用软件。然而一些不完善的测试版软件、非官方渠道下载的小程序等等都有可能对系统留下垃圾或造成不良影响。这时候，Parallels Desktop的快照功能就派上用场了。</p></li></ol><p>你可以随时给当前的虚拟机系统“拍”上一张快照，它能够帮你备份当前系统的整个状态 ，例如未关闭的word文档等等。然后你就可以任意折腾你的系统了，等想恢复系统原来的状态时，只需要在菜单里选择“管理快照”，找到刚才拍过的快照进行恢复就可以了。</p><ol start="3"><li><strong>懒人福利“Parallel Toolbox 工具箱”</strong><br>新版PD新增了一款独立应用——Parallel Toolbox（一键式实用工具集），可以帮助用户方便地截图、录制屏幕、制作 GIF等，非常方便实用，可以让你的工作效率大幅提升。</li></ol><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次分享给大家的我认为还不错的Mac虚拟机，我后面还会继续分享其他的玩转Mac技巧，如果觉得这篇文章对你有的话就给我一个小小的赞吧，你的鼓励就是我前进的动力。后面我继续加油，坚持就是胜利！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 玩转Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Parallels Desktop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现双向链表</title>
      <link href="/posts/beb5106a.html"/>
      <url>/posts/beb5106a.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>目前我们所学到的<font color="blue">链表</font>，无论是动态链表还是<font color="blue">静态链表</font>，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为<font color="green">单向链表</font>（或<font color="green">单链表</font>）。</p><p>虽然使用单链表能 100% 解决逻辑关系为 “一对一” 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，如果算法中需要大量地找某指定结点的前趋结点，使用单链表无疑是灾难性的，因为单链表更适合 “从前往后” 找，而 “从后往前” 找并不是它的强项。</p><p>为了能够高效率解决类似的问题，本篇文章我们一起来讨论<font color="green">双向链表</font>（简称<font color="green">双链表</font>）。<br>从名字上理解双向链表，即链表是 “双向” 的,如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4S3dqSi5naWY" alt="图一"></p><a id="more"></a><blockquote><p>双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要。</p></blockquote><p>从上图中可以看到，双向链表中各节点包含以下 3 部分信息（如下图 所示）：</p><ul><li><font color="green">指针域 </font>：用于指向当前节点的直接前驱节点；</li><li><font color="green">数据域 </font>：用于存储数据元素。</li><li><font color="green">指针域</font>：用于指向当前节点的直接后继节点；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4SzdVUC5naWY" alt="在这里插入图片描述"><br>因此，双链表的节点结构用 C 语言实现为:<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span><span class="comment">//指向直接前趋</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span><span class="comment">//指向直接后继</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure></div></li></ul><h4 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h4><p>同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。</p><p>需要注意的是，与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：</p><blockquote><ol><li>将新节点的 prior 指针指向直接前驱节点；</li><li>将直接前驱节点的 next 指针指向新节点；</li></ol></blockquote><p>这里给出创建双向链表的 C 语言实现代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line">head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建链表第一个结点（首元结点）</span></span><br><span class="line">head-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;data=<span class="number">1</span>;</span><br><span class="line">Node * <span class="built_in">list</span>=head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="comment">//创建并初始化一个新结点</span></span><br><span class="line">Node * body=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">body-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;data=i;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">list</span>-&gt;next=body;<span class="comment">//直接前趋结点的next指针指向新结点</span></span><br><span class="line">body-&gt;prior=<span class="built_in">list</span>;<span class="comment">//新结点指向直接前趋结点</span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">prior</span>;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">//双链表的创建函数</span></span><br><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>;</span><br><span class="line"><span class="comment">//输出双链表的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Node * head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个头指针</span></span><br><span class="line">Node * head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//调用链表创建函数</span></span><br><span class="line">head=initNode(head);</span><br><span class="line"><span class="comment">//输出创建好的链表</span></span><br><span class="line">display(head);</span><br><span class="line"><span class="comment">//显示双链表的优点</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表中第 4 个节点的直接前驱是：%d"</span>,head-&gt;next-&gt;next-&gt;next-&gt;prior-&gt;data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node* <span class="title">initNode</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个首元节点，链表的头指针为head</span></span><br><span class="line">head=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line"><span class="comment">//对节点进行初始化</span></span><br><span class="line">head-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">head-&gt;data=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点</span></span><br><span class="line">Node * <span class="built_in">list</span>=head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="comment">//创建新的节点并初始化</span></span><br><span class="line">Node * body=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">body-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">body-&gt;data=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新节点与链表最后一个节点建立关系</span></span><br><span class="line"><span class="built_in">list</span>-&gt;next=body;</span><br><span class="line">body-&gt;prior=<span class="built_in">list</span>;</span><br><span class="line"><span class="comment">//list永远指向链表中最后一个节点</span></span><br><span class="line"><span class="built_in">list</span>=<span class="built_in">list</span>-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回新创建的链表</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Node * head)</span></span>&#123;</span><br><span class="line">Node * temp=head;</span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="comment">//如果该节点无后继节点，说明此节点是链表的最后一个节点</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp-&gt;data);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d &lt;-&gt; "</span>,temp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果：</p><blockquote><p>1 &lt;-&gt; 2 &lt;-&gt; 3 &lt;-&gt; 4 &lt;-&gt; 5<br>链表中第 4 个节点的直接前驱是：3</p></blockquote><h4 id="双向链表基本操作"><a href="#双向链表基本操作" class="headerlink" title="双向链表基本操作"></a>双向链表基本操作</h4><p>下面继续讨论有关双向链表的一些基本操作，即如何在双向链表中添加、删除、查找或更改数据元素。</p><p>创建好的双向链表如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UVF3bi5naWY" alt="在这里插入图片描述"></p><h5 id="双向链表添加节点"><a href="#双向链表添加节点" class="headerlink" title="双向链表添加节点"></a>双向链表添加节点</h5><p>根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：<br><strong>添加至表头</strong><br>将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。</p><p>换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：</p><blockquote><ol><li>temp-&gt;next=head; head-&gt;prior=temp;</li><li>将 head 移至 temp，重新指向新的表头；</li></ol></blockquote><p>例如，将新元素 7 添加至双链表的表头，则实现过程如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UXNmSy5naWY" alt="在这里插入图片描述"><br><strong>添加至表的中间位置</strong><br>同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如下图所示：</p><blockquote><ol><li>新节点先与其直接后继节点建立双层逻辑关系；</li><li>新节点的直接前驱节点与之建立双层逻辑关系；</li></ol></blockquote><p><a href="https://imgchr.com/i/lxQWmd" target="_blank" rel="noopener"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UVdtZC5naWY" alt="lxQWmd.gif"></a><br><strong>添加至表尾</strong><br>与添加到表头是一个道理，实现过程如下（如下图所示）：</p><blockquote><ol><li>找到双链表中最后一个节点；</li><li>让新节点与最后一个节点进行双层逻辑关系；</li></ol></blockquote><p><a href="https://imgchr.com/i/lxQ2OH" target="_blank" rel="noopener"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4UTJPSC5naWY" alt="lxQ2OH.gif"></a></p><p>因此，双向链表添加数据的 C 语言代码，参考代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">insertNode</span><span class="params">(Node * head,<span class="keyword">int</span> data,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line"><span class="comment">//新建数据域为data的结点</span></span><br><span class="line">Node * temp=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">temp-&gt;data=data;</span><br><span class="line">temp-&gt;prior=<span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//插入到链表头，要特殊考虑</span></span><br><span class="line"><span class="keyword">if</span> (add==<span class="number">1</span>) &#123;</span><br><span class="line">temp-&gt;next=head;</span><br><span class="line">head-&gt;prior=temp;</span><br><span class="line">head=temp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node * body=head;</span><br><span class="line"><span class="comment">//找到要插入位置的前一个结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add<span class="number">-1</span>; i++) &#123;</span><br><span class="line">body=body-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断条件为真，说明插入位置为链表尾</span></span><br><span class="line"><span class="keyword">if</span> (body-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;prior=body;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">body-&gt;next-&gt;prior=temp;</span><br><span class="line">temp-&gt;next=body-&gt;next;</span><br><span class="line">body-&gt;next=temp;</span><br><span class="line">temp-&gt;prior=body;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表删除节点"><a href="#双向链表删除节点" class="headerlink" title="双向链表删除节点"></a>双向链表删除节点</h5><p>双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。<br>例如，删除上面图中的元素2，如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE2L2x4bGlYNC5naWY" alt="lxliX4.gif">]<br>双向链表删除节点的 C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除结点的函数，data为要删除结点的数据域的值</span></span><br><span class="line"><span class="function">Node * <span class="title">delNode</span><span class="params">(Node * head,<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">Node * temp=head;</span><br><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="comment">//判断当前结点中数据域和data是否相等，若相等，摘除该结点</span></span><br><span class="line"><span class="keyword">if</span> (temp-&gt;data==data) &#123;</span><br><span class="line">temp-&gt;prior-&gt;next=temp-&gt;next;</span><br><span class="line">temp-&gt;next-&gt;prior=temp-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"链表中无该数据元素"</span>);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表查找节点"><a href="#双向链表查找节点" class="headerlink" title="双向链表查找节点"></a>双向链表查找节点</h5><p>通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</p><p>C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//head为原双链表，elem表示被查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectElem</span><span class="params">(Node * head,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line"><span class="comment">//新建一个指针t，初始化为头指针 head</span></span><br><span class="line">Node * t=head;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (t) &#123;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;data==elem) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="双向链表更改节点"><a href="#双向链表更改节点" class="headerlink" title="双向链表更改节点"></a>双向链表更改节点</h5><p>更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。</p><p>实现此操作的 C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值</span></span><br><span class="line"><span class="function">Node *<span class="title">amendElem</span><span class="params">(Node * p,<span class="keyword">int</span> add,<span class="keyword">int</span> newElem)</span></span>&#123;</span><br><span class="line">Node * temp=p;</span><br><span class="line"><span class="comment">//遍历到被删除结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add; i++) &#123;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;data=newElem;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong><br>基本上写到这里这篇关于C语言实现双向链表的文章就结束了，总的实现代码已经push到github，喜欢的小伙伴欢迎Star！<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">传送门</a>，小编如果有什么写的不好的地方，欢迎大家留言提出来，多多指教，我们一起进步！明天继续更新C++语言实现双向链表，坚持就是胜利！加油！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C </category>
          
          <category> 双向链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向链表 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++线性表的链式存储结构</title>
      <link href="/posts/6a752619.html"/>
      <url>/posts/6a752619.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>C++实现线性表的链式存储结构：</p><p>为了<font color="green">解决顺序存储不足</font>：用线性表另外一种结构-<font color="red">链式存储</font>。在顺序存储结构(数组描述)中，元素的地址是由数学公式决定的，而在链式储存结构中，元素的地址是随机分布的，每个元素都有一个明确的指针指向线性表的下一个元素的位置（即地址）。</p><p><font color="green">线性表的链式存储结构的特点</font>是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。在顺序结构中，每个数据元素只需要存数据元素信息就行了，而在链式结构中，除了存储数据元素信息外，还要存储它的后继元素的存储地址。所以一般结点包括两个信息：数据和指针。链表就是n个节点组成的，<font color="red">如果每个结点只包含一个指针，那么就是单链表</font>。</p><p><font color="green">有头有尾</font>：我们把链表中第一个结点的存储位置叫作头指针，那么整个链表的存取就必须是从头指针开始进行的。而线性链表的最后一个结点指针为空（NULL）。从下图中可以看到，结点都是由两部分组成，数据域和指针域。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE1L2xYbG1hNi5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><a id="more"></a><p>有时，为了更方便对链表进行操作，会在单链表的第一个结点前加一个头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表长度等附加信息，头结点的指针域存储指向第一个结点的指针。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE1L2xYbERNai5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>头指针和头结点的异同</strong></p><ol><li><p>指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。</p></li><li><p>头指针具有标识作用，所以常用头指针冠以链表的名字。</p></li><li><p><font color="red">无论链表是否为空，头指针均不为空。头指针是链表的必要元素。</font></p><p><font color="red">（这句话真的歧义，若没有头结点，头指针head指向第一个节点，当空表时，head=NULL。应该是必须要有头指针。）</font></p><div class="note info no-icon"><h4 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h4><p>（1）头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（也可存放链表的长度）</p><p>（2）有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了。</p><p>（3）头结点不一定是链表必须的要素。</p></div><p>链式存储结构的线性表进行的基本操作。主要包括：</p></li></ol><ul><li>插入：操作方式为在指定元素前插入、在指定元素之后插入、在指定位置完成插入</li><li>删除：操作方式可分为删除指定元素、删除指定位置的元素，删除第一个元素，删除最后一个元素</li><li>显示数据</li><li>查找：查询指定的元素（可根据某个数据成员完成查询操作）</li><li>定位操作：定位指定元素的序号</li><li>更新：修改指定元素的数据</li><li>数据文件的读写操作</li><li>计算链表的长度</li></ul><p><img src="https://img-blog.csdnimg.cn/20190920120609137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="这是测试函数写的一个大概功能展示"></p><h4 id="定义一个结点类"><a href="#定义一个结点类" class="headerlink" title="定义一个结点类"></a>定义一个结点类</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Define a friend class to facilitate direct manipulation of data*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkList</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>&lt;T&gt;;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T _data;</span><br><span class="line">LinkNode&lt;T&gt;  *_next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkNode(T x ) </span><br><span class="line">&#123;</span><br><span class="line">_data = x;</span><br><span class="line">_next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="链表的主要函数构成"><a href="#链表的主要函数构成" class="headerlink" title="链表的主要函数构成"></a>链表的主要函数构成</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">LinkNode&lt;T&gt; * _head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkList()</span><br><span class="line">&#123;_head = <span class="literal">NULL</span>;&#125;</span><br><span class="line">LinkNode&lt;T&gt;* _CreateNode(<span class="keyword">const</span> T&amp; x);<span class="comment">//Create a new node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(LinkNode&lt;T&gt;* &amp;cur)</span></span>;<span class="comment">//Delete a new node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//tail insertion to create a linked list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PushFront</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//Head insertion to create a linked list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopBack</span><span class="params">()</span></span>;<span class="comment">//Remove an element from the tail</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopFront</span><span class="params">()</span></span>;<span class="comment">//Remove an element from the head</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span></span>;<span class="comment">//Find the length of the linear table</span></span><br><span class="line">LinkNode&lt;T&gt;* Find(T x);<span class="comment">//Find a number</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_right</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//Insert after the nth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_cur</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//Insert at the specified location</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_left</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//Insert in front of the nth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete_pos</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;<span class="comment">//Delete the nth element</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete_val</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//Delete specified element</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">const</span> T &amp;x,<span class="keyword">const</span> T &amp;y)</span></span>;<span class="comment">//Update an element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">located</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span>;<span class="comment">//Locate the serial number of the specified element</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>;<span class="comment">// Print linear table</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writeToFile</span><span class="params">()</span></span>;<span class="comment">//Write file</span></span><br><span class="line"><span class="function">T* <span class="title">readFromFile</span><span class="params">()</span></span>;<span class="comment">//Read in data file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readlen</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h4 id="各个函数的实现"><a href="#各个函数的实现" class="headerlink" title="各个函数的实现"></a>各个函数的实现</h4><h5 id="Print-函数"><a href="#Print-函数" class="headerlink" title="Print()函数"></a>Print()函数</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:Print()</span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt;  *tmp = _head;</span><br><span class="line"><span class="keyword">while</span> (tmp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tmp-&gt;_data &lt;&lt; <span class="string">"--&gt;"</span>;</span><br><span class="line">tmp = tmp-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="创建一个新的结点，并为其分配空间"><a href="#创建一个新的结点，并为其分配空间" class="headerlink" title="创建一个新的结点，并为其分配空间"></a>创建一个新的结点，并为其分配空间</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkNode</span>&lt;T&gt;* <span class="title">LinkList</span>&lt;T&gt;:</span>: _CreateNode(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt;* tmp = <span class="keyword">new</span> LinkNode&lt;T&gt;(x);</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="清除某一个节点，释放空间"><a href="#清除某一个节点，释放空间" class="headerlink" title="清除某一个节点，释放空间"></a>清除某一个节点，释放空间</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:clear(LinkNode&lt;T&gt; *&amp;cur)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">delete</span>  cur;</span><br><span class="line">cur = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="获得链表的长度"><a href="#获得链表的长度" class="headerlink" title="获得链表的长度"></a>获得链表的长度</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Length()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = readlen();<span class="comment">/*调用一个读文件的函数，来判别链表状态，Call a function that reads the file to determine the state of the linked list*/</span></span><br><span class="line"><span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * begin = _head;</span><br><span class="line"><span class="keyword">while</span> (begin != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">begin = begin-&gt;_next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="前插法建立链表"><a href="#前插法建立链表" class="headerlink" title="前插法建立链表"></a>前插法建立链表</h4><p>从一个空表开始，重复读入数据，执行以下两步<br>（1）生成新的结点，将读入数据存放在新节点的的_data域中<br>（2）将该节点插入到链表的前端，直到读入到结束符为止。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>: PushFront(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_head = _CreateNode(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt;  * prev = _CreateNode(x);</span><br><span class="line">prev-&gt;_next = _head;</span><br><span class="line">_head = prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="用后插法建立链表"><a href="#用后插法建立链表" class="headerlink" title="用后插法建立链表"></a>用后插法建立链表</h4><p>需要设置一个尾部指针end,总是指向新链表的最后一个节点，新节点链接到它所指链尾节点的后面。end最初要置于附加头节点位置</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:PushBack(<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_head = _CreateNode(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * end = _head;</span><br><span class="line"><span class="keyword">while</span> (end-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">end = end-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">end-&gt;_next = _CreateNode(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="从尾部删除一个数据"><a href="#从尾部删除一个数据" class="headerlink" title="从尾部删除一个数据"></a>从尾部删除一个数据</h4><p>考虑只有一个节点情况，多个结点的情况。<br>多个结点，首先找到尾部元素，然后调用clear()函数，清理掉尾部第一个元素</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>: PopBack()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_head-&gt;_next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">clear(_head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * temp = _head;</span><br><span class="line">LinkNode&lt;T&gt; * end = _head;</span><br><span class="line"><span class="keyword">while</span> (end-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = end;</span><br><span class="line">end = end-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">clear(end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="从头部删除一个元素"><a href="#从头部删除一个元素" class="headerlink" title="从头部删除一个元素"></a>从头部删除一个元素</h4><p>实现方法和从尾部删除一个元素基本相似，不多加以解释</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:PopFront()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_head -&gt;_next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">clear(_head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * tmp = _head;</span><br><span class="line">_head = _head-&gt;_next;</span><br><span class="line">clear(tmp);</span><br><span class="line">tmp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找某一个元素"><a href="#查找某一个元素" class="headerlink" title="查找某一个元素"></a>查找某一个元素</h4><p>遍历整个链表，并将其数据_data与x进行比对，如果是其他类型就需要重载运算符==</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkNode</span>&lt;T&gt;* <span class="title">LinkList</span>&lt;T&gt; :</span>:Find (T x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty,not found!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_head-&gt;_data==x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * n = _head ;</span><br><span class="line"><span class="keyword">while</span> (n-&gt;_next != <span class="literal">NULL</span> &amp;&amp; n-&gt;_data != x )</span><br><span class="line">&#123;</span><br><span class="line">n = n-&gt;_next;</span><br><span class="line"><span class="keyword">if</span> (n-&gt;_data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="在第pos个元素后插入一个新元素"><a href="#在第pos个元素后插入一个新元素" class="headerlink" title="在第pos个元素后插入一个新元素"></a>在第pos个元素后插入一个新元素</h4><p>创建一个新的结点，通过移动begin指针，pos控制指针最终位置，将新元素插入到之后</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Insert_right(<span class="keyword">int</span> pos,<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len = Length();</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * begin = _head;</span><br><span class="line">LinkNode&lt;T&gt; * tmp = _CreateNode(x);</span><br><span class="line"><span class="keyword">while</span> (--pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">begin = begin-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;_next = begin-&gt;_next;</span><br><span class="line">begin-&gt;_next = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input Error!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="在第pos个元素插入一个新元素"><a href="#在第pos个元素插入一个新元素" class="headerlink" title="在第pos个元素插入一个新元素"></a>在第pos个元素插入一个新元素</h4><p>因为写了一个在后面插入的函数，为了偷懒，就直接调用了Insert_right()这个函数</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Insert_cur(<span class="keyword">int</span> pos,<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len = Length();</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Insert_right(pos<span class="number">-1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input Error!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="在第pos个元素前插入一个新元素"><a href="#在第pos个元素前插入一个新元素" class="headerlink" title="在第pos个元素前插入一个新元素"></a>在第pos个元素前插入一个新元素</h4><p>创建一个新的结点，通过移动begin指针，pos控制指针最终位置，将新元素插入到之前，与插入之后实现方法基本类似，只是需要注意pos的控制</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Insert_left(<span class="keyword">int</span> pos,<span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len = Length();</span><br><span class="line"><span class="keyword">int</span> temp=pos<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * begin = _head;</span><br><span class="line">LinkNode&lt;T&gt; * tmp = _CreateNode(x);</span><br><span class="line"><span class="keyword">while</span> (--temp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">begin = begin-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tmp-&gt;_next = begin-&gt;_next;</span><br><span class="line">begin-&gt;_next = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input Error!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除第pos个元素"><a href="#删除第pos个元素" class="headerlink" title="删除第pos个元素"></a>删除第pos个元素</h4><p>依旧利用pos控制指针位置，然后删除就ok</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Delete_pos(<span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> len = Length();</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_head-&gt;_next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">clear(_head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * begin = _head-&gt;_next;</span><br><span class="line">LinkNode&lt;T&gt; * temp = _head;</span><br><span class="line">pos = pos - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (--pos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (begin-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">begin = begin-&gt;_next;</span><br><span class="line">temp = temp-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;_next = begin-&gt;_next;</span><br><span class="line">begin-&gt;_next = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Input Error!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找某一个元素位置并返回其位置"><a href="#查找某一个元素位置并返回其位置" class="headerlink" title="查找某一个元素位置并返回其位置"></a>查找某一个元素位置并返回其位置</h4><p>用一个temp进行计数，遍历整个链表，一一进行比对其——data数据（若是其它类型就需要重载运算符“=”，后面的函数提到比对的都需要实现，才能进行比对）比对成功就返回，其它类的实现依然需要重载</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:located(<span class="keyword">const</span> T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty,not found!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_head-&gt;_data==x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * n = _head ;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n-&gt;_next != <span class="literal">NULL</span> &amp;&amp; n-&gt;_data != x )</span><br><span class="line">&#123;</span><br><span class="line">n = n-&gt;_next;</span><br><span class="line">temp++;</span><br><span class="line"><span class="keyword">if</span> (n-&gt;_data == x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> temp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定的元素遍历链表"><a href="#删除指定的元素遍历链表" class="headerlink" title="删除指定的元素遍历链表"></a>删除指定的元素遍历链表</h4><p>一一比对，找到就调用chear()函数删除并清理空间</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt; :</span>:Delete_val(<span class="keyword">const</span> T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_head-&gt;_next == <span class="literal">NULL</span> &amp;&amp; _head-&gt;_data == x)</span><br><span class="line">&#123;</span><br><span class="line">clear(_head);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_head-&gt;_data==x)&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(_head-&gt;_data!=x)<span class="keyword">break</span>;</span><br><span class="line">PopFront();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * n = Find(x);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">LinkNode&lt;T&gt; * begin = _head;</span><br><span class="line"><span class="keyword">while</span> (begin-&gt;_next != n &amp;&amp; begin-&gt;_next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">begin = begin-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">begin-&gt;_next = n-&gt;_next;</span><br><span class="line">clear(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="更新指定元素的值"><a href="#更新指定元素的值" class="headerlink" title="更新指定元素的值"></a>更新指定元素的值</h4><p>遍历链表，一一比对（<strong>前面提到了重载的</strong>），找到要更新的元素后就将新的值赋值给它</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:reset(<span class="keyword">const</span> T &amp;x,<span class="keyword">const</span> T &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_head == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"List is empty!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LinkNode&lt;T&gt; * n = Find(x);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="literal">NULL</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">n-&gt;_data=y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="链表的数据写入文件"><a href="#链表的数据写入文件" class="headerlink" title="链表的数据写入文件"></a>链表的数据写入文件</h4><p>能实现所有数据的储存，但是如果是其他类，写入没有问题，如果想从同一个文件中读入之前写的数据，遇到一些困难没有实现，但是基本数据类型是ok的,测试函数就表现出来了的（其它类的读入需要重载输入流，输出流）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:writeToFile()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">writefile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">len=Length();</span><br><span class="line">writefile&lt;&lt;len&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">LinkNode&lt;T&gt; * begin=_head;</span><br><span class="line"><span class="keyword">while</span>(begin!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">writefile&lt;&lt;begin-&gt;_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">begin=begin-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="从文件读入先前写入的数据，上面有提到只能满足基本数据类型"><a href="#从文件读入先前写入的数据，上面有提到只能满足基本数据类型" class="headerlink" title="从文件读入先前写入的数据，上面有提到只能满足基本数据类型"></a>从文件读入先前写入的数据，上面有提到只能满足基本数据类型</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span>* <span class="title">LinkList</span>&lt;T&gt;:</span>:readFromFile()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">readfile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">readfile&gt;&gt;length;</span><br><span class="line">T *temp=<span class="keyword">new</span> T[length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">readfile&gt;&gt;temp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="为了更好的操作，测试相关函数的功能，写了这样一个函数来从文件得到链表长度的函数"><a href="#为了更好的操作，测试相关函数的功能，写了这样一个函数来从文件得到链表长度的函数" class="headerlink" title="为了更好的操作，测试相关函数的功能，写了这样一个函数来从文件得到链表长度的函数"></a>为了更好的操作，测试相关函数的功能，写了这样一个函数来从文件得到链表长度的函数</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">LinkList</span>&lt;T&gt;:</span>:readlen()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">readfile</span><span class="params">(<span class="string">"data.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">readfile&gt;&gt;length;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="写到这基本上函数的功能都实现了，这个链表结构肯定有很多不完善的地方，第一次写博客，还望大家见谅。上面提到了其它类的重载问题，我就把写的一个point类分享给大家。"><a href="#写到这基本上函数的功能都实现了，这个链表结构肯定有很多不完善的地方，第一次写博客，还望大家见谅。上面提到了其它类的重载问题，我就把写的一个point类分享给大家。" class="headerlink" title="写到这基本上函数的功能都实现了，这个链表结构肯定有很多不完善的地方，第一次写博客，还望大家见谅。上面提到了其它类的重载问题，我就把写的一个point类分享给大家。"></a>写到这基本上函数的功能都实现了，这个链表结构肯定有很多不完善的地方，第一次写博客，还望大家见谅。上面提到了其它类的重载问题，我就把写的一个point类分享给大家。</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">double</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Point(<span class="keyword">double</span> x=<span class="number">0.0</span>,<span class="keyword">double</span> y=<span class="number">0.0</span>)</span><br><span class="line">&#123;<span class="keyword">this</span>-&gt;x=x,<span class="keyword">this</span>-&gt;y=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setdata</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">this</span>-&gt;x=a;<span class="keyword">this</span>-&gt;y=b;&#125;</span><br><span class="line">Point <span class="keyword">operator</span>=(Point a);<span class="comment">//重载运算符“=”</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>==(Point a);<span class="comment">//重载运算符“==”</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>!=(Point a);</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getx</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gety</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="comment">//重载输入流</span></span><br><span class="line"><span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is,Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">is&gt;&gt;p.x;</span><br><span class="line">is&gt;&gt;p.y;</span><br><span class="line"><span class="keyword">return</span> is;</span><br><span class="line">&#125;<span class="comment">//重载输出流</span></span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os,Point p)</span><br><span class="line">&#123;</span><br><span class="line">os&lt;&lt;<span class="string">"("</span>&lt;&lt;p.x&lt;&lt;<span class="string">","</span>&lt;&lt;p.y&lt;&lt;<span class="string">")"</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> Point Point::<span class="keyword">operator</span>=(Point a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;x=a.x;</span><br><span class="line"><span class="keyword">this</span>-&gt;y=a.y;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Point::<span class="keyword">operator</span>==(Point a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;x==a.getx()&amp;&amp;<span class="keyword">this</span>-&gt;y==a.gety())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Point::<span class="keyword">operator</span>!=(Point a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;x!=a.getx()&amp;&amp;<span class="keyword">this</span>-&gt;y!=a.gety())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;x!=a.getx()||<span class="keyword">this</span>-&gt;y!=a.gety())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="一个输入之后的展示"><a href="#一个输入之后的展示" class="headerlink" title="一个输入之后的展示"></a>一个输入之后的展示</h5><p><img src="https://img-blog.csdnimg.cn/20190920122835383.png" alt="int类型的展示"><br><img src="https://img-blog.csdnimg.cn/20190920122915876.png" alt="point类的实现"></p><div class="note success"><h4 id="继续加油！"><a href="#继续加油！" class="headerlink" title="继续加油！"></a>继续加油！</h4><p>以上是C++链式线性表使用过程中最常用的主要操作，相关完整代码已经push到GitHub，需要的小伙伴自行clone，如果觉得还不错的话，欢迎Star,这里是传送门<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C%2B%2B/%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8" target="_blank" rel="noopener">C++顺序表</a>，小编也是一名学生，如果有什么写的不对的地方，大家在下方给我留言，我们一起讨论！接下来我会更新其他相关算法，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性表 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++语言实现顺序表（顺序存储结构）</title>
      <link href="/posts/8cc73e65.html"/>
      <url>/posts/8cc73e65.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>C++语言实现顺序表</p><h3 id="顺序表的定义及其特点"><a href="#顺序表的定义及其特点" class="headerlink" title="顺序表的定义及其特点"></a>顺序表的定义及其特点</h3><p>顺序表的定义是:把线性表中的所有表项按照其逻辑顺序依次存储到从计算机存储中指定存储位置开始的一块连续的存储空间中。 这样,线性表中第一个表项的存储位置就是被指定的存储位置,第i个表项(2$\leq$ i $\leq$n)的存储位置紧接在第i一1个表项的存储位置的后面。假设顺序表中每个表项的数据类型为T,则每个表项所占用存储空间的大小(即字节数)大小相同,均为 sizeof(T),整个顺序表所占用存储空间的大小为n$\times$ sizeof(T),其中n表示线性表的长度。</p><p><code>顺序表的特点是:</code></p><blockquote><p>(1)在顺序表中,各个表项的逻辑顺序与其存放的物理顺序一致,即第i个表项存储于<br>第i个物理位置(1$\leq$ i $\leq$n).<br>(2)对顺序表中所有表项,既可以进行顺序访问,也可以进行随机访问。 也就是说,既可以从表的第一个表项开始逐个访问表项,也可以按照表项的序号(亦称为下标)直接访问表项。</p></blockquote><a id="more"></a><h3 id="顺序表类定义及其主要操作"><a href="#顺序表类定义及其主要操作" class="headerlink" title="顺序表类定义及其主要操作"></a>顺序表类定义及其主要操作</h3><h5 id="顺序表的类声明"><a href="#顺序表的类声明" class="headerlink" title="顺序表的类声明"></a>顺序表的类声明</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T *data;<span class="comment">//存放数据的动态数组</span></span><br><span class="line"><span class="keyword">int</span> maxSize;<span class="comment">//最大可容纳表项的项数</span></span><br><span class="line"><span class="keyword">int</span> last; <span class="comment">//当前已存表项的最后位置（从0开始）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reSize</span><span class="params">(<span class="keyword">int</span> newSize)</span></span>;<span class="comment">//改变数组空间大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SeqList(<span class="keyword">int</span> sz);          <span class="comment">//构造函数</span></span><br><span class="line">SeqList(SeqList&lt;T&gt;&amp; L);           <span class="comment">//复制构造函数</span></span><br><span class="line">~SeqList() &#123;<span class="keyword">delete</span>[ ] data;&#125;        <span class="comment">//析构函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span></span>&#123;<span class="comment">//求表最大容量</span></span><br><span class="line"><span class="keyword">return</span> maxSize;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> </span>&#123;<span class="comment">//计算表长度</span></span><br><span class="line"><span class="keyword">return</span> last+<span class="number">1</span>;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(T x)</span></span>;<span class="comment">//搜索x在表中位置，函数返回表项序号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Locate</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//定位第i个表项，函数返回表项序号</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> i, T&amp; x)</span></span>;<span class="comment">//插入x在第i个表项之后</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Remove</span><span class="params">(<span class="keyword">int</span> i, T&amp; x)</span></span>;<span class="comment">//删除第i个表项之后，通过x返回表项的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetData</span><span class="params">(<span class="keyword">int</span> i,T&amp; x)</span></span>;<span class="comment">//取第i个表项的值，以x引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SetData</span><span class="params">(<span class="keyword">int</span> i,T&amp; x)</span></span>;<span class="comment">//用x修改第i个表项的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;<span class="comment">//判断表是否空否，是返回true，否返回false</span></span><br><span class="line"><span class="keyword">return</span> (last==<span class="number">-1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsFull</span><span class="params">()</span></span>&#123;<span class="comment">//判读表是否满否，是返回true，否返回false</span></span><br><span class="line"><span class="keyword">return</span> (last = maxSize - <span class="number">1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;<span class="comment">//输入数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span>;<span class="comment">//打印数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h5 id="构造函数和复制构造函数"><a href="#构造函数和复制构造函数" class="headerlink" title="构造函数和复制构造函数"></a>构造函数和复制构造函数</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:SeqList(<span class="keyword">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">maxSize = sz;  last = <span class="number">-1</span>;</span><br><span class="line">data = <span class="keyword">new</span> T[maxSize];   <span class="comment">//创建表存储数组</span></span><br><span class="line"><span class="keyword">if</span> (data == <span class="literal">NULL</span>)   <span class="comment">//动态分配失败</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:SeqList(SeqList&lt;T&gt;&amp; L)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//复制构造函数，用参数表中给出的已有顺序表初始化新建的顺序表</span></span><br><span class="line">maxSize = L.Size();</span><br><span class="line">last = L.Length()<span class="number">-1</span>;</span><br><span class="line">T value;</span><br><span class="line">data = <span class="keyword">new</span> T[maxSize];<span class="comment">//创建顺序表储存数组</span></span><br><span class="line"><span class="keyword">if</span>(data == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;=last<span class="number">-1</span>;i++)&#123;</span><br><span class="line">L.GetData(i, value);</span><br><span class="line">data[i<span class="number">-1</span>] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="调整顺序表空间大小"><a href="#调整顺序表空间大小" class="headerlink" title="调整顺序表空间大小"></a>调整顺序表空间大小</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:reSize(<span class="keyword">int</span> newSize)&#123;</span><br><span class="line"><span class="comment">//私有函数，扩充顺序表的储存数组空间的大小，新数组的元素个数为newSize.</span></span><br><span class="line"><span class="keyword">if</span>(newSize &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"无效数组的大小！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(newSize != maxSize)&#123;</span><br><span class="line">T *newarray = <span class="keyword">new</span> T[newSize];</span><br><span class="line"><span class="keyword">if</span>(newarray == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"储存分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = last+<span class="number">1</span>;</span><br><span class="line">T *srcptr = data;<span class="comment">//源数组的首地址</span></span><br><span class="line">T *desptr = newarray;<span class="comment">//目的数组的首地址</span></span><br><span class="line"><span class="keyword">while</span>(n--)&#123;<span class="comment">//复制</span></span><br><span class="line">*desptr++ = *srcptr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []data;<span class="comment">//删除老数组</span></span><br><span class="line">data = newarray;</span><br><span class="line">maxSize = newSize;<span class="comment">//复制新数组</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="搜索和定位操作"><a href="#搜索和定位操作" class="headerlink" title="搜索和定位操作"></a>搜索和定位操作</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:Search(T x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//搜索函数：在表中顺序搜索与给定值x匹配的表项，找到则函数返回该表项是第几个元素</span></span><br><span class="line"><span class="comment">//否则返回0，表示搜索失败</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=last;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i] == x)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:Locate(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定位函数:返回第i(1&lt;=i&lt;=lat+1)个表项的位置，否则函数返回0，表示定位失败</span></span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; i&lt;last+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="插入与删除操作"><a href="#插入与删除操作" class="headerlink" title="插入与删除操作"></a>插入与删除操作</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:Insert(<span class="keyword">int</span> i, T&amp; x)<span class="comment">//插入x在第i个表项之后</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将新元素x插入到第i（0&lt;=i&lt;=last+1）个表项之后。函数返回插入成功的信息，若插入成功返回true,否则返回false.</span></span><br><span class="line"><span class="comment">//i=0时虚拟的，实际上是插入到第1个元素的位置。</span></span><br><span class="line"><span class="keyword">if</span>(last == maxSize - <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表满，不能插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span> || i &gt; last+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//参数i不合理，不能插入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=last;j&gt;=i;j--)</span><br><span class="line">&#123;</span><br><span class="line">data[j+<span class="number">1</span>]=data[j];<span class="comment">//一次后移，空出第i号位置</span></span><br><span class="line">&#125;</span><br><span class="line">data[i] = x;<span class="comment">//插入</span></span><br><span class="line">last++;<span class="comment">//最后位置加一</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">SeqList</span>&lt;T&gt;:</span>:Remove(<span class="keyword">int</span> i, T&amp; x)<span class="comment">//删除第i个表项之后，通过x返回表项的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从表中删除第i（0&lt;=i&lt;=last+1）个表项，通过引用型参数x返回删除的元素值。函数返回删除成功的信息，删除成功返回true,删除失败返回false</span></span><br><span class="line"><span class="keyword">if</span>(last == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//表空，不能删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;last+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//参数i不合理，不能删除</span></span><br><span class="line">&#125;</span><br><span class="line">x=data[i];<span class="comment">//储存删除的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=last;j++)</span><br><span class="line">&#123;</span><br><span class="line">data[j<span class="number">-1</span>] = data[j];<span class="comment">//依次前移，填补</span></span><br><span class="line">&#125;</span><br><span class="line">last--;<span class="comment">//最后位置减一</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="顺序表的性能分析"><a href="#顺序表的性能分析" class="headerlink" title="顺序表的性能分析"></a>顺序表的性能分析</h3><p><code>顺序表所有操作的实现中,最复杂、最耗时的就是搜索、插入和删除运算的实现代码。分析顺序表的性能,主要是分析这3个操作的实现代码的时间复杂性。</code><br>int search(T&amp; x)是顺序表的顺序搜索算法。 其主要思想是:</p><blockquote><p>从表的开始位置起,根据给定值x,逐个与表中各表项的值进行比较。 若给定值与某个表项的值相等,则算法报告搜索成功的信息并返回该表项的位置;若查遍表中所有的表项,没有任何一个表项满足要求,则算法报告搜索不成功的信息并返回0(必要的话,可改一下算法,返回新表项应插人的位置)。</p></blockquote><div class="note success"><h4 id="搜索算法分析"><a href="#搜索算法分析" class="headerlink" title="搜索算法分析"></a>搜索算法分析</h4><p>搜索算法的时间代价用数据比较次数来衡量。 在搜索成功的情形下,顺序搜索的数据比较次数可做如下分析。 若要找的正好是表中第1个表项,数据比较次数为1,这是最好情况;若要找的是表中最后的第n个表项,数据比较次数为n(设表的长度为n),这是最坏的情况 。若要计算平均数据比较次数,需要考虑各个表项的搜索概率p及找到该表项时的数据比较次数$p_i$.搜索的平均数据比较次数ACN(average comparing number)为<br>ACN=$\sum_{i=1}^n {p_i}\times c_i$</p><p>计算平均数据比较次数是为了了解对表操作的整体性能。若考虑相等概率的情形。搜索各表项的可能性相同,有$p_1$=$p_2$=…=$p_n$=$\frac1 n$,且搜索第1个表项的数据比较次数为1,搜计算平均值是为了解算法对表操作的整体性能。 若仅考虑相等概率的情形。搜索各表索第2个表项的数据比较次数为2,,搜索第i号表项的数据比较次数为i,则<br>ACN=$\frac1 n\sum_{i=1}^ni=\frac1 n(1+2+3+…+n)==\frac{1+n} 2$<br>即平均要比较$\frac{n+1} 2$个表项。</p></div><p><strong>分析顺序表的插入和删除的时间代价主要看循环内的数据移动次数</strong></p><div class="note success"><h4 id="插入算法分析"><a href="#插入算法分析" class="headerlink" title="插入算法分析"></a>插入算法分析</h4><p>在将新表项插入到第i个表项(0$\leq$ i $\leq$n)后面时,必须从后向前循环,逐个向后移动n-i个表项。 因此,最好的情形是在第n个表项后追加新表项,移动表项个数为0;最差情形是在第1个表项位置插人新表项(视为在第0个表项后面插入),移动表项个数为n;平均数据移动次数AMN(average moving number)在各表项插入概率相等时为<br>AMN=$\frac1 {n+1}\sum_{i=0}^n{(n-i)}=\frac1 {n+1}\frac{n (n+1)} 2=\frac n 2$<br>即就整体性能来说,在插入时有n+1个插入位置,平均移动$\frac n 2$个表项!</p></div><div class="note success"><h4 id="删除算法分析"><a href="#删除算法分析" class="headerlink" title="删除算法分析"></a>删除算法分析</h4><p>在删除第i个表项(1$\leq$ i $\leq$n)时,必须从前向后循环,逐个移动n一i个表项。 因此,最好的情形是删去最后的第n个表项,移动表项个数为0;最差情形是删去第1个表项,移动项个数为n-1;平均数据移动次数AMN在各表项删除概率相等时为<br>AMN=$\frac1 n\sum_{i=1}^n{(n-i)}=\frac1 {n}\frac{n (n-1)} 2=\frac {n-1} 2$<br>就整体性能来说,在删除时有n个删除位置,平均移动(n-1)/2个表项。</p></div><div class="note info no-icon"><h4 id="继续加油！"><a href="#继续加油！" class="headerlink" title="继续加油！"></a>继续加油！</h4><p>以上是C++顺序表使用过程中最常用的主要操作，相关完整代码已经push到GitHub，需要的小伙伴自行clone，如果觉得还不错的话，欢迎Star,这里是传送门<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/tree/master/C++/%E9%A1%BA%E5%BA%8F%E8%A1%A8" target="_blank" rel="noopener">C++顺序表</a>，小编也是一名学生，如果有什么写的不对的地方，大家在下方给我留言，我们一起讨论！接下来我会更新C语言链式结构实现线性表，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> 顺序存储结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 顺序存储结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现链表（链式存储结构）</title>
      <link href="/posts/60816b5a.html"/>
      <url>/posts/60816b5a.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>链表（链式存储结构）及创建</p><p>链表，别名<font color="green">链式存储结构</font>或<font color="green">单链表</font>，用于存储逻辑关系为 “一对一” 的数据。<font color="red">与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。</font></p><p>例如，使用链表存储 <code>{1,2,3}</code>，数据的物理存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxNzAzVi5naWY" alt="在这里插入图片描述"></p><a id="more"></a><p>我们看到，上图 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxN1I0MS5naWY" alt="在这里插入图片描述"><br>像上图这样，<font color="red">数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是</font><font color="green">链式存储结构。</font></p><h4 id="链表的节点"><a href="#链表的节点" class="headerlink" title="链表的节点"></a>链表的节点</h4><p>从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：</p><ol><li>数据元素本身，其所在的区域称为<font color="green">数据域</font>；</li><li>指向直接后继元素的指针，所在的区域称为<font color="green">指针域</font>；</li></ol><p>即链表中存储各数据元素的结构如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxSGRWSC5naWY" alt="在这里插入图片描述"><br>上图 所示的结构在链表中称为<font color="red">节点</font>。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxSFVxZS5naWY" alt="在这里插入图片描述"><br>因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span>  elem;<span class="comment">//代表数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span> *<span class="title">next</span>;</span><span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;Linklist; <span class="comment">//link为节点名，每个节点都是一个 link 结构体</span></span><br></pre></td></tr></table></figure></div><blockquote><p><font color="red">提示：</font>由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 struct Link* 的形式）。</p></blockquote><h4 id="头节点，头指针和首元节点"><a href="#头节点，头指针和首元节点" class="headerlink" title="头节点，头指针和首元节点"></a>头节点，头指针和首元节点</h4><p>其实，图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：</p><ol><li><font color="green">头指针</font>：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</li><li><font color="green">节点</font>：链表中的节点又细分为头节点、首元节点和其他节点：<br><font color="green">头节点</font>：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；<br><font color="green">首元节点</font>：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；<br>其他节点：链表中其他的节点；</li></ol><p>因此，一个存储<code>{1,2,3}</code> 的完整链表结构如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxYkpGcy5naWY" alt="在这里插入图片描述"></p><blockquote><p><font color="red">注意</font>：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。</p></blockquote><p>明白了链表的基本结构，下面我们来了解如何创建一个链表。</p><h4 id="链表的创建（初始化）"><a href="#链表的创建（初始化）" class="headerlink" title="链表的创建（初始化）"></a>链表的创建（初始化）</h4><p>创建一个链表需要做如下工作：</p><ol><li>声明一个头指针（如果有必要，可以声明一个头节点）；</li><li>创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；</li></ol><p>例如，创建一个存储<code>{1,2,3,4 }</code>且无头节点的链表，C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">linklist * <span class="title">initlinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">linklist * p=<span class="literal">NULL</span>;<span class="comment">//创建头指针</span></span><br><span class="line">linklist * temp = (linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));<span class="comment">//创建首元节点</span></span><br><span class="line"><span class="comment">//首元节点先初始化</span></span><br><span class="line">temp-&gt;elem = <span class="number">1</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p = temp;<span class="comment">//头指针指向首元节点</span></span><br><span class="line"><span class="comment">//从第二个节点开始创建</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line"> <span class="comment">//创建一个新节点并初始化</span></span><br><span class="line">linklist *a=(linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">a-&gt;elem=i;</span><br><span class="line">a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//将temp节点与新建立的a节点建立逻辑关系</span></span><br><span class="line">temp-&gt;next=a;</span><br><span class="line"><span class="comment">//指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对</span></span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果想创建一个存储<code>{1,2,3,4}</code>且含头节点的链表，则 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">linklist * <span class="title">initlinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">linklist * p=(linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));<span class="comment">//创建一个头结点</span></span><br><span class="line">linklist * temp=p;<span class="comment">//声明一个指针指向头结点，</span></span><br><span class="line"><span class="comment">//生成链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">linklist *a=(linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">a-&gt;elem=i;</span><br><span class="line">a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next=a;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们只需在主函数中调用 initLink 函数，即可轻松创建一个存储 {1,2,3,4} 的链表，C 语言完整代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链表中节点的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span>  elem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linklist</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linklist;</span><br><span class="line"><span class="comment">//初始化链表的函数</span></span><br><span class="line"><span class="function">linklist * <span class="title">initlinklist</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//用于输出链表的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(linklist *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化链表（1，2，3，4）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化链表为：\n"</span>);</span><br><span class="line">linklist *p=initlinklist();</span><br><span class="line">display(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">linklist * <span class="title">initlinklist</span><span class="params">()</span></span>&#123;</span><br><span class="line">linklist * p=<span class="literal">NULL</span>;<span class="comment">//创建头指针</span></span><br><span class="line">linklist * temp = (linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));<span class="comment">//创建首元节点</span></span><br><span class="line"><span class="comment">//首元节点先初始化</span></span><br><span class="line">temp-&gt;elem = <span class="number">1</span>;</span><br><span class="line">temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">p = temp;<span class="comment">//头指针指向首元节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">linklist *a=(linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">a-&gt;elem=i;</span><br><span class="line">a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">temp-&gt;next=a;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(linklist *p)</span></span>&#123;</span><br><span class="line">linklist* temp=p;<span class="comment">//将temp指针重新指向头结点</span></span><br><span class="line"><span class="comment">//只要temp指针指向的结点的next不是Null，就执行输出语句。</span></span><br><span class="line"><span class="keyword">while</span> (temp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,temp-&gt;elem);</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果为：</p><blockquote><p>初始化链表为：<br>1 2 3 4<br><font color="red">注意</font>：如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(linklist *p)</span></span>&#123;</span><br><span class="line">linklist* temp=p;<span class="comment">//将temp指针重新指向头结点</span></span><br><span class="line"><span class="comment">//只要temp指针指向的结点的next不是Null，就执行输出语句。</span></span><br><span class="line"><span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,temp-&gt;elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="链表插入元素"><a href="#链表插入元素" class="headerlink" title="链表插入元素"></a>链表插入元素</h4><p>同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p><ul><li>插入到链表的头部（头节点之后），作为首元节点；</li><li>插入到链表中间的某个位置；</li><li>插入到链表的最末端，作为链表中最后一个数据元素；</li></ul><p>虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：</p><ol><li>将新结点的 next 指针指向插入位置后的结点；</li><li>将插入位置前结点的 next 指针指向插入结点；</li></ol><p>例如，我们在链表<code>{1,2,3,4}</code>的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxalFhRC5naWY" alt="在这里插入图片描述"><br>从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。</p><blockquote><p><font color="red">注意</font>：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。</p></blockquote><p>通过以上的讲解，我们可以尝试编写 C 语言代码来实现链表插入元素的操作：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置</span></span><br><span class="line"><span class="function">linklist * <span class="title">insertElem</span><span class="params">(linklist * p,<span class="keyword">int</span> elem,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">linklist * temp=p;<span class="comment">//创建临时结点temp</span></span><br><span class="line"><span class="comment">//首先找到要插入位置的上一个结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入位置无效\n"</span>);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//创建插入结点c</span></span><br><span class="line">linklist * c=(linklist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linklist));</span><br><span class="line">c-&gt;elem=elem;</span><br><span class="line"><span class="comment">//向链表中插入结点</span></span><br><span class="line">c-&gt;next=temp-&gt;next;</span><br><span class="line">temp-&gt;next=c;</span><br><span class="line"><span class="keyword">return</span>  p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><font color="blue">提示</font>:insertElem 函数中加入一个 if 语句，用于判断用户输入的插入位置是否有效。例如，在已存储 {1,2,3} 的链表中，用户要求在链表中第 100 个数据元素所在的位置插入新元素，显然用户操作无效，此时就会触发 if 语句。</p></blockquote><h4 id="链表删除元素"><a href="#链表删除元素" class="headerlink" title="链表删除元素"></a>链表删除元素</h4><p>从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：</p><ol><li>将结点从链表中摘下来;</li><li>手动释放掉结点，回收被结点占用的存储空间;</li></ol><p>其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：</p><blockquote><p>temp-&gt;next=temp-&gt;next-&gt;next;</p></blockquote><p>例如，从存有<code>{1,2,3,4}</code>的链表中删除元素 3，则此代码的执行效果如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzE0L2xxajVpNC5naWY" alt="在这里插入图片描述"><br>因此，链表删除元素的 C 语言实现如下所示：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，add为要删除元素的值</span></span><br><span class="line"><span class="function">linklist * <span class="title">delElem</span><span class="params">(linklist * p,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line">linklist * temp=p;</span><br><span class="line"><span class="comment">//temp指向被删除结点的上一个结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add; i++) &#123;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">linklist * del=temp-&gt;next;<span class="comment">//单独设置一个指针指向被删除结点，以防丢失</span></span><br><span class="line">temp-&gt;next=temp-&gt;next-&gt;next;<span class="comment">//删除某个结点的方法就是更改前一个结点的指针域</span></span><br><span class="line"><span class="built_in">free</span>(del);<span class="comment">//手动释放该结点，防止内存泄漏</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们可以看到，从链表上摘下的节点 del 最终通过 free 函数进行了手动释放。</p><h4 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h4><p>在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的<code>NULL</code>（比对失败的标志）。</p><p>因此，链表中查找特定数据元素的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示被查找元素、</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectElem</span><span class="params">(linklist * p,<span class="keyword">int</span> elem)</span></span>&#123;</span><br><span class="line"><span class="comment">//新建一个指针t，初始化为头指针 p</span></span><br><span class="line">linklist * t=p;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//由于头节点的存在，因此while中的判断为t-&gt;next</span></span><br><span class="line"><span class="keyword">while</span> (t-&gt;next) &#123;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;elem==elem) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p><font color="red">注意</font>：遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建立使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。</p></blockquote><h4 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h4><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><p>直接给出链表中更新数据元素的 C 语言实现代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span></span><br><span class="line"><span class="function">linklist *<span class="title">amendElem</span><span class="params">(linklist * p,<span class="keyword">int</span> add,<span class="keyword">int</span> newElem)</span></span>&#123;</span><br><span class="line">linklist * temp=p;</span><br><span class="line">temp=temp-&gt;next;<span class="comment">//在遍历之前，temp指向首元结点</span></span><br><span class="line"><span class="comment">//遍历到被删除结点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;add; i++) &#123;</span><br><span class="line">temp=temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">temp-&gt;elem=newElem;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><h4 id="继续加油！"><a href="#继续加油！" class="headerlink" title="继续加油！"></a>继续加油！</h4><p>以上内容详细介绍了对链表中数据元素做”增删查改”的实现过程及 C 语言代码相关完整代码已经push到GitHub，需要的小伙伴自行clone，如果觉得还不错的话，欢迎Star！这里是传送门<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8/Linklist.c" target="_blank" rel="noopener">链式存储结构</a>,除此之外，想要了解更多的C,C++,Java,Python等相关知识的童鞋，欢迎在下面留言哟，我们一起讨论！我也是一名学生，如果有不对的地方希望大家指出来，我虚心学习改正。接下来我会持续更新其他算法，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C </category>
          
          <category> 顺序存储结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序存储结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现顺序表（顺序存储结构）</title>
      <link href="/posts/30c404a6.html"/>
      <url>/posts/30c404a6.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>顺序表（顺序存储结构）详解<br><font color="green">顺序表</font>，全名<font color="green">顺序存储结构</font>，是线性表的一种。通过《线性表》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。</p><p>不仅如此，顺序表对数据的物理存储结构也有要求。<font color="red"> 顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。</font></p><p>例如，使用顺序表存储集合<code>{1,2,3,4,5}</code>数据最终的存储状态如下图所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzEzL2w3ZlczZC5naWY" alt="图 1 顺序存储结构示意图"><br>由此我们可以得出，将“具有 ‘一对一’ 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。</p><a id="more"></a><p>通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同数组非常接近。其实，顺序表存储数据使用的就是数组。</p><h3 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h3><p>使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：</p><ol><li>顺序表申请的存储容量；</li><li>顺序表的长度，也就是表中存储数据元素的个数；<blockquote><p><font color="red">提示：</font>正常状态下，顺序表申请的存储容量要大于顺序表的长度<br>因此，我们需要自定义顺序表，C 语言实现代码如下：</p></blockquote></li></ol><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> * head;<span class="comment">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//记录当前顺序表的长度</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">//记录顺序表分配的存储容量</span></span><br><span class="line">&#125;table;</span><br></pre></td></tr></table></figure></div><p>注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。</p><p>接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：</p><ul><li>给 head 动态数据申请足够大小的物理空间；</li><li>给 size 和 length 赋初值；<br>因此，C 语言实现代码如下：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5 <span class="comment">//对Size进行宏定义，表示顺序表申请空间的大小</span></span></span><br><span class="line"><span class="function">table <span class="title">initTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">table t;</span><br><span class="line">t.head=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//构造一个空的顺序表，动态申请存储空间</span></span><br><span class="line"><span class="keyword">if</span> (!t.head) <span class="comment">//如果申请失败，作出提示并直接退出程序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化失败"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">t.length=<span class="number">0</span>;<span class="comment">//空表的长度初始化为0</span></span><br><span class="line">t.size=Size;<span class="comment">//空表的初始存储空间为Size</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。</p><p>通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> * head;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">&#125;table;</span><br><span class="line"><span class="function">table <span class="title">initTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">table t;</span><br><span class="line">t.head=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(Size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (!t.head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"初始化失败"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">t.length=<span class="number">0</span>;</span><br><span class="line">t.size=Size;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出顺序表中元素的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayTable</span><span class="params">(table t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; t.length;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,t.head[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">table t=initTable();</span><br><span class="line"><span class="comment">//向顺序表中添加元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=Size; i++) &#123;</span><br><span class="line">t.head[i<span class="number">-1</span>]=i;</span><br><span class="line">t.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"顺序表中存储的元素分别是：\n"</span>);</span><br><span class="line">displayTable(t);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>程序运行结果如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序表中存储的元素分别是：</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure></div><p>可以看到，顺序表初始化成功。</p><h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><h4 id="顺序表插入元素"><a href="#顺序表插入元素" class="headerlink" title="顺序表插入元素"></a>顺序表插入元素</h4><p>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：</p><ol><li>插入到顺序表的表头；</li><li>在表的中间位置插入元素；</li><li>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</li></ol><p>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：</p><ul><li>将要插入位置元素以及后续的元素整体向后移动一个位置；</li><li>将元素放到腾出来的位置上；</li></ul><p>例如，在 <code>{1,2,3,4,5}</code>的第 3 个位置上插入元素 6，实现过程如下：</p><ul><li>遍历至顺序表存储第 3 个数据元素的位置，如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzEzL2w3b290Sy5naWY" alt="在这里插入图片描述"><!-- more --></li><li>将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图下 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzEzL2w3Nzh4Zy5naWY" alt="在这里插入图片描述"></li><li>将新元素 6 放入腾出的位置，如下 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzEzL2w3NzFHOC5naWY" alt="在这里插入图片描述"><br>因此，顺序表插入数据元素的 C 语言实现代码如下：</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span></span><br><span class="line"><span class="function">table <span class="title">addTable</span><span class="params">(table t,<span class="keyword">int</span> elem,<span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span></span><br><span class="line"><span class="keyword">if</span> (add&gt;t.length+<span class="number">1</span>||add&lt;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入位置有问题"</span>);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span></span><br><span class="line"><span class="keyword">if</span> (t.length==t.size) &#123;</span><br><span class="line">t.head=(<span class="keyword">int</span> *)<span class="built_in">realloc</span>(t.head, (t.size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (!t.head) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"存储分配失败"</span>);</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">t.size+=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//插入操作，需要将从插入位置开始的后续元素，逐个后移</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=t.length<span class="number">-1</span>; i&gt;=add<span class="number">-1</span>; i--) &#123;</span><br><span class="line">t.head[i+<span class="number">1</span>]=t.head[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span></span><br><span class="line">t.head[add<span class="number">-1</span>]=elem;</span><br><span class="line"><span class="comment">//由于添加了元素，所以长度+1</span></span><br><span class="line">t.length++;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>注意，动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</p><h4 id="顺序表删除元素"><a href="#顺序表删除元素" class="headerlink" title="顺序表删除元素"></a>顺序表删除元素</h4><p>从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。</p><blockquote><p>后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。</p></blockquote><p>例如，从<code>{1,2,3,4,5}</code> 中删除元素 3 的过程如下图 所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDIwLzAxLzEzL2w3YlN0eC5naWY" alt="在这里插入图片描述"><br>因此，顺序表删除元素的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">table <span class="title">delTable</span><span class="params">(table t,<span class="keyword">int</span> add)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (add&gt;t.length || add&lt;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"被删除元素的位置有误"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=add; i&lt; t.length; i++) &#123;</span><br><span class="line">t.head[i<span class="number">-1</span>]=t.head[i];</span><br><span class="line">&#125;</span><br><span class="line">t.length--;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h4><p>顺序表中查找目标元素，可以使用多种查找算法实现，比如说<font color="blue">二分查找算法、插值查找算法</font>等。</p><p>这里，我们选择顺序查找算法，具体实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找函数，其中，elem表示要查找的数据元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchable</span><span class="params">(table t,<span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; t.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (t.head[i]==elem) &#123;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="顺序表更改元素"><a href="#顺序表更改元素" class="headerlink" title="顺序表更改元素"></a>顺序表更改元素</h4><p>顺序表更改元素的实现过程是：</p><ol><li>找到目标元素；</li><li>直接修改该元素的值；</li></ol><p>顺序表更改元素的 C 语言实现代码为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span></span><br><span class="line"><span class="function">table <span class="title">replaceTable</span><span class="params">(table t,<span class="keyword">int</span> elem,<span class="keyword">int</span> newElem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> add=searchable(t, elem);</span><br><span class="line">t.head[add<span class="number">-1</span>]=newElem;<span class="comment">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayTable</span><span class="params">(table t)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; t.length;i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,t.head[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="返回顺序表的长度和最大容纳表项个数"><a href="#返回顺序表的长度和最大容纳表项个数" class="headerlink" title="返回顺序表的长度和最大容纳表项个数"></a>返回顺序表的长度和最大容纳表项个数</h4><p>这两个元素属于结构体，直接返回即可</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回顺序表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">returnLength</span><span class="params">(table t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.length;<span class="comment">//返回结构体的长度元素即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回顺序表最大容纳表项个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">returnSize</span><span class="params">(table t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上是顺序表使用过程中最常用的基本操作，相关完整代码已经push到GitHub，需要的小伙伴自行clone，如果觉得还不错的话，欢迎Star！这里是传送门<a href="https://github.com/xjh199923/Data-structures-in-multiple-languages/blob/master/C/%E9%A1%BA%E5%BA%8F%E8%A1%A8/SequenceTable.c" target="_blank" rel="noopener">顺序表（顺序存储结构）</a>，除此之外，喜欢C,C++,Java,Python等相关知识的童鞋，欢迎留言，我们一起讨论！接下来我会持续更新其他语言实现顺序表，其中算法分析我会在下一次，C++实现时与大家分享，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C </category>
          
          <category> 顺序存储结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 顺序存储结构 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Hexo-abbrlink插件生成唯一文章链接</title>
      <link href="/posts/69978469.html"/>
      <url>/posts/69978469.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>Hexo在生成博客文章链接时，默认是按照年、月、日、标题格式来生成的，可以在站点配置文件中指定new_post_name的值。默认是:year/:month/:day/:title这样的格式。如果你的标题是中文的话，你的URL链接就会包含中文，生成的链接如下图：</p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/12/16/QhIywV.png" alt="QhIywV.png"><br>复制后的url路径就是把中文变成了一大堆字符串编码：<br><a href="http://xjh199923.top/2019/12/15/Mac%E5%AE%89%E8%A3%85Qt%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">http://xjh199923.top/2019/12/15/Mac%E5%AE%89%E8%A3%85Qt%E6%95%99%E7%A8%8B/</a><br>如果你在其它地方用了你自己这篇文章的url链接，偶然你又修改了该文章的标题，那这个url链接岂不是失效了。为了给每一篇文章来上一个属于自己的链接，写下此教程，利用hexo-abbrlink插件，A Hexo plugin to generate static post link based on post titles,来解决这个问题。<br>参考github官方：<br><a href="https://github.com/Rozbo/hexo-abbrlink" class="LinkCard" target="_blank" rel="noopener">hexo-abbrlink</a><br>按照此教程配置完之后如下：<br><img src="https://s2.ax1x.com/2019/12/16/Q4J7tg.png" alt="Q4J7tg.png"></p><h3 id="How-to-install"><a href="#How-to-install" class="headerlink" title="How to install"></a>How to install</h3><p>Add plugin to Hexo:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></div><div class="note danger"><p>执行此命令可能会不成功，提示你缺少相应的依赖，比如babel-eslint、mini-css-extract-plugin、webpack-cli…<br>使用npm命令安装即可，比如npm install <a href="mailto:eslint@4.x" target="_blank" rel="noopener">eslint@4.x</a> babel-eslint@8 –save-dev</p></div><p>Modify permalink in config.yml file:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br></pre></td></tr></table></figure></div><p>There are two settings:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">alg</span> <span class="bullet">--</span> <span class="string">Algorithm</span> <span class="string">(currently</span> <span class="string">support</span> <span class="string">crc16</span> <span class="string">and</span> <span class="string">crc32,</span> <span class="string">which</span> <span class="string">crc16</span> <span class="string">is</span> <span class="string">default)</span></span><br><span class="line"><span class="string">rep</span> <span class="bullet">--</span> <span class="string">Represent</span> <span class="string">(the</span> <span class="string">generated</span> <span class="string">link</span> <span class="string">could</span> <span class="string">be</span> <span class="string">presented</span> <span class="string">in</span> <span class="string">hex</span> <span class="string">or</span> <span class="string">dec</span> <span class="string">value)</span></span><br></pre></td></tr></table></figure></div><p>配置完成后如下</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line"><span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure></div><p>官方Sample<br>The generated link will look like the following:</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https:<span class="comment">//post.zz173.com/posts/66c8.html</span></span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https:<span class="comment">//post.zz173.com/posts/65535.html</span></span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https:<span class="comment">//post.zz173.com/posts/8ddf18fb.html</span></span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https:<span class="comment">//post.zz173.com/posts/1690090958.html</span></span><br></pre></td></tr></table></figure></div><div class="note success"><p>生成完后,原文章md文件的Front-matter 内会增加abbrlink 字段,值为生成的ID 。这个字段确保了在我们修改了Front-matter 内的博客标题title或创建日期date字段之后而不会改变链接地址,换句话说,就是本篇文章有了自己的专属链接。有了专属链接，找百度收录也就简单的多了，冲鸭！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> abbrlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列的相关操作(队列实现杨辉三角的打印)</title>
      <link href="/posts/22281.html"/>
      <url>/posts/22281.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><h2 id="队列的相关操作-队列实现杨辉三角的打印"><a href="#队列的相关操作-队列实现杨辉三角的打印" class="headerlink" title="队列的相关操作(队列实现杨辉三角的打印)"></a>队列的相关操作(队列实现杨辉三角的打印)</h2><p>1.实现队列的一种存储结构<br>2.实现队列的相关操作<br>3.利用队列的操作特点，借助进队与出队操作完成打印二项式系数的任务（杨辉三角的打印）</p><p><img src="https://img-blog.csdnimg.cn/20191011121857759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="杨辉三角打印图"></p><a id="more"></a><h3 id="考虑到实现多种数据类型，采用了C-的模板方式编写，并利用了STL库函数的vector容器类来储存数据-该循环队列主要实现了以下函数："><a href="#考虑到实现多种数据类型，采用了C-的模板方式编写，并利用了STL库函数的vector容器类来储存数据-该循环队列主要实现了以下函数：" class="headerlink" title="考虑到实现多种数据类型，采用了C++的模板方式编写，并利用了STL库函数的vector容器类来储存数据,该循环队列主要实现了以下函数："></a>考虑到实现多种数据类型，采用了C++的模板方式编写，并利用了STL库函数的vector容器类来储存数据,该循环队列主要实现了以下函数：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  MyCircularQueue() &#123;</span><br><span class="line">    data.resize(k);</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    tail = <span class="number">-1</span>;</span><br><span class="line">    size = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">setsize</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">const</span> T&amp; value)</span></span>;<span class="comment">//进队</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(T&amp; x)</span></span>;<span class="comment">//出队</span></span><br><span class="line">  <span class="function">T <span class="title">getFront</span><span class="params">()</span> </span>;<span class="comment">//取队列头部元素</span></span><br><span class="line">  <span class="function">T <span class="title">getRear</span><span class="params">()</span></span>;<span class="comment">//取队列位尾部元素</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断是否为空</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;<span class="comment">//判断是否为满</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="主要函数的相关实现"><a href="#主要函数的相关实现" class="headerlink" title="主要函数的相关实现"></a>主要函数的相关实现</h3><h4 id="队列元素进队"><a href="#队列元素进队" class="headerlink" title="队列元素进队"></a>队列元素进队</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">MyCircularQueue</span>&lt;T&gt;:</span>:enQueue(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">    data[tail] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="队列元素出队"><a href="#队列元素出队" class="headerlink" title="队列元素出队"></a>队列元素出队</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">MyCircularQueue</span>&lt;T&gt;:</span>:deQueue(T&amp; x) </span><br><span class="line">&#123;</span><br><span class="line">  x=data[head];</span><br><span class="line">  <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  head = (head + <span class="number">1</span>) % size;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="取队列头部元素"><a href="#取队列头部元素" class="headerlink" title="取队列头部元素"></a>取队列头部元素</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">MyCircularQueue</span>&lt;T&gt;:</span>:getFront() </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> data[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="取队列位尾部元素"><a href="#取队列位尾部元素" class="headerlink" title="取队列位尾部元素"></a>取队列位尾部元素</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">MyCircularQueue</span>&lt;T&gt;:</span>:getRear() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data[tail];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="测试函数实现杨辉三角的打印"><a href="#测试函数实现杨辉三角的打印" class="headerlink" title="测试函数实现杨辉三角的打印"></a>测试函数实现杨辉三角的打印</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyCircularQueue&lt;<span class="keyword">int</span>&gt; queve;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>,x;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j,s=<span class="number">0</span>,k=<span class="number">0</span>,t=<span class="number">0</span>,u;</span><br><span class="line">    queve.enQueue(i);queve.enQueue(i);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j&lt;=n - i ; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">3</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      queve.enQueue(k);</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i+<span class="number">2</span>;j++)</span><br><span class="line">      &#123;</span><br><span class="line">        queve.deQueue(t);</span><br><span class="line">        u=s+t;</span><br><span class="line">        queve.enQueue(u);</span><br><span class="line">        s=t;</span><br><span class="line">        <span class="keyword">if</span>(j!=i+<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;setw(<span class="number">6</span>)&lt;&lt;s;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><h3 id="希望和大家一起进步，一起学习，有什么可以改进的地方希望大家评论区指出来，我加以改正，继续加油。也可以通过我的QQ联系我哟。"><a href="#希望和大家一起进步，一起学习，有什么可以改进的地方希望大家评论区指出来，我加以改正，继续加油。也可以通过我的QQ联系我哟。" class="headerlink" title="希望和大家一起进步，一起学习，有什么可以改进的地方希望大家评论区指出来，我加以改正，继续加油。也可以通过我的QQ联系我哟。"></a>希望和大家一起进步，一起学习，有什么可以改进的地方希望大家评论区指出来，我加以改正，继续加油。也可以通过我的QQ联系我哟。</h3><p><a href="https://download.csdn.net/download/qq_43336390/11848049" target="_blank" rel="noopener">完整代码下载地址</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 杨辉三角 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装Qt教程</title>
      <link href="/posts/59037.html"/>
      <url>/posts/59037.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>史上最详细mac安装Qt教程，小白看过来！这是一篇非常适合Qt入门小白的的安装Qt教程，因为这学期我们小组的一个关于高速救援的项目要用到Qt与web进行交互式展现相关的图像，由于没有MSVC这个插件，所以我只好选择重装Qt，这次没有第一次装那么困难，毕竟经历过一次，这次我以这篇博客记录下来，分享给大家！</p><a id="more"></a><h5 id="首先，进入QT官网"><a href="#首先，进入QT官网" class="headerlink" title="首先，进入QT官网"></a>首先，进入<a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">QT官网</a></h5><h5 id="选择你需要的版本，我选择了5-13，因为5-14才更新两天，不喜欢用最新的，当这个小白鼠。"><a href="#选择你需要的版本，我选择了5-13，因为5-14才更新两天，不喜欢用最新的，当这个小白鼠。" class="headerlink" title="选择你需要的版本，我选择了5.13，因为5.14才更新两天，不喜欢用最新的，当这个小白鼠。"></a>选择你需要的版本，我选择了5.13，因为5.14才更新两天，不喜欢用最新的，当这个小白鼠。</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf5gp9.md.png" alt="在这里插入图片描述"></p><h5 id="选择你需要的安装，当然mac是选择小编勾画出来的部分"><a href="#选择你需要的安装，当然mac是选择小编勾画出来的部分" class="headerlink" title="选择你需要的安装，当然mac是选择小编勾画出来的部分"></a>选择你需要的安装，当然mac是选择小编勾画出来的部分</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf52lR.md.png" alt="在这里插入图片描述"></p><h5 id="接下来又是漫长的等待下载环节，没想到今天学校的网速这么给力"><a href="#接下来又是漫长的等待下载环节，没想到今天学校的网速这么给力" class="headerlink" title="接下来又是漫长的等待下载环节，没想到今天学校的网速这么给力"></a>接下来又是漫长的等待下载环节，没想到今天学校的网速这么给力</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf56fJ.png" alt="Qf56fJ.png"></p><h5 id="下载好之后双击安装"><a href="#下载好之后双击安装" class="headerlink" title="下载好之后双击安装"></a>下载好之后双击安装</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf5yY4.png" alt="Qf5yY4.png"></p><h5 id="我也不知道为什么这次安装验证了这么久，可能是还是有2个多G吧，我等了超久。"><a href="#我也不知道为什么这次安装验证了这么久，可能是还是有2个多G吧，我等了超久。" class="headerlink" title="我也不知道为什么这次安装验证了这么久，可能是还是有2个多G吧，我等了超久。"></a>我也不知道为什么这次安装验证了这么久，可能是还是有2个多G吧，我等了超久。</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf5R61.png" alt="Qf5R61.png"></p><h5 id="验证成功之后就会出现下面这个界面，毫不犹豫的next"><a href="#验证成功之后就会出现下面这个界面，毫不犹豫的next" class="headerlink" title="验证成功之后就会出现下面这个界面，毫不犹豫的next"></a>验证成功之后就会出现下面这个界面，毫不犹豫的next</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf5WOx.png" alt="Qf5WOx.png"></p><h5 id="接下来你需要选择你的安装地址，等会儿会下载需要的插件的安装位置，选择好之后就继续"><a href="#接下来你需要选择你的安装地址，等会儿会下载需要的插件的安装位置，选择好之后就继续" class="headerlink" title="接下来你需要选择你的安装地址，等会儿会下载需要的插件的安装位置，选择好之后就继续"></a>接下来你需要选择你的安装地址，等会儿会下载需要的插件的安装位置，选择好之后就继续</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf5hm6.png" alt="Qf5hm6.png"></p><h5 id="看到下面这个界面就不用我说了吧，当然是I-have-啊"><a href="#看到下面这个界面就不用我说了吧，当然是I-have-啊" class="headerlink" title="看到下面这个界面就不用我说了吧，当然是I have 啊"></a>看到下面这个界面就不用我说了吧，当然是I have 啊</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qf540K.png" alt="Qf540K.png"></p><h5 id="下面这一步你需要选择你需要的插件，如果你电脑吃的消全选也没啥问题，本来想要MSVC-没想到没有，我太气了！只能说利用这次水一篇教程的博文吧哈哈哈，选择好之后点击继续，接下来需要等待一段时间，毕竟要下载几个G的插件嘛，耐心等待吧"><a href="#下面这一步你需要选择你需要的插件，如果你电脑吃的消全选也没啥问题，本来想要MSVC-没想到没有，我太气了！只能说利用这次水一篇教程的博文吧哈哈哈，选择好之后点击继续，接下来需要等待一段时间，毕竟要下载几个G的插件嘛，耐心等待吧" class="headerlink" title="下面这一步你需要选择你需要的插件，如果你电脑吃的消全选也没啥问题，本来想要MSVC,没想到没有，我太气了！只能说利用这次水一篇教程的博文吧哈哈哈，选择好之后点击继续，接下来需要等待一段时间，毕竟要下载几个G的插件嘛，耐心等待吧"></a>下面这一步你需要选择你需要的插件，如果你电脑吃的消全选也没啥问题，本来想要MSVC,没想到没有，我太气了！只能说利用这次水一篇教程的博文吧哈哈哈，选择好之后点击继续，接下来需要等待一段时间，毕竟要下载几个G的插件嘛，耐心等待吧</h5><p><img src="https://s2.ax1x.com/2019/12/15/QfTx76.png" alt="QfTx76.png"></p><h5 id="终于等到了安装成功！"><a href="#终于等到了安装成功！" class="headerlink" title="终于等到了安装成功！"></a>终于等到了安装成功！</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFTUS.png" alt="QhFTUS.png"><br><img src="https://s2.ax1x.com/2019/12/15/QhF5Hf.png" alt="QhF5Hf.png"></p><h5 id="接下来创建一个project看看吧"><a href="#接下来创建一个project看看吧" class="headerlink" title="接下来创建一个project看看吧"></a>接下来创建一个project看看吧</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFbCQ.png" alt="QhFbCQ.png"></p><h5 id="新建项目new-project"><a href="#新建项目new-project" class="headerlink" title="新建项目new project"></a>新建项目new project</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFoE8.png" alt="QhFoE8.png"></p><h5 id="就拿一个widgets来测试吧"><a href="#就拿一个widgets来测试吧" class="headerlink" title="就拿一个widgets来测试吧"></a>就拿一个widgets来测试吧</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhF4DP.png" alt="QhF4DP.png"></p><h5 id="在此你要设置你的项目路径，与你的Qt安装路径是不一样的，这个路径是你的项目产生的文件所存取的路径-然后点击继续"><a href="#在此你要设置你的项目路径，与你的Qt安装路径是不一样的，这个路径是你的项目产生的文件所存取的路径-然后点击继续" class="headerlink" title="在此你要设置你的项目路径，与你的Qt安装路径是不一样的，这个路径是你的项目产生的文件所存取的路径,然后点击继续"></a>在此你要设置你的项目路径，与你的Qt安装路径是不一样的，这个路径是你的项目产生的文件所存取的路径,然后点击继续</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFq3j.png" alt="QhFq3j.png"></p><h5 id="采用qmake来进行编译"><a href="#采用qmake来进行编译" class="headerlink" title="采用qmake来进行编译"></a>采用qmake来进行编译</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFOvn.png" alt="QhFOvn.png"></p><h5 id="创建之后会产生以下相关的窗体设计文件"><a href="#创建之后会产生以下相关的窗体设计文件" class="headerlink" title="创建之后会产生以下相关的窗体设计文件"></a>创建之后会产生以下相关的窗体设计文件</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFjuq.png" alt="QhFjuq.png"></p><h5 id="选择一个kits"><a href="#选择一个kits" class="headerlink" title="选择一个kits"></a>选择一个kits</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFvD0.png" alt="QhFvD0.png"></p><h5 id="最后一完成之后就OK了"><a href="#最后一完成之后就OK了" class="headerlink" title="最后一完成之后就OK了"></a>最后一完成之后就OK了</h5><p><img src="https://s2.ax1x.com/2019/12/15/QhFxbV.png" alt="QhFxbV.png"></p><h5 id="不需要添加任何代码，直接编译运行，出现一个窗口说明就成功了"><a href="#不需要添加任何代码，直接编译运行，出现一个窗口说明就成功了" class="headerlink" title="不需要添加任何代码，直接编译运行，出现一个窗口说明就成功了"></a>不需要添加任何代码，直接编译运行，出现一个窗口说明就成功了</h5><p><img src="https://s2.ax1x.com/2019/12/15/Qhk95F.png" alt="Qhk95F.png"></p><div class="note success"><p>继续加油!<br>到这里基本上教程就算得上是结束了，如果有写的不好的地方，欢迎评论指出来，我做相应的修正。一篇小小的教程可能需要花很多的时间去堆积，如果觉得还不错的就点上一个赞吧，你的支持就是我前进的动力，我们一起学习，共同进步！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/posts/51203.html"/>
      <url>/posts/51203.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>排序算法之选择排序,选择排序，选择排序的基本思想描述为：每一趟在n-i+1(i=1,2,…,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。具体来说，假设长度为n的数组arr，要按照从小到大排序，那么先从n个数字中找到最小值min1，如果最小值min1的位置不在数组的最左端(也就是min1不等于arr[0])，则将最小值min1和arr[0]交换，接着在剩下的n-1个数字中找到最小值min2，如果最小值min2不等于arr[1]，则交换这两个数字，依次类推，直到数组arr有序排列。</p><a id="more"></a><div class="note info"><p>算法过程</p><p>举个栗子（第一趟的排序过程）</p><p>原始序列：3、44、38、5、47、15、36、 26、27、2、46、4、19、50、48</p><p>1）在进行选择排序过程中分成有序和无序两个部分，开始都是无序序列</p><p>结果：3、44、38、5、47、15、36、 26、27、2、46、4、19、50、48</p><p>2）从无序序列中取出最小的元素2，将2同无序序列第一个元素交换，此时产生仅含一个元素的有序序列，无序序列减一</p><p>结果：{2、} {44、38、5、47、15、36、 26、27、3、46、4、19、50、48</p><p>3）从无序序列中取出最小的元素3，将3同无序序列第一个元素交换，此时产生仅两个元素的有序序列，无序序列减一</p><p>结果：{2、3、} {38、5、47、15、36、 26、27、44、46、4、19、50、48}</p><p>4）从无序序列中取出最小的元素4，将4同无序序列第一个元素交换，此时产生含三个元素的有序序列，无序序列减一</p><p>结果：{2、3、4、} {5、47、15、36、 26、27、44、46、38、19、50、48}</p><p>5）从无序序列中取出最小的元素5，5此时是无序序列最小的，不用交换</p><p>结果：{2、3、4、5、} {47、15、36、 26、27、44、46、38、19、50、48}</p><p>6）从无序序列中取出最小的元素15，将15同无序序列第一个元素交换，此时产生含五个元素的有序序列，无序序列减一</p><p>结果：{2、3、4、5、15、} {47、36、 26、27、44、46、38、19、50、48}</p><p>7）依次重复上述操作，直到无序序列只有最后一个元素</p><p>8）最后一个元素50肯定是最大元素，无序排序直接生产一个有序的序列</p><p>结果：{2、3、4、5、19、26、27、36、38、44、46、47、48、50}</p><p>最后如果还没有理解这个过程的话，小编放上一个动图，让大家更深入的理解这个过程：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzExLzEyL00zMlFUeC5naWY" alt="插入排序动态分析图"></p></div><h2 id="接下来分析完了选择排序的算法，我们就到了分享代码的这个激动人心的时刻了："><a href="#接下来分析完了选择排序的算法，我们就到了分享代码的这个激动人心的时刻了：" class="headerlink" title="接下来分析完了选择排序的算法，我们就到了分享代码的这个激动人心的时刻了："></a>接下来分析完了选择排序的算法，我们就到了分享代码的这个激动人心的时刻了：</h2><h3 id="选择排序C-实现代码："><a href="#选择排序C-实现代码：" class="headerlink" title="选择排序C++实现代码："></a>选择排序C++实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100</span>];<span class="comment">//定义一个产生数组储存100个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; randsample=get_random(<span class="number">100</span>,MAX_NUM);<span class="comment">//产生100个0-MAZX_NUM的随机数,每次产生的随机数不一样</span></span><br><span class="line">  <span class="keyword">int</span> size=randsample.size();</span><br><span class="line">  <span class="comment">//输出最开始时未排序时的顺序:</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"随机数的顺序："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;randsample[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">clock_t</span> start,finish;<span class="comment">//定义一个测量一段程序运行时间的前后值</span></span><br><span class="line">  <span class="keyword">double</span> totaltime;<span class="comment">//总的运行时间</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//测试选择排序</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"执行选择排序后:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">  &#123;</span><br><span class="line">    data[i]=randsample[i];</span><br><span class="line">  &#125;</span><br><span class="line">  start=clock();</span><br><span class="line">  SelectSort(size);</span><br><span class="line">  finish=clock();</span><br><span class="line">  output(size);</span><br><span class="line">  totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间："</span>&lt;&lt;totaltime&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生随机数的函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(N);<span class="comment">//N代表初始状态分配的空间大小</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out_vec;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    vec[i]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> rand_value=rand()%N;</span><br><span class="line">    out_vec.push_back(vec[rand_value]);</span><br><span class="line">    vec[rand_value]=vec[N<span class="number">-1</span>];<span class="comment">//将数组vec的元素</span></span><br><span class="line">    N--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out_vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> k=i;<span class="comment">//在data[i]到data[n-1]找最小排序码元素</span></span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(data[j]&lt;data[k])&#123;</span><br><span class="line">        count++;<span class="comment">//当前具有最小排序码的元素</span></span><br><span class="line">        k=j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k!=i)</span><br><span class="line">    Swap(i,k);<span class="comment">//交换</span></span><br><span class="line">    count1++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"比较次数: "</span>&lt;&lt;count&lt;&lt;<span class="string">"  移动次数:  "</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tem;</span><br><span class="line">  tem = data[j];</span><br><span class="line">  data[j]= data[i];</span><br><span class="line">  data[i] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://imgchr.com/i/M88llD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M88llD.md.png" alt="M88llD.md.png"></a></p><h3 id="选择排序Java代码实现"><a href="#选择排序Java代码实现" class="headerlink" title="选择排序Java代码实现"></a>选择排序Java代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object []arr = getRandomNumList(<span class="number">100</span>,<span class="number">0</span>,<span class="number">10000</span>).toArray();</span><br><span class="line">    <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>] ;</span><br><span class="line">    System.out.println(<span class="string">"排序前："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      String s=arr[i].toString();</span><br><span class="line">      ins[i]= Integer.parseInt( s );</span><br><span class="line">      System.out.println(ins[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    System.out.println(<span class="string">"排序后："</span>);</span><br><span class="line">    <span class="keyword">int</span>[] ins2 = selectsort(ins);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(ins2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectsort(<span class="keyword">int</span>[] data)&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n = data.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> k=i;<span class="comment">//在data[i]到data[n-1]找最小排序码元素</span></span><br><span class="line">      <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[j]&lt;data[k])&#123;<span class="comment">//当前具有最小排序码的元素</span></span><br><span class="line">          k=j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(k!=i)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> tem;</span><br><span class="line">        tem=data[k];</span><br><span class="line">        data[k]=data[i];</span><br><span class="line">        data[i]=tem;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//定义生成随机数并且装入集合容器的方法</span></span><br><span class="line">    <span class="comment">//方法的形参列表分别为：生成随机数的个数、生成随机数的值的范围最小值为start(包含start)、值得范围最大值为end(不包含end)  可取值范围可表示为[start,end)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">getRandomNumList</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建集合容器对象</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Random对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//循环将得到的随机数进行判断，如果随机数不存在于集合中，则将随机数放入集合中，如果存在，则将随机数丢弃不做操作，进行下一次循环，直到集合长度等于nums</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() != nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = r.nextInt(end-start) + start;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="选择排序Python代码实现"><a href="#选择排序Python代码实现" class="headerlink" title="选择排序Python代码实现"></a>选择排序Python代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        minIndex = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>,len(arr),<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[minIndex]):</span><br><span class="line">                minIndex = i</span><br><span class="line">        arr[j],arr[minIndex] = arr[minIndex],arr[j]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    arr =[]</span><br><span class="line">    <span class="keyword">while</span>(len(arr)&lt;<span class="number">100</span>):</span><br><span class="line">        x=random.randint(<span class="number">0</span>,<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> arr:</span><br><span class="line">            arr.append(x)</span><br><span class="line">    sort(arr)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><div class="note info"><p>直接选择排序的排序码比较次数KCN与元素的初始排列无关。第i趟选择具有最小排序码元素所需的比较次数总是n-i-1次，此处假定整个待排序元素序列有n个元素。因此，总的排序码比较次数为:</p><p>$\displaystyle KCN=\sum_{i=0}^{n-2}{(n-i-1)}$=n*(n-1)/2</p><p>元素的移动次数与元素序列的初始排列有关。当这组元素的初始状态是按其排序码从小到大有序的时候，元素的移动次数RMN=0，达到最少；而最坏情况是每一趟都要进行交换，总的元素移动次数为RMN=3（n一1)。它对一类重要的元素序列具有较好的效率，这就是元素规模很大，而排序码却比较小的序列。因为对这种的序列进行排序，移动操作所花费的时间要比比较操作的时间大得多，而其他算法移动操作所花费的时间要比比较操作的时间大的多，而其他算法移动操作次数都要比选择排序来得多。直接选择排序是一种不稳定的排序方法。</p></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的选择排序的几种实现,如果有什么不足之处欢迎大家指出，留言，互相学习，共同进步。花了几个小时整理，希望得到大家的支持,你的支持就是我前进的动力,下面我会持续更新其他的排序算法，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> Java </category>
          
          <category> Python </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的储存结构及相关操作</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><h1 id="栈的储存结构及相关操作"><a href="#栈的储存结构及相关操作" class="headerlink" title="栈的储存结构及相关操作"></a>栈的储存结构及相关操作</h1><p>1.实现栈的存储结构及相关操作：进栈、出栈、取栈顶元素等<br>2.使用该栈完成一个字符串的逆序输出<br>3.使用该栈完成表达式的括号是否匹配?<br>4.对算术表达式求值</p><p><img src="https://img-blog.csdnimg.cn/20191009212043477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="界面"></p><a id="more"></a><h2 id="主要的相关实现函数"><a href="#主要的相关实现函数" class="headerlink" title="主要的相关实现函数"></a>主要的相关实现函数</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* elements;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶元素的指针</span></span><br><span class="line"><span class="keyword">int</span> maxSize;<span class="comment">//栈的最大容纳元素个数</span></span><br><span class="line"><span class="comment">//void overflowProcess();//栈的溢出处理操作</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Stack(<span class="keyword">int</span> size=basesize)<span class="comment">//构造函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">maxSize=size;</span><br><span class="line">top=<span class="number">-1</span>;</span><br><span class="line">creatStack(size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~Stack()&#123;<span class="keyword">delete</span> []elements;&#125;<span class="comment">//析构函数，释放栈的空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatStack</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//创建一个大小为n的栈，并为其动态分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>;<span class="comment">//元素x入栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(T&amp; x)</span></span>;<span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;<span class="comment">//判满函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判空函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxsize</span><span class="params">()</span><span class="comment">//得到栈的最大体积</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> maxSize;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">getTopelements</span><span class="params">()</span></span>;<span class="comment">//得到栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTop</span><span class="params">()</span><span class="comment">//得到栈的top指针的地址，因为是采用数组类型储存，因此top指针可以利用数组的下标得到</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> top;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> tape)</span></span>;<span class="comment">//展示各种类型的数据，控制格式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">writeToFile</span><span class="params">(<span class="built_in">string</span> filename)</span></span>;<span class="comment">//将数据写入指定文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readFromFile</span><span class="params">(<span class="built_in">string</span> filename)</span></span>;<span class="comment">//将数据从指定文件读入</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="栈的各个函数的实现"><a href="#栈的各个函数的实现" class="headerlink" title="栈的各个函数的实现"></a>栈的各个函数的实现</h2><h3 id="创建一个大小为n的栈"><a href="#创建一个大小为n的栈" class="headerlink" title="创建一个大小为n的栈"></a>创建一个大小为n的栈</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:creatStack(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">elements = <span class="keyword">new</span> T(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(elements==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"动态分配错误！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="元素x入栈"><a href="#元素x入栈" class="headerlink" title="元素x入栈"></a>元素x入栈</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果栈isFull(),则进行溢出处理，否则将其插入到栈顶</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Push(<span class="keyword">const</span> T &amp;x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isFull()==<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//overflowProcess();//溢出处理，调整空间大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">elements[++top]=x;<span class="comment">//将x入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">### 栈顶元素出栈，以x的引用返回</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//栈顶元素出栈，如果栈为空返回false;若栈不为空，栈顶元素出栈，top指针减一</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:Pop(T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">x=getTopelements();</span><br><span class="line"></span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="判满函数"><a href="#判满函数" class="headerlink" title="判满函数"></a>判满函数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈是否满，如果满返回true,未满返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isFull()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()&lt;<span class="keyword">this</span>-&gt;getMaxsize())&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="判空函数"><a href="#判空函数" class="headerlink" title="判空函数"></a>判空函数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈是否空，如果满返回true,未满返回false</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:isEmpty()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;getTop()==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">Stack</span>&lt;T&gt;:</span>:print(<span class="built_in">string</span> tape)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"This Stack is empty!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getTop();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[i]&lt;&lt;<span class="string">"]&lt;-"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;elements[getTop()]&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="得到栈顶元素"><a href="#得到栈顶元素" class="headerlink" title="得到栈顶元素"></a>得到栈顶元素</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">T</span> <span class="title">Stack</span>&lt;T&gt;:</span>:getTopelements()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> elements[getTop()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="文件相关读写操作"><a href="#文件相关读写操作" class="headerlink" title="文件相关读写操作"></a>文件相关读写操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:writeToFile(<span class="built_in">string</span> filename)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">writefile</span><span class="params">(filename)</span></span>;</span><br><span class="line">T temp[basesize];</span><br><span class="line">T x;</span><br><span class="line"><span class="keyword">int</span> i,count;</span><br><span class="line">count=getTop()+<span class="number">1</span>;</span><br><span class="line">writefile&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">temp[i]=getTopelements();</span><br><span class="line">Pop(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=count<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line">writefile&lt;&lt;temp[j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">Stack</span>&lt;T&gt;:</span>:readFromFile(<span class="built_in">string</span> filename)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">readfile</span><span class="params">(filename)</span></span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">readfile&gt;&gt;len;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">T temp;</span><br><span class="line">readfile&gt;&gt;temp;</span><br><span class="line"><span class="keyword">this</span>-&gt;Push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="利用栈实现字符串的逆序"><a href="#利用栈实现字符串的逆序" class="headerlink" title="利用栈实现字符串的逆序"></a>利用栈实现字符串的逆序</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span> temp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(temp);</span><br><span class="line">Stack&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line"><span class="keyword">char</span> x;</span><br><span class="line"><span class="keyword">char</span> str[len+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//str[len]='\0';</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">st.Push(temp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">str[i]=st.getTopelements();</span><br><span class="line">st.Pop(x);</span><br><span class="line">&#125;</span><br><span class="line">str[len]=<span class="string">'\0'</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"逆序后的字符串为:"</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="利用栈实现括号是否匹配的判断"><a href="#利用栈实现括号是否匹配的判断" class="headerlink" title="利用栈实现括号是否匹配的判断"></a>利用栈实现括号是否匹配的判断</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bracketMatching</span><span class="params">(<span class="keyword">char</span> expression[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(expression);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(expression[i<span class="number">-1</span>]==<span class="string">'('</span>)&#123;</span><br><span class="line"><span class="built_in">stack</span>.Push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(expression[i<span class="number">-1</span>]==<span class="string">')'</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">stack</span>.Pop(j)==<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;j&lt;&lt;<span class="string">"个 “(” 与第"</span>&lt;&lt;i&lt;&lt;<span class="string">"个 “)” 匹配!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"没有与第"</span>&lt;&lt;i&lt;&lt;<span class="string">"个 “)” 匹配的 “(” ！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">stack</span>.isEmpty()==<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="built_in">stack</span>.Pop(j);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"没有与第"</span>&lt;&lt;j&lt;&lt;<span class="string">"个 “(” 匹配的 “)”！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="利用栈实现表达式的求值"><a href="#利用栈实现表达式的求值" class="headerlink" title="利用栈实现表达式的求值"></a>利用栈实现表达式的求值</h2><h3 id="（满足小数，多位数，整数的计算）"><a href="#（满足小数，多位数，整数的计算）" class="headerlink" title="（满足小数，多位数，整数的计算）"></a>（满足小数，多位数，整数的计算）</h3><h3 id="其中最重要的算法实现，中缀表达式转后缀表达式，利用容器保存各个操作数，以便实现多位数，小数的实现"><a href="#其中最重要的算法实现，中缀表达式转后缀表达式，利用容器保存各个操作数，以便实现多位数，小数的实现" class="headerlink" title="其中最重要的算法实现，中缀表达式转后缀表达式，利用容器保存各个操作数，以便实现多位数，小数的实现"></a>其中最重要的算法实现，中缀表达式转后缀表达式，利用容器保存各个操作数，以便实现多位数，小数的实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中缀表达式转后缀表达式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; convert(<span class="built_in">string</span> input)&#123;</span><br><span class="line"></span><br><span class="line">Stack&lt;<span class="keyword">char</span>&gt; stk;<span class="comment">//存储操作符栈</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line"><span class="keyword">char</span> s;</span><br><span class="line"><span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> length = (<span class="keyword">int</span>)input.length();<span class="comment">//获取表达式的长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">tmp = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((input[i]&gt;=<span class="string">'0'</span> &amp;&amp; input[i]&lt;=<span class="string">'9'</span>))&#123;</span><br><span class="line">tmp += input[i];</span><br><span class="line"><span class="keyword">while</span>((i+<span class="number">1</span>&lt;input.size() &amp;&amp; input[i+<span class="number">1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; input[i+<span class="number">1</span>]&lt;=<span class="string">'9'</span>)||input[i+<span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp += input[i+<span class="number">1</span>];<span class="comment">//若是连续数字</span></span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">temp.push_back(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(input[i] == <span class="string">'('</span>)&#123;</span><br><span class="line"><span class="comment">//遇到左括号直接入栈</span></span><br><span class="line">stk.Push(input[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(input[i] == <span class="string">')'</span>)&#123;</span><br><span class="line"><span class="comment">//如果遇到右括号的话，就把一直到最近的左括号之间的都弹出来加入temp中</span></span><br><span class="line"><span class="keyword">while</span>(stk.getTopelements() != <span class="string">'('</span>)&#123;</span><br><span class="line">tmp += stk.getTopelements();</span><br><span class="line">temp.push_back(tmp);</span><br><span class="line">stk.Pop(s);</span><br><span class="line">tmp=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">stk.Pop(s);<span class="comment">//把左括号弹出栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(isMark(input[i]))&#123;</span><br><span class="line"><span class="comment">//如果是运算符的话，比较他们的优先级再决定是否入栈</span></span><br><span class="line"><span class="keyword">while</span>( prior(input[i])&lt;=prior(stk.getTopelements()) )&#123;</span><br><span class="line"><span class="comment">//如果当前的优先级小于等于栈顶操作符的话，栈顶操作符弹出，加入temp</span></span><br><span class="line">tmp += stk.getTopelements();</span><br><span class="line">temp.push_back(tmp);</span><br><span class="line">stk.Pop(s);</span><br><span class="line">tmp=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前的优先级大于栈顶操作符的话，入栈</span></span><br><span class="line">stk.Push(input[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果已经扫描到中缀表达式的末尾，就把栈中的操作符都弹出来加入到temp中</span></span><br><span class="line"><span class="keyword">while</span>(!stk.isEmpty())&#123;</span><br><span class="line">tmp=<span class="string">""</span>;</span><br><span class="line">tmp += stk.getTopelements();</span><br><span class="line">temp.push_back(tmp);</span><br><span class="line">stk.Pop(s);</span><br><span class="line">tmp=<span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="计算表达式的最终结果"><a href="#计算表达式的最终结果" class="headerlink" title="计算表达式的最终结果"></a>计算表达式的最终结果</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算后缀表达式的最终数值</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; retu)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">Stack&lt;<span class="keyword">double</span>&gt; optNum;<span class="comment">//定义一个操作数栈</span></span><br><span class="line"><span class="keyword">double</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> x1,x2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; retu.size(); i++)&#123;<span class="comment">//没有遇到结束标志#，即进行表达式的计算</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> tmp = retu[i];</span><br><span class="line"><span class="keyword">if</span>(tmp[<span class="number">0</span>] &gt;= <span class="string">'0'</span>&amp;&amp;tmp[<span class="number">0</span>] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">num = atof(tmp.c_str());</span><br><span class="line">optNum.Push(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"+"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push(x1+x2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"-"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push(x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"*"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push(x1*x2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"/"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push(x2/x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"%"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push((<span class="keyword">int</span>)x2%(<span class="keyword">int</span>)x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(retu[i] == <span class="string">"^"</span>)&#123;</span><br><span class="line">x1 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">x2 = optNum.getTopelements();</span><br><span class="line">optNum.Pop(s);</span><br><span class="line">optNum.Push(<span class="built_in">pow</span>(x2, x1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> optNum.getTopelements();<span class="comment">//返回最终的计算结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">result</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">str = format(str);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; bh = convert(str);</span><br><span class="line"><span class="keyword">double</span> k = calculate(bh);</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="对“-”号的特殊化处理"><a href="#对“-”号的特殊化处理" class="headerlink" title="对“-”号的特殊化处理"></a>对“-”号的特殊化处理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">format</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.length(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i] == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">str.insert(<span class="number">0</span>,<span class="number">1</span>,<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str[i<span class="number">-1</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">str.insert(i,<span class="number">1</span>,<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(<span class="keyword">char</span> op)</span></span>&#123;<span class="comment">//求运算符优先级</span></span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'^'</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="完整的代码我已经上传到github，有需要的自行clone，有什么错误的地方欢迎大家指出来，共同学习进步。希望得到大家的支持和鼓励，加油！！！（下一篇更新利用qt，栈的表达式求值，写一个简易的计算器）"><a href="#完整的代码我已经上传到github，有需要的自行clone，有什么错误的地方欢迎大家指出来，共同学习进步。希望得到大家的支持和鼓励，加油！！！（下一篇更新利用qt，栈的表达式求值，写一个简易的计算器）" class="headerlink" title="完整的代码我已经上传到github，有需要的自行clone，有什么错误的地方欢迎大家指出来，共同学习进步。希望得到大家的支持和鼓励，加油！！！（下一篇更新利用qt，栈的表达式求值，写一个简易的计算器）"></a>完整的代码我已经上传到github，有需要的自行clone，有什么错误的地方欢迎大家指出来，共同学习进步。希望得到大家的支持和鼓励，加油！！！（下一篇更新利用qt，栈的表达式求值，写一个简易的计算器）</h5><p><a href="https://github.com/xjh199923/Stack.git" target="_blank" rel="noopener">Stack栈实现的相关代码</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接插入排序</title>
      <link href="/posts/20352.html"/>
      <url>/posts/20352.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>直接插入排序,插入排序(insert sort)的基本方法是：每步将一个待排序的元素，按其排序码大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。</p><a id="more"></a><div class="note info"><p>==算法描述:==<br>直接插入排序（insert sort)的基本思想是：当插入第 i (i≥1)个元素时，前面的v[0]，v[1]……..VIi-1]已经排好序：这时，用V[i]的排序码与V[i-1]，V[i一2]，…的排序码顺序进行比较，找到插入位置即将V[i]插人，原来位置上的元素向后顺移。假设其中v[0],…….v[i-1]已经是一组有序的元素，V[i]，V[i+1]，…，V[n-1]是待插入的元素，排序过程从i=1起，每一趟执行完后，i增加1，把第i个元素插入到前面有序的元素序列中去，使插入后元素序列V[0]，V[1]，…V[i]仍保持有序。</p><p>算法过程：</p><p>原始序列：3、44、38、5、47、15、36、 26、27、2、46、4、19、50、48</p><p>放上插入排序的动态图让大家更容易理解这个过程:</p><p><img src="https://img-blog.csdnimg.cn/20191113225534656.gif" alt="在这里插入图片描述"><br>结果：{2、3、4、5、19、26、27、36、38、44、46、47、48、50}</p></div><h2 id="插入排序的C-Java-Python实现"><a href="#插入排序的C-Java-Python实现" class="headerlink" title="插入排序的C++,Java,Python实现"></a>插入排序的C++,Java,Python实现</h2><p><strong>本篇文章会给大家介绍直接插入排序的三种语言的实现，在后面的文章中我会更新其他的插入排序，在这里先给大家分享简单一点的插入排序，循序渐进</strong></p><h3 id="插入排序C-实现代码："><a href="#插入排序C-实现代码：" class="headerlink" title="插入排序C++实现代码："></a>插入排序C++实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100</span>];<span class="comment">//定义一个产生数组储存100个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; randsample=get_random(<span class="number">100</span>,MAX_NUM);<span class="comment">//产生100个0-MAZX_NUM的随机数,每次产生的随机数不一样</span></span><br><span class="line"><span class="keyword">int</span> size=randsample.size();</span><br><span class="line"><span class="comment">//输出最开始时未排序时的顺序:</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"随机数的顺序："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;randsample[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start,finish;<span class="comment">//定义一个测量一段程序运行时间的前后值</span></span><br><span class="line"><span class="keyword">double</span> totaltime;<span class="comment">//总的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试插入排序</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"执行插入排序后:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i]=randsample[i];</span><br><span class="line">&#125;</span><br><span class="line">start=clock();</span><br><span class="line">InsertSort(size);</span><br><span class="line">finish=clock();</span><br><span class="line">output(size);</span><br><span class="line">totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间："</span>&lt;&lt;totaltime&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生随机数的函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(N);<span class="comment">//N代表初始状态分配的空间大小</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out_vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rand_value=rand()%N;</span><br><span class="line">out_vec.push_back(vec[rand_value]);</span><br><span class="line">vec[rand_value]=vec[N<span class="number">-1</span>];<span class="comment">//将数组vec的元素</span></span><br><span class="line">N--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out_vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i]&lt;data[i<span class="number">-1</span>])&#123;</span><br><span class="line">count++;</span><br><span class="line">tmp=data[i];</span><br><span class="line">j=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;tmp&lt;data[j])&#123;</span><br><span class="line">count++;</span><br><span class="line">data[j+<span class="number">1</span>]=data[j];</span><br><span class="line">count1++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">data[j+<span class="number">1</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"比较次数: "</span>&lt;&lt;count&lt;&lt;<span class="string">"  移动次数:  "</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试结果展示：<br><img src="https://img-blog.csdnimg.cn/20191113224207448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="插入排序Java代码实现"><a href="#插入排序Java代码实现" class="headerlink" title="插入排序Java代码实现"></a>插入排序Java代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object []arr = getRandomNumList(<span class="number">100</span>,<span class="number">0</span>,<span class="number">10000</span>).toArray();</span><br><span class="line">    <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>] ;</span><br><span class="line">    System.out.println(<span class="string">"排序前："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      String s=arr[i].toString();</span><br><span class="line">      ins[i]= Integer.parseInt( s );</span><br><span class="line">      System.out.println(ins[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    System.out.println(<span class="string">"排序后："</span>);</span><br><span class="line">    <span class="keyword">int</span>[] ins2 = insertsort(ins);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(ins2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertsort(<span class="keyword">int</span>[] data)&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp;</span><br><span class="line">  <span class="keyword">int</span> n = data.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i]&lt;data[i-<span class="number">1</span>])&#123;</span><br><span class="line">tmp=data[i];</span><br><span class="line">j=i-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;tmp&lt;data[j])&#123;</span><br><span class="line">data[j+<span class="number">1</span>]=data[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">data[j+<span class="number">1</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//定义生成随机数并且装入集合容器的方法</span></span><br><span class="line">    <span class="comment">//方法的形参列表分别为：生成随机数的个数、生成随机数的值的范围最小值为start(包含start)、值得范围最大值为end(不包含end)  可取值范围可表示为[start,end)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">getRandomNumList</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建集合容器对象</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Random对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//循环将得到的随机数进行判断，如果随机数不存在于集合中，则将随机数放入集合中，如果存在，则将随机数丢弃不做操作，进行下一次循环，直到集合长度等于nums</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() != nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = r.nextInt(end-start) + start;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="插入排序Python代码实现"><a href="#插入排序Python代码实现" class="headerlink" title="插入排序Python代码实现"></a>插入排序Python代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>]):</span><br><span class="line">            tmp = nums[i]</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> tmp&lt;nums[j]):</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j]</span><br><span class="line">                j=j<span class="number">-1</span></span><br><span class="line">            nums[j+<span class="number">1</span>]=tmp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    arr =[]</span><br><span class="line">    <span class="keyword">while</span>(len(arr)&lt;<span class="number">100</span>):</span><br><span class="line">        x=random.randint(<span class="number">0</span>,<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> arr:</span><br><span class="line">            arr.append(x)</span><br><span class="line">    InsertSort(arr)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><div class="note info"><p>若设待排序的元素个数为n，则该算法的主程序执行n-1趟。因为排序码比较次数和元素移动次数与元素排序码的初始排列有关，所以在最好情况下，即在排序前元素已经按排序码大小从小到大排好序了，每趟只需与前面的有序元素序列的最后一个元素的排序码比较1次，总的排序码比较次数为n-1，元素移动次数为0。而在最差情况下，即第 i 趟时第 i 个元素必须与前面个元素都做排序码比较，并且每做1次较就要做1次数据移动，则总的排序码比较次数KCN和元素移动次数RMN分别为：</p><p>KCN=$\sum_{i=1}^{n-1}{i}$=n(n-1)/2$\approx$ $n^2$/2.<br>RMN=$\sum_{i=1}^{n-1}{(i+2)}$=(n+4)(n-1)/2$\approx$ $n^2$/2</p><p>从以上讨论可知，直接插入排序的运行时间和待排序元素的原始排列顺序密切相关。若待排序元素序列中出现各种可能排列的概率相同，则可取上述最好情况和最差情况的平均情况。在平均情况下的排序码比较次数和元素移动次数约为$n^2$/4。因此，直接插入插序的时间复杂度为O($n^2$)。直接插入排序是一种稳定的排序方法。</p></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的直接插入排序,后面还会写其他的插入排序，如果有什么不足之处欢迎大家指出，留言，互相学习，共同进步。希望得到大家的支持,你的支持就是我前进的动力,接下来我会持续更新其他的排序算法，敬请期待！(写博客学到了很多东西，嘻嘻)</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> Java </category>
          
          <category> Python </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/posts/15468.html"/>
      <url>/posts/15468.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>希尔排序（Shell sort)这个排序方法又称为缩小增量排序(diminishing increment Sort)，是1959年由D.L.Shell提出来的。该方法的基本思想是：设待排序元素序列有n个元素，首先取一个整数gap&lt;n作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一个子序列中，在每一个子序列中分别施行直接插入排序，然后缩小间距gap.例如取gap=[gap/21，重复上述的子序列划分和排序工作。直到最后取gap==1，将所有元素放在同一个序列中排序为止。由于开始时gap的取值较大，每个子序列中的元素较少，排序速度较快；待到排序的后期，gap取值逐渐变小，子序列中元素个数逐渐变多，但由于前面工作的基础，大多数元素已基本有序，所以排序速度仍然很快。</p><a id="more"></a><div class="note info"><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：<br>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>按增量序列个数k，对序列进行k 趟排序；每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>举个栗子</p><p>原始序列：84、83、88、87、61、50、70、 60、80、99</p><p>1）第一趟，84对应50，50比84小，交换。</p><p>结果：[ 50]、83、88、87、61、[84]、70、 60、80、99</p><p>2） 第二趟，83对应70，70比83小，交换。</p><p>结果：50、[70]、88、87、61、84、[83]、 60、80、99</p><p>3）依次如此，把剩余的都按这样排好。</p><p>结果：50、70、60、80、61、84、83、 88、87、99</p><p>4）缩小间隔步幅为2，分别对其进行插入排序</p><p>结果：50、70、60、80、61、84、83、 88、87、99</p><p>……………</p><p>5）依次类推直到步幅间隔为1</p><p>结果： 50、60、61、70、80、83、84、 87、88、99</p><p>最后如果还没有理解这个过程的话，小编放上一个动图，让大家更深入的理解这个过程：</p><p><img src="https://img-blog.csdnimg.cn/20191115154530231.gif" alt="在这里插入图片描述"></p></div><h2 id="接下来就是希尔排序的算法实现喽"><a href="#接下来就是希尔排序的算法实现喽" class="headerlink" title="接下来就是希尔排序的算法实现喽"></a>接下来就是希尔排序的算法实现喽</h2><h3 id="希尔排序C-实现代码："><a href="#希尔排序C-实现代码：" class="headerlink" title="希尔排序C++实现代码："></a>希尔排序C++实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100</span>];<span class="comment">//定义一个产生数组储存100个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; randsample=get_random(<span class="number">100</span>,MAX_NUM);<span class="comment">//产生100个0-MAZX_NUM的随机数,每次产生的随机数不一样</span></span><br><span class="line"><span class="keyword">int</span> size=randsample.size();</span><br><span class="line"><span class="comment">//输出最开始时未排序时的顺序:</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"随机数的顺序："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;randsample[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start,finish;<span class="comment">//定义一个测量一段程序运行时间的前后值</span></span><br><span class="line"><span class="keyword">double</span> totaltime;<span class="comment">//总的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试希尔排序</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"执行希尔排序后:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i]=randsample[i];</span><br><span class="line">&#125;</span><br><span class="line">start=clock();</span><br><span class="line">ShellSort(size);</span><br><span class="line">finish=clock();</span><br><span class="line">output(size);</span><br><span class="line">totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间："</span>&lt;&lt;totaltime&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生随机数的函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(N);<span class="comment">//N代表初始状态分配的空间大小</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out_vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rand_value=rand()%N;</span><br><span class="line">out_vec.push_back(vec[rand_value]);</span><br><span class="line">vec[rand_value]=vec[N<span class="number">-1</span>];<span class="comment">//将数组vec的元素</span></span><br><span class="line">N--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out_vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> gap=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(gap&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap=gap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//求下一增量值</span></span><br><span class="line"><span class="keyword">for</span>(i=gap;i&lt;n;i++)&#123;<span class="comment">//各个子序列交替处理</span></span><br><span class="line"><span class="keyword">if</span>(data[i]&lt;data[i-gap])&#123;<span class="comment">//逆序</span></span><br><span class="line">    count++;</span><br><span class="line">temp=data[i];</span><br><span class="line">j=i-gap;</span><br><span class="line"><span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;data[j]) &#123;</span><br><span class="line">count++;</span><br><span class="line">data[j+gap]=data[j];<span class="comment">//后移元素</span></span><br><span class="line">count1++;</span><br><span class="line">j=j-gap;<span class="comment">//再比较前一元素</span></span><br><span class="line">&#125;</span><br><span class="line">data[j+gap]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"比较次数: "</span>&lt;&lt;count&lt;&lt;<span class="string">"  移动次数:  "</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img src="https://img-blog.csdnimg.cn/20191115161025158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="希尔排序Java代码实现"><a href="#希尔排序Java代码实现" class="headerlink" title="希尔排序Java代码实现"></a>希尔排序Java代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object []arr = getRandomNumList(<span class="number">100</span>,<span class="number">0</span>,<span class="number">10000</span>).toArray();</span><br><span class="line">    <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>] ;</span><br><span class="line">    System.out.println(<span class="string">"排序前："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      String s=arr[i].toString();</span><br><span class="line">      ins[i]= Integer.parseInt( s );</span><br><span class="line">      System.out.println(ins[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    System.out.println(<span class="string">"排序后："</span>);</span><br><span class="line">    <span class="keyword">int</span>[] ins2 = shellSort(ins);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(ins2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] data)&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n = data.length;</span><br><span class="line"><span class="keyword">int</span> gap=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">while</span>(gap&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">gap=gap/<span class="number">3</span>+<span class="number">1</span>;<span class="comment">//求下一增量值</span></span><br><span class="line"><span class="keyword">for</span>(i=gap;i&lt;n;i++)&#123;<span class="comment">//各个子序列交替处理</span></span><br><span class="line"><span class="keyword">if</span>(data[i]&lt;data[i-gap])&#123;<span class="comment">//逆序</span></span><br><span class="line">temp=data[i];</span><br><span class="line">j=i-gap;</span><br><span class="line"><span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;data[j]) &#123;</span><br><span class="line">data[j+gap]=data[j];<span class="comment">//后移元素</span></span><br><span class="line">j=j-gap;<span class="comment">//再比较前一元素</span></span><br><span class="line">&#125;</span><br><span class="line">data[j+gap]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//定义生成随机数并且装入集合容器的方法</span></span><br><span class="line">    <span class="comment">//方法的形参列表分别为：生成随机数的个数、生成随机数的值的范围最小值为start(包含start)、值得范围最大值为end(不包含end)  可取值范围可表示为[start,end)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">getRandomNumList</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建集合容器对象</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Random对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//循环将得到的随机数进行判断，如果随机数不存在于集合中，则将随机数放入集合中，如果存在，则将随机数丢弃不做操作，进行下一次循环，直到集合长度等于nums</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() != nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = r.nextInt(end-start) + start;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="希尔排序Python代码实现"><a href="#希尔排序Python代码实现" class="headerlink" title="希尔排序Python代码实现"></a>希尔排序Python代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellsort</span><span class="params">(lists)</span>:</span></span><br><span class="line">    <span class="comment">#希尔排序</span></span><br><span class="line">    count = len(lists)</span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    group = round(count / step)</span><br><span class="line">    <span class="keyword">while</span> group &gt; <span class="number">0</span>:  <span class="comment">#通过group增量分组循环</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, group):</span><br><span class="line">            j = i + group</span><br><span class="line">            <span class="keyword">while</span> j &lt; count:  <span class="comment">#分组中key值的索引，通过增量自增</span></span><br><span class="line">                k = j - group</span><br><span class="line">                key = lists[j]</span><br><span class="line">                <span class="keyword">while</span> k &gt;= <span class="number">0</span>:  <span class="comment">#分组中进行插入排序</span></span><br><span class="line">                    <span class="keyword">if</span> lists[k] &gt; key:</span><br><span class="line">                        lists[k + group], lists[k] = lists[k], key</span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">                    k -= group</span><br><span class="line">                j += group</span><br><span class="line">        group = round(group/step)</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    arr =[]</span><br><span class="line">    <span class="keyword">while</span>(len(arr)&lt;<span class="number">100</span>):</span><br><span class="line">        x=random.randint(<span class="number">0</span>,<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> arr:</span><br><span class="line">            arr.append(x)</span><br><span class="line">    shellsort(arr)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><div class="note info"><pre><code>增量gap的取法有各种方案。最初Shell提出gap=n/2,gap=gap/2,直到gap=1.但由直到最后一步，在奇数位置的元素才会与偶数位置的元素进行比较，这样使这个序列的效率将很低。后来Knuth提出取gap=gap/3+1。还有人提出都取为好，也有人提出各gap互质为好。应用不同的序列会使希尔排序算法的性能有很大差异，有些序列的效率会明显更高，例如：1，8，23，77,281，1073，4193，16577。</code></pre><p>对希尔排序的时间复杂度的分析很困难，在特定情况下可以准确地估算排序码的次数和元素移动次数，但想要弄清排序码比较次数和元素移动次数与增量选择之间的依赖关系，并给出完整的数学分析，还没有人能够做到。<br>由于即使对于规模较大的序列（n&lt;=1000)，希尔排序都具有很高的效率。并且希尔排序算法的代码简单，容易执行，所以很多排序应用程序都选用了希尔排序算法。希尔排序是一种不稳定的排序算法。</p></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的希尔排序的几种实现,如果有什么不足之处欢迎大家指出，留言。如果有什么写的不好的地方欢迎大家补充，希望得到大家的支持,,下面我会持续更新其他的排序算法，敬请期待!<br>(博客在今天开通了评论功能，欢迎大家一起来讨论交流啊!)</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> Java </category>
          
          <category> Python </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/posts/21238.html"/>
      <url>/posts/21238.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><p>排序算法之冒泡排序,冒泡排序，冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><a id="more"></a><div class="note info"><p>==算法描述:==<br>起泡排序的基本方法是：设待排序元素序列中的元素个数为n，首先比较第n-2个元素和第n-1个元素，如果发生逆序，即前一个大于后一个)，则将这两个元素交换；然后对第n-3个和第n-2个元素（可能是刚交换过来的）做同样处理；重复此过程直到处理完第0个和第1个元素。我们称它为一趟起泡，结果将最小的元素交换到待排序元素序列的第一个位置，其他元素也都向排序的最终位置移动。当然在个别情形下，元素有可能在排序中途向相反的方向移动，但元素移动的总趋势是向最终位置移动。正因为每一趟起泡就把一个排序码小的元素前移到它最后应在的位置，所以叫做起泡排序。这样最多做n一1趟起泡就能把所有元素排好序。</p><p>算法过程：</p><p>原始序列：3、44、38、5、47、15、36、 26、27、2、46、4、19、50、48</p><p>我们需要 拿第一个和第二个对比 如果第一个比第二个大那么就换位置，如果小就不换，接下来拿第二个和第三个…..这样依次下去比到最后 我们把这些数中最大的一个放在了右边， 然后再重复以上的方式下去就这些数只第二个大的放在了倒数第二位，依次下去..</p><p>1、比较相邻的元素。如果第一个比第二个大（小），就交换他们两个。</p><p>2、对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大（小）的数。</p><p>3、针对所有的元素重复以上的步骤，除了最后已经选出的元素（有序）。</p><p>4、持续每次对越来越少的元素（无序元素）重复上面的步骤，直到没有任何一对数字需要比较，则序列最终有序。</p><p>结果：{2、3、4、5、19、26、27、36、38、44、46、47、48、50}</p><p>冒泡排序个人认为是最简单的一个排序，也挺容易记住的，过程中会发生大量的交换，就没有像选择排序那样写步骤，如果大家还没有理解这个过程的话，小编依旧放上一个动图，让大家更深入的理解这个过程：</p><p><img src="https://img-blog.csdnimg.cn/20191113090100467.gif" alt="在这里插入图片描述"></p></div><h2 id="冒泡排序的C-Java-Python实现"><a href="#冒泡排序的C-Java-Python实现" class="headerlink" title="冒泡排序的C++,Java,Python实现"></a>冒泡排序的C++,Java,Python实现</h2><p><strong>因为小编也是java,python的初学者，写的不好的地方请大家见谅，后面的各大算法都会加入一个随机数的产生，基本上的实现大致相同，除了排序算法会变之外</strong></p><h3 id="冒泡排序C-实现代码："><a href="#冒泡排序C-实现代码：" class="headerlink" title="冒泡排序C++实现代码："></a>冒泡排序C++实现代码：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NUM=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100</span>];<span class="comment">//定义一个产生数组储存100个随机数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeSort</span><span class="params">(<span class="keyword">int</span> n)</span></span>;<span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; randsample=get_random(<span class="number">100</span>,MAX_NUM);<span class="comment">//产生100个0-MAZX_NUM的随机数,每次产生的随机数不一样</span></span><br><span class="line"><span class="keyword">int</span> size=randsample.size();</span><br><span class="line"><span class="comment">//输出最开始时未排序时的顺序:</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"随机数的顺序："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;randsample[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">clock_t</span> start,finish;<span class="comment">//定义一个测量一段程序运行时间的前后值</span></span><br><span class="line"><span class="keyword">double</span> totaltime;<span class="comment">//总的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试冒泡排序</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"执行冒泡排序后:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;randsample.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">data[i]=randsample[i];</span><br><span class="line">&#125;</span><br><span class="line">start=clock();</span><br><span class="line">ExchangeSort(size);</span><br><span class="line">finish=clock();</span><br><span class="line">output(size);</span><br><span class="line">totaltime=(<span class="keyword">double</span>)(finish-start)/CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间："</span>&lt;&lt;totaltime&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产生随机数的函数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_random(<span class="keyword">int</span> n, <span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(N);<span class="comment">//N代表初始状态分配的空间大小</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out_vec;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">&#123;</span><br><span class="line">vec[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> rand_value=rand()%N;</span><br><span class="line">out_vec.push_back(vec[rand_value]);</span><br><span class="line">vec[rand_value]=vec[N<span class="number">-1</span>];<span class="comment">//将数组vec的元素</span></span><br><span class="line">N--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> out_vec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡排序，又称选择排序,加入一个exchange来改进排序时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExchangeSort</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> count1=<span class="number">0</span>;<span class="comment">//count,count1分别用来计算比较次数和移动次数</span></span><br><span class="line"><span class="keyword">int</span> tem;</span><br><span class="line"><span class="keyword">bool</span> exchange;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">exchange=<span class="literal">false</span>;<span class="comment">//检查前假设没有发生排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line">count++;</span><br><span class="line">Swap(i, j);</span><br><span class="line">count1++;</span><br><span class="line">exchange=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(exchange==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"比较次数: "</span>&lt;&lt;count&lt;&lt;<span class="string">"  移动次数:  "</span>&lt;&lt;count1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tem;</span><br><span class="line">tem = data[j];</span><br><span class="line">data[j]= data[i];</span><br><span class="line">data[i] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>测试结果展示：</p><p><a href="https://imgchr.com/i/M8xU9U" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/M8xU9U.md.png" alt="M8xU9U.md.png"></a></p><h3 id="排序Java代码实现"><a href="#排序Java代码实现" class="headerlink" title="排序Java代码实现"></a>排序Java代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Object []arr = getRandomNumList(<span class="number">100</span>,<span class="number">0</span>,<span class="number">10000</span>).toArray();</span><br><span class="line">    <span class="keyword">int</span>[] ins = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>] ;</span><br><span class="line">    System.out.println(<span class="string">"排序前："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      String s=arr[i].toString();</span><br><span class="line">      ins[i]= Integer.parseInt( s );</span><br><span class="line">      System.out.println(ins[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    System.out.println(<span class="string">"排序后："</span>);</span><br><span class="line">    <span class="keyword">int</span>[] ins2 = exchangesort(ins);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(ins2[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] exchangesort(<span class="keyword">int</span>[] data)&#123;</span><br><span class="line"><span class="keyword">int</span> exchange;</span><br><span class="line"><span class="keyword">int</span> n = data.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">exchange=<span class="number">0</span>;<span class="comment">//检查前假设没有发生排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(data[i]&gt;data[j])&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">temp = data[j];</span><br><span class="line">data[j]= data[i];</span><br><span class="line">data[i] = temp;</span><br><span class="line">exchange=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(exchange==<span class="number">0</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//定义生成随机数并且装入集合容器的方法</span></span><br><span class="line">    <span class="comment">//方法的形参列表分别为：生成随机数的个数、生成随机数的值的范围最小值为start(包含start)、值得范围最大值为end(不包含end)  可取值范围可表示为[start,end)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">getRandomNumList</span><span class="params">(<span class="keyword">int</span> nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建集合容器对象</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Random对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//循环将得到的随机数进行判断，如果随机数不存在于集合中，则将随机数放入集合中，如果存在，则将随机数丢弃不做操作，进行下一次循环，直到集合长度等于nums</span></span><br><span class="line">        <span class="keyword">while</span>(list.size() != nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = r.nextInt(end-start) + start;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(num))&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="冒泡排序Python代码实现"><a href="#冒泡排序Python代码实现" class="headerlink" title="冒泡排序Python代码实现"></a>冒泡排序Python代码实现</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExchangeSort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        ex_flag = <span class="literal">False</span>  <span class="comment"># 改进后的冒泡，设置一个交换标志位</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) - i - <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                ex_flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ex_flag:</span><br><span class="line">            <span class="keyword">return</span> nums  <span class="comment"># 这里代表计算机偷懒成功 (〃'▽'〃)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums  <span class="comment"># ExchangeSort这里代表计算机没有偷懒成功 o(╥﹏╥)o</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    arr =[]</span><br><span class="line">    <span class="keyword">while</span>(len(arr)&lt;<span class="number">100</span>):</span><br><span class="line">        x=random.randint(<span class="number">0</span>,<span class="number">10000</span>)</span><br><span class="line">        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> arr:</span><br><span class="line">            arr.append(x)</span><br><span class="line">    ExchangeSort(arr)</span><br><span class="line">    print(arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><div class="note info"><p>起泡排序中，第i趟起泡中需要执行n一i次比较和交换操作。因此，从1到n一1，执行行的比较操作的次数为：</p><p><strong><font color="#5cb85c">(n-1)+(n-2)+…+2+1=n*(n-1)/2</font></strong><br>从排序的执行过程中可以看到基本的起泡排序的数据比较次数与输人序列中各待排序元素的初始排列无关，但数据的交换次数与各待排序元素的初始排列有关，它与逆序的发生有关，最好情况下可能一次也不交换，最差情况下每一次比较都需要交换。</p><p>为此，在算法中可增加一个标志exchange,用以标识本趟起泡结果是否发生了逆序和交换。如果没有发生交换则exchange=false，表示全部元素已经排好序，因而可以停止处理，结束算法；如果xchange=true,表示本趟有元素发生交换，还需执行下一趟排序。</p><p>在做了这样的改进之后，如果元素序列已经有序，那么只需要一趟起泡，算法就顺利结束了。因此，对于改进的起泡算法，最好的情况下需要n次比较和0次交换操作，而在一般情况最差情况下，排序算法大约需要$n^2$/2次比较和交换操作.</p></div><div class="note success"><p><strong><font color="#5cb85c">继续加油!</font></strong></p><p>以上就是本次给大家分享的冒泡排序的几种语言的实现,如果有什么不足之处欢迎大家指出，留言，互相学习，共同进步。希望得到大家的支持,你的支持就是我前进的动力,接下来我会持续更新其他的排序算法，敬请期待！</p></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
          <category> Java </category>
          
          <category> Python </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> Java </tag>
            
            <tag> Python </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的相关实现</title>
      <link href="/posts/14311.html"/>
      <url>/posts/14311.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 17:59:57 GMT+0800 (中国标准时间) --><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><strong><em>二叉搜索树实现了以下功能<br>1.计算二叉搜索树的大小<br>2.前中后递归遍历二叉搜索树<br>3.前中后非递归遍历二叉搜索树<br>4.层序遍历二叉搜索树<br>5.二叉搜索树叶子个数<br>6.二叉搜索树的深度<br>7.二叉搜索树的结点的度<br>8.二叉搜索树的双亲以及左右子女的查找<br>9.查找某一节点<br>10.插入新的结点<br>11.删除某一节点<br>12.判断是否为平衡树</em></strong><br><img src="https://img-blog.csdnimg.cn/20191030231545417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzM2Mzkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h3 id="定义一个结点结构体"><a href="#定义一个结点结构体" class="headerlink" title="定义一个结点结构体"></a>定义一个结点结构体</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二叉搜索树的节点结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  BinaryTreeNode &lt;T&gt;* _left;</span><br><span class="line">  BinaryTreeNode &lt;T&gt;* _right;</span><br><span class="line">  T _data;</span><br><span class="line">  BinaryTreeNode(T &amp;data)</span><br><span class="line">    :_left(<span class="literal">NULL</span>)</span><br><span class="line">    ,_right(<span class="literal">NULL</span>)</span><br><span class="line">    ,_data(data)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="封装的相关函数"><a href="#封装的相关函数" class="headerlink" title="封装的相关函数"></a>封装的相关函数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* _root;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参的构造函数</span></span><br><span class="line">    BinarySearchTree()</span><br><span class="line">    :_root(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    BinarySearchTree(<span class="built_in">vector</span>&lt;T&gt; v)</span><br><span class="line">    &#123;</span><br><span class="line">      _root=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">      &#123;</span><br><span class="line">        insert(_root,v[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制构造函数</span></span><br><span class="line">    BinarySearchTree(<span class="keyword">const</span> BinarySearchTree&lt;T&gt; &amp;s)</span><br><span class="line">    &#123;_root=CopyBintTree(s.GetRoot());&#125;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* GetRoot()</span><br><span class="line">    &#123;<span class="keyword">return</span>  <span class="keyword">this</span>-&gt;_root;&#125;</span><br><span class="line">    <span class="comment">//递归先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrevOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//非递归先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrevOrder_NonR</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//递归中序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//非递归中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder_NonR</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//递归后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//非递归后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrder_NonR</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//层序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Leve1Order</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//二叉搜索树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//递归求二叉搜索树叶子节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LeafSize</span><span class="params">(BinaryTreeNode&lt;T&gt;* root)</span></span>;</span><br><span class="line">    <span class="comment">//求节点的度</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DegreeofNode</span><span class="params">(T tmp)</span></span>;</span><br><span class="line">    <span class="comment">//求节点的层次</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BinaryTreeNode&lt;T&gt;* root,<span class="keyword">int</span> val,<span class="keyword">int</span> &amp;ans,<span class="keyword">int</span> lev)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLevelofNode</span><span class="params">(T tmp)</span></span>;</span><br><span class="line">    <span class="comment">//二叉搜索树的复制</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* CopyBintTree(BinaryTreeNode&lt;T&gt;* originNode);</span><br><span class="line">    <span class="comment">//寻找二叉搜索树某一节点的双亲</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ParentofNode</span><span class="params">(BinaryTreeNode&lt;T&gt;* r,T data)</span></span>;</span><br><span class="line">    <span class="comment">//寻找二叉搜索树某一节点的左子女</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* LeftChildofNode(T tmp);</span><br><span class="line">    <span class="comment">//寻找二叉搜索树某一节点的右子女</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* RightChildofNode(T tmp);</span><br><span class="line">    <span class="comment">//查找某一个结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt;* FindNode(T tmp,BinaryTreeNode&lt;T&gt;* &amp;root);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(BinaryTreeNode&lt;T&gt;* &amp;root, T val)</span></span>;<span class="comment">//二叉搜索树的插入一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(T val)</span></span>;<span class="comment">//删除某一个结点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(T x)</span></span>;<span class="comment">//二叉搜索树的搜索</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; * Remove(BinaryTreeNode&lt;T&gt; * &amp;root,T val);<span class="comment">//二叉搜索树的删除结点</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(BinaryTreeNode&lt;T&gt; * &amp;root)</span></span>;<span class="comment">//判断是否为平衡二叉树</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="各个函数的实现"><a href="#各个函数的实现" class="headerlink" title="各个函数的实现"></a>各个函数的实现</h3><h4 id="前中后序遍历的递归实现"><a href="#前中后序遍历的递归实现" class="headerlink" title="前中后序遍历的递归实现"></a>前中后序遍历的递归实现</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PrevOrder(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;root-&gt;_data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  PrevOrder(root-&gt;_left );</span><br><span class="line">  PrevOrder(root-&gt;_right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:InOrder(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  InOrder(root-&gt;_left );</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;root-&gt;_data &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  InOrder(root-&gt;_right );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PostOrder(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    PostOrder(root-&gt;_left);</span><br><span class="line">    PostOrder(root-&gt;_right);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;_data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="前中后序遍历的非递归实现"><a href="#前中后序遍历的非递归实现" class="headerlink" title="前中后序遍历的非递归实现"></a>前中后序遍历的非递归实现</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PrevOrder_NonR()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">  BinaryTreeNode&lt;T&gt;* cur=_root;</span><br><span class="line">  <span class="keyword">while</span>(cur||!s.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur)</span><br><span class="line">    &#123;<span class="comment">//先将左子树遍历输出后压栈</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cur-&gt;_data &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    s.push(cur);</span><br><span class="line">    cur=cur-&gt;_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//当左子树为空时开始访问右子树</span></span><br><span class="line">    cur=s.top ();</span><br><span class="line">    s.pop();</span><br><span class="line">    cur=cur-&gt;_right;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:InOrder_NonR()</span><br><span class="line">&#123;</span><br><span class="line">  BinaryTreeNode&lt;T&gt;* cur=_root;</span><br><span class="line">  <span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">    <span class="keyword">while</span>(cur||!s.empty())<span class="comment">//cur非空或者栈非空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur)</span><br><span class="line">      &#123;</span><br><span class="line">        s.push(cur);<span class="comment">//根节点进栈遍历左子树</span></span><br><span class="line">        cur=cur-&gt;_left;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt;* top=s.top();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;top-&gt;_data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        cur=top-&gt;_right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:PostOrder_NonR()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">stack</span>&lt;BinaryTreeNode&lt;T&gt;*&gt; s;</span><br><span class="line">  BinaryTreeNode&lt;T&gt;* cur=_root;</span><br><span class="line">  BinaryTreeNode&lt;T&gt;* prev=<span class="literal">NULL</span>;<span class="comment">//设置标志域</span></span><br><span class="line">  s.push(_root);</span><br><span class="line">  <span class="keyword">while</span>(!s.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    cur=s.top();</span><br><span class="line">    <span class="keyword">if</span>((cur-&gt;_left ==<span class="literal">NULL</span>&amp;&amp;cur-&gt;_right ==<span class="literal">NULL</span>)</span><br><span class="line">      ||(prev!=<span class="literal">NULL</span>&amp;&amp;(prev==cur-&gt;_left ||prev ==cur-&gt;_right )))</span><br><span class="line">    &#123;  </span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;cur-&gt;_data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      prev=cur;</span><br><span class="line">      s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_right!=<span class="literal">NULL</span>)</span><br><span class="line">      s.push(cur-&gt;_right);</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_left!=<span class="literal">NULL</span>)</span><br><span class="line">      s.push(cur-&gt;_left); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h4><p>按层次顺序访问二叉树的处理需要利用一个队列。<br>在访问二又树的某一层结点时，把下一层结点指针预先<br>记忆在队列中，利用队列安排逐层访问的次序。因此，每<br>当访问一个结点时，将它的子女依次加到队列的队尾，然<br>后再访问已在队列队头的结点。这样可以实现二叉树结<br>点的按层访问</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Leve1Order()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt;q;</span><br><span class="line">  <span class="keyword">if</span>(_root!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    q.push(_root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* front=q.front();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;front-&gt;_data &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">if</span>(front-&gt;_left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      q.push(front-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(front-&gt;_right!=<span class="literal">NULL</span>)</span><br><span class="line">    q.push(front-&gt;_right);</span><br><span class="line">    q.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求树的大小"><a href="#求树的大小" class="headerlink" title="求树的大小"></a>求树的大小</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Size(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> Ssize=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ++Ssize;</span><br><span class="line">  Size(root-&gt;_left);</span><br><span class="line">  Size(root-&gt;_right);</span><br><span class="line">  <span class="keyword">return</span> Ssize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Depth(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> left=Depth(root-&gt;_left )+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">size_t</span> right=Depth(root-&gt;_right)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (left&gt;right)?left:right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求树的叶子个数"><a href="#求树的叶子个数" class="headerlink" title="求树的叶子个数"></a>求树的叶子个数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:LeafSize(BinaryTreeNode&lt;T&gt;* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;_left  ==<span class="literal">NULL</span>&amp;&amp;root-&gt;_right ==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> LeafSize(root-&gt;_left )+LeafSize(root-&gt;_right );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求树的各个结点的度"><a href="#求树的各个结点的度" class="headerlink" title="求树的各个结点的度"></a>求树的各个结点的度</h4><p>利用二叉树的层次遍历方法来统计各个节点的度</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:DegreeofNode(T tmp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt;q;</span><br><span class="line">    <span class="keyword">if</span>(_root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      q.push(_root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      BinaryTreeNode&lt;T&gt;* cur=q.front();</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_data==tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>((cur-&gt;_left==<span class="literal">NULL</span>&amp;&amp;cur-&gt;_right!=<span class="literal">NULL</span>)||(cur-&gt;_left!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;_right==<span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;_left==<span class="literal">NULL</span>&amp;&amp;cur-&gt;_right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q.push(cur-&gt;_left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(cur-&gt;_right!=<span class="literal">NULL</span>)</span><br><span class="line">      q.push(cur-&gt;_right);</span><br><span class="line">      q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="复制搜索二叉树"><a href="#复制搜索二叉树" class="headerlink" title="复制搜索二叉树"></a>复制搜索二叉树</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BinaryTreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:CopyBintTree(BinaryTreeNode&lt;T&gt;* originNode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(originNode==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BinaryTreeNode&lt;T&gt;* temp=<span class="keyword">new</span> BinaryTreeNode&lt;T&gt;;</span><br><span class="line">  temp-&gt;_data=originNode-&gt;_data;</span><br><span class="line">  temp-&gt;_left=CopyBintTree(originNode-&gt;_left);</span><br><span class="line">  temp-&gt;_right=CopyBintTree(originNode-&gt;_right);</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求某一结点的双亲及左右子女"><a href="#求某一结点的双亲及左右子女" class="headerlink" title="求某一结点的双亲及左右子女"></a>求某一结点的双亲及左右子女</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:ParentofNode(BinaryTreeNode&lt;T&gt;* r,T data)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(r ==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r-&gt;_left != <span class="literal">NULL</span>)<span class="comment">//当左孩子存在的时候才进行判断，否则程序出错</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;_left-&gt;_data == data)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"这个节点的双亲结点是:"</span>&lt;&lt;r-&gt;_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r-&gt;_right != <span class="literal">NULL</span>)<span class="comment">//如左子树所示</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;_right-&gt;_data == data)    </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"这个节点的双亲结点是:"</span>&lt;&lt;r-&gt;_data&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ParentofNode(r-&gt;_left,data);</span><br><span class="line">  ParentofNode(r-&gt;_right,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BinaryTreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>: LeftChildofNode(T tmp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt;q;</span><br><span class="line">  <span class="keyword">if</span>(_root!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    q.push(_root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* cur=q.front();</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_data==tmp&amp;&amp;cur-&gt;_left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> cur-&gt;_left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      q.push(cur-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_right!=<span class="literal">NULL</span>)</span><br><span class="line">    q.push(cur-&gt;_right);</span><br><span class="line">    q.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BinaryTreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:RightChildofNode(T tmp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;BinaryTreeNode&lt;T&gt;*&gt;q;</span><br><span class="line">  <span class="keyword">if</span>(_root!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    q.push(_root);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt;* cur=q.front();</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_data==tmp&amp;&amp;cur-&gt;_right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> cur-&gt;_right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">      q.push(cur-&gt;_left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;_right!=<span class="literal">NULL</span>)</span><br><span class="line">    q.push(cur-&gt;_right);</span><br><span class="line">    q.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="求某一结点的层次"><a href="#求某一结点的层次" class="headerlink" title="求某一结点的层次"></a>求某一结点的层次</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:level(BinaryTreeNode&lt;T&gt;* root,<span class="keyword">int</span> val,<span class="keyword">int</span> &amp;ans,<span class="keyword">int</span> lev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span>==root)</span><br><span class="line">    ans=<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;_data==val)</span><br><span class="line">    ans=lev;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    level(root-&gt;_left,val,ans,lev+<span class="number">1</span>);<span class="comment">//在左子树中查找</span></span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">      level(root-&gt;_right,val,ans,lev+<span class="number">1</span>);<span class="comment">//在右子树中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">int</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:GetLevelofNode(T tmp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> res=<span class="number">-1</span>;</span><br><span class="line">  level(_root,tmp,res,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="查找搜索某一个结点"><a href="#查找搜索某一个结点" class="headerlink" title="查找搜索某一个结点"></a>查找搜索某一个结点</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span>  <span class="title">BinaryTreeNode</span>&lt;T&gt;* <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:FindNode(T tmp,BinaryTreeNode&lt;T&gt;* &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;root-&gt;_data)&#123;</span><br><span class="line">    <span class="keyword">return</span> FindNode(tmp,root-&gt;_left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;root-&gt;_data)&#123;</span><br><span class="line">      <span class="keyword">return</span> FindNode(tmp,root-&gt;_right);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Search(T x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;FindNode(x,_root)==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="插入一个新的结点"><a href="#插入一个新的结点" class="headerlink" title="插入一个新的结点"></a>插入一个新的结点</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:insert(BinaryTreeNode&lt;T&gt;* &amp;root, T val)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    root=<span class="keyword">new</span> BinaryTreeNode&lt;T&gt;(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(val&lt;root-&gt;_data)&#123;</span><br><span class="line">    insert(root-&gt;_left,val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(val&gt;root-&gt;_data)&#123;</span><br><span class="line">      insert(root-&gt;_right,val);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="删除指定结点"><a href="#删除指定结点" class="headerlink" title="删除指定结点"></a>删除指定结点</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">BinaryTreeNode</span>&lt;T&gt; * <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Remove(BinaryTreeNode&lt;T&gt; * &amp;root,T val)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;_data &gt; val)</span><br><span class="line">      root-&gt;_left = Remove(root-&gt;_left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_data &lt; val)</span><br><span class="line">      root-&gt;_right = Remove(root-&gt;_right, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (root-&gt;_left == <span class="literal">NULL</span>&amp;&amp;root-&gt;_right == <span class="literal">NULL</span>)</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_left == <span class="literal">NULL</span>)</span><br><span class="line">        root = root-&gt;_right;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_right == <span class="literal">NULL</span>)</span><br><span class="line">        root = root-&gt;_left;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        BinaryTreeNode&lt;T&gt; *minnode = root-&gt;_right;</span><br><span class="line">        <span class="keyword">while</span> (minnode-&gt;_left != <span class="literal">NULL</span>)</span><br><span class="line">          minnode = minnode-&gt;_left;</span><br><span class="line">        root-&gt;_data = minnode-&gt;_data;</span><br><span class="line">        root-&gt;_right = Remove(root-&gt;_right, minnode-&gt;_data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:Delete(T val)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Search(val))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Remove(_root, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="是否为平衡树"><a href="#是否为平衡树" class="headerlink" title="是否为平衡树"></a>是否为平衡树</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">bool</span> <span class="title">BinarySearchTree</span>&lt;T&gt;:</span>:isBalanced(BinaryTreeNode&lt;T&gt; * &amp;root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!root-&gt;_left &amp;&amp; !root-&gt;_right)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(Size(root-&gt;_left) - Size(root-&gt;_right)) &gt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> isBalanced(root-&gt;_left) &amp;&amp; isBalanced(root-&gt;_right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h5 id="每一次写博客都是学习过程的记录，有什么问题大家提出来！我们一起讨论，欢迎留言！"><a href="#每一次写博客都是学习过程的记录，有什么问题大家提出来！我们一起讨论，欢迎留言！" class="headerlink" title="每一次写博客都是学习过程的记录，有什么问题大家提出来！我们一起讨论，欢迎留言！"></a>每一次写博客都是学习过程的记录，有什么问题大家提出来！我们一起讨论，欢迎留言！</h5><p><a href="https://github.com/xjh199923/BinarySearchTree.git" target="_blank" rel="noopener">项目源代码传送门</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
            <tag> 类模板 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
